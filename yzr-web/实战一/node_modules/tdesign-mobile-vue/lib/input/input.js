/**
 * tdesign v0.12.1
 * (c) 2022 TDesign Group
 * @license MIT
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
var _slicedToArray = require('@babel/runtime/helpers/slicedToArray');
var tdesignIconsVueNext = require('tdesign-icons-vue-next');
var vue = require('vue');
var core = require('@vueuse/core');
var cell_index = require('../cell/index.js');
var config = require('../config.js');
var input_props = require('./props.js');
var shared_constants = require('../shared/constants.js');
var shared_renderTnode = require('../shared/render-tnode.js');
var shared_component = require('../shared/component.js');
var shared_util = require('../shared/util.js');
var shared_useEmitEvent_index = require('../shared/useEmitEvent/index.js');
var shared_useDefault_index = require('../shared/useDefault/index.js');
var shared_render = require('../shared/render.js');
require('../cell/cell.js');
require('../cell/props.js');
require('lodash/camelCase');
require('@babel/runtime/helpers/typeof');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);
var _slicedToArray__default = /*#__PURE__*/_interopDefaultLegacy(_slicedToArray);

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty__default["default"](target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
var prefix = config["default"].prefix;
var componentName = "".concat(prefix, "-input");
var script = vue.defineComponent({
  name: componentName,
  components: {
    TNode: shared_renderTnode["default"],
    TCell: cell_index["default"],
    CloseCircleFilledIcon: tdesignIconsVueNext.CloseCircleFilledIcon
  },
  props: input_props["default"],
  emits: ["update:value", "update:modelValue", "click-icon", "focus", "blur", "change", "clear"],
  setup: function setup(props, context) {
    var emitEvent = shared_useEmitEvent_index.useEmitEvent(props, context.emit);
    var inputRef = vue.ref();
    var _toRefs = vue.toRefs(props),
      autofocus = _toRefs.autofocus;
    var internalInstance = vue.getCurrentInstance();
    var _useDefault = shared_useDefault_index.useDefault(props, context.emit, "value", "change"),
      _useDefault2 = _slicedToArray__default["default"](_useDefault, 1),
      innerValue = _useDefault2[0];
    var styleLabel = vue.computed(function () {
      var _ref;
      return _ref = {}, _defineProperty__default["default"](_ref, "".concat(componentName, "--label"), true), _defineProperty__default["default"](_ref, shared_constants["default"].STATUS.disabled, props.disabled), _ref;
    });
    var _useFocus = core.useFocus(inputRef, {
        initialValue: props.autofocus
      }),
      focused = _useFocus.focused;
    var labelContent = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "label");
    });
    var suffixIconContent = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "suffixIcon");
    });
    var prefixIconContent = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "prefixIcon");
    });
    var suffixContent = vue.computed(function () {
      return shared_render.renderTNode(internalInstance, "suffix");
    });
    var styleControl = vue.computed(function () {
      return ["".concat(componentName, "__control"), _defineProperty__default["default"]({}, "".concat(componentName, "__control--").concat(props.align), props.align !== "left")];
    });
    var styleWrapper = vue.computed(function () {
      var _ref3;
      return _ref3 = {}, _defineProperty__default["default"](_ref3, componentName, true), _defineProperty__default["default"](_ref3, "".concat(componentName, "--size-").concat(props.size), props.size), _defineProperty__default["default"](_ref3, "".concat(componentName, "__error"), !!props.errorMessage), _ref3;
    });
    var setInputValue = function setInputValue() {
      var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
      var input = inputRef.value;
      var sV = String(v);
      if (!input) {
        return;
      }
      if (input.value !== sV) {
        input.value = sV;
      }
    };
    var handleInput = function handleInput(e) {
      var checkInputType = e.inputType && e.inputType === "insertCompositionText";
      if (e.isComposing || checkInputType) return;
      inputValueChangeHandle(e);
    };
    var inputValueChangeHandle = function inputValueChangeHandle(e) {
      var value = e.target.value;
      var maxcharacter = props.maxcharacter;
      if (maxcharacter && maxcharacter > 0 && !Number.isNaN(maxcharacter)) {
        var _getCharacterLength = shared_util.getCharacterLength(value, maxcharacter);
          _getCharacterLength.length;
          var _getCharacterLength$c = _getCharacterLength.characters,
          characters = _getCharacterLength$c === void 0 ? "" : _getCharacterLength$c;
        innerValue.value = characters;
      } else {
        innerValue.value = value;
      }
      vue.nextTick(function () {
        return setInputValue(innerValue.value);
      });
    };
    var focus = function focus() {
      focused.value = true;
    };
    var blur = function blur() {
      focused.value = false;
    };
    shared_component.extendAPI({
      focus: focus,
      blur: blur
    });
    var handleClear = function handleClear(e) {
      innerValue.value = "";
      focused.value = true;
      emitEvent("clear", {
        e: e
      });
    };
    var handleFocus = function handleFocus(e) {
      emitEvent("focus", innerValue.value, {
        e: e
      });
    };
    var handleBlur = function handleBlur(e) {
      emitEvent("blur", innerValue.value, {
        e: e
      });
    };
    var handleCompositionend = function handleCompositionend(e) {
      inputValueChangeHandle(e);
    };
    vue.watch(autofocus, function (autofocus2, prevAutofocus) {
      if (autofocus2 === true) {
        vue.nextTick(function () {
          focused.value = true;
        });
      }
    });
    return _objectSpread(_objectSpread({
      componentName: componentName
    }, vue.toRefs(props)), {}, {
      styleLabel: styleLabel,
      styleWrapper: styleWrapper,
      styleControl: styleControl,
      suffixContent: suffixContent,
      suffixIconContent: suffixIconContent,
      prefixIconContent: prefixIconContent,
      labelContent: labelContent,
      innerValue: innerValue,
      inputRef: inputRef,
      handleClear: handleClear,
      handleFocus: handleFocus,
      handleBlur: handleBlur,
      handleInput: handleInput,
      handleCompositionend: handleCompositionend
    });
  }
});

var _hoisted_1 = ["value", "name", "type", "disabled", "autocomplete", "placeholder", "readonly", "maxlength"];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_t_node = vue.resolveComponent("t-node");
  var _component_close_circle_filled_icon = vue.resolveComponent("close-circle-filled-icon");
  var _component_t_cell = vue.resolveComponent("t-cell");
  return vue.openBlock(), vue.createBlock(_component_t_cell, {
    required: _ctx.required,
    class: vue.normalizeClass(_ctx.styleWrapper)
  }, vue.createSlots({
    note: vue.withCtx(function () {
      return [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap"))
      }, [vue.createElementVNode("input", {
        ref: "inputRef",
        value: _ctx.innerValue,
        name: _ctx.name,
        class: vue.normalizeClass(_ctx.styleControl),
        type: _ctx.type,
        disabled: _ctx.disabled,
        autocomplete: _ctx.autocomplete ? "On" : "Off",
        placeholder: _ctx.placeholder,
        readonly: _ctx.readonly,
        maxlength: _ctx.maxlength || -1,
        onFocus: _cache[0] || (_cache[0] = function () {
          return _ctx.handleFocus && _ctx.handleFocus.apply(_ctx, arguments);
        }),
        onBlur: _cache[1] || (_cache[1] = function () {
          return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
        }),
        onInput: _cache[2] || (_cache[2] = function () {
          return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
        }),
        onCompositionend: _cache[3] || (_cache[3] = function () {
          return _ctx.handleCompositionend && _ctx.handleCompositionend.apply(_ctx, arguments);
        })
      }, null, 42, _hoisted_1), _ctx.clearable && _ctx.innerValue && _ctx.innerValue.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--icon")),
        onClick: _cache[4] || (_cache[4] = function () {
          return _ctx.handleClear && _ctx.handleClear.apply(_ctx, arguments);
        })
      }, [vue.createVNode(_component_close_circle_filled_icon)], 2)) : vue.createCommentVNode("", true), _ctx.suffixContent ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 1,
        class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--suffix"))
      }, [vue.createVNode(_component_t_node, {
        content: _ctx.suffixContent
      }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2), _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.componentName, "__error-msg"))
      }, vue.toDisplayString(_ctx.errorMessage), 3)) : vue.createCommentVNode("", true)];
    }),
    _: 2
  }, [_ctx.labelContent ? {
    name: "title",
    fn: vue.withCtx(function () {
      return [vue.createElementVNode("div", {
        class: vue.normalizeClass(_ctx.styleLabel)
      }, [vue.createVNode(_component_t_node, {
        content: _ctx.labelContent
      }, null, 8, ["content"])], 2)];
    }),
    key: "0"
  } : void 0, _ctx.prefixIconContent ? {
    name: "leftIcon",
    fn: vue.withCtx(function () {
      return [vue.createVNode(_component_t_node, {
        content: _ctx.prefixIconContent
      }, null, 8, ["content"])];
    }),
    key: "1"
  } : void 0, _ctx.suffixIconContent ? {
    name: "rightIcon",
    fn: vue.withCtx(function () {
      return [vue.createVNode(_component_t_node, {
        content: _ctx.suffixIconContent
      }, null, 8, ["content"])];
    }),
    key: "2"
  } : void 0]), 1032, ["required", "class"]);
}

script.render = render;

exports["default"] = script;
//# sourceMappingURL=input.js.map
