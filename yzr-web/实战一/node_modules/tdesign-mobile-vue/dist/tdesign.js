/**
 * tdesign v0.12.1
 * (c) 2022 TDesign Group
 * @license MIT
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TDesign = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function ownKeys$19(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$19(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$19(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$19(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function camel2Kebab(camelString) {
    var covertArr = ["fillOpacity", "fillRule", "clipRule"];
    if (covertArr.includes(camelString)) {
      return camelString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
    }
    return camelString;
  }
  function renderFn(node, props) {
    var kebabAttrs = Object.keys(node.attrs).reduce(function (result, key) {
      result[camel2Kebab(key)] = node.attrs[key];
      return result;
    }, {});
    return vue.h(node.tag, _objectSpread$19(_objectSpread$19({}, kebabAttrs), props), (node.children || []).map(function (child) {
      return renderFn(child, {});
    }));
  }

  var DEFAULT_CLASS_PREFIX = "t";
  var DEFAULT_LOCALE = "zh-CN";
  var ConfigContext = {
    classPrefix: DEFAULT_CLASS_PREFIX,
    locale: DEFAULT_LOCALE
  };

  function useCommonClassName() {
    var classPrefix = ConfigContext.classPrefix;
    return {
      SIZE: {
        default: "",
        xs: "".concat(classPrefix, "-size-xs"),
        small: "".concat(classPrefix, "-size-s"),
        medium: "".concat(classPrefix, "-size-m"),
        large: "".concat(classPrefix, "-size-l"),
        xl: "".concat(classPrefix, "-size-xl"),
        block: "".concat(classPrefix, "-size-full-width")
      },
      STATUS: {
        loading: "".concat(classPrefix, "-is-loading"),
        disabled: "".concat(classPrefix, "-is-disabled"),
        focused: "".concat(classPrefix, "-is-focused"),
        success: "".concat(classPrefix, "-is-success"),
        error: "".concat(classPrefix, "-is-error"),
        warning: "".concat(classPrefix, "-is-warning"),
        selected: "".concat(classPrefix, "-is-selected"),
        active: "".concat(classPrefix, "-is-active"),
        checked: "".concat(classPrefix, "-is-checked"),
        current: "".concat(classPrefix, "-is-current"),
        hidden: "".concat(classPrefix, "-is-hidden"),
        visible: "".concat(classPrefix, "-is-visible"),
        expanded: "".concat(classPrefix, "-is-expanded"),
        indeterminate: "".concat(classPrefix, "-is-indeterminate")
      }
    };
  }

  function useSizeProps(size) {
    var COMMON_SIZE_CLASS_NAMES = useCommonClassName().SIZE;
    var className = vue.computed(function () {
      if (size.value in COMMON_SIZE_CLASS_NAMES) {
        return COMMON_SIZE_CLASS_NAMES[size.value];
      }
      return "";
    });
    var style = vue.computed(function () {
      if (size.value === void 0 || size.value in COMMON_SIZE_CLASS_NAMES) {
        return {};
      }
      return {
        fontSize: size.value
      };
    });
    return {
      style: style,
      className: className
    };
  }

  function ownKeys$18(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$18(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$18(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$18(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$p = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.35 8.65v3.85h1.3V8.65h3.85v-1.3H8.65V3.5h-1.3v3.85H3.5v1.3h3.85z",
        "fillOpacity": 0.9
      }
    }]
  };
  var add = vue.defineComponent({
    name: "AddIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-add", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$18(_objectSpread$18({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$p, finalProps.value);
      };
    }
  });

  function ownKeys$17(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$17(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$17(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$17(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$o = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M2 3h12V2H2v1zM3.38 10.23l4.1-4.03v8.64H8.5V6.2l4.18 4.08.71-.7-5.05-4.93a.5.5 0 00-.7 0l-4.98 4.9.72.69z",
        "fillOpacity": 0.9
      }
    }]
  };
  var backtop = vue.defineComponent({
    name: "BacktopIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-backtop", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$17(_objectSpread$17({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$o, finalProps.value);
      };
    }
  });

  function ownKeys$16(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$16(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$16(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$16(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$n = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M11 6H5l3 4.5L11 6z",
        "fillOpacity": 0.9
      }
    }]
  };
  var caretDownSmall = vue.defineComponent({
    name: "CaretDownSmallIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-caret-down-small", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$16(_objectSpread$16({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$n, finalProps.value);
      };
    }
  });

  function ownKeys$15(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$15(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$15(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$15(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$m = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zM4.5 8.2l.7-.7L7 9.3l3.8-3.8.7.7L7 10.7 4.5 8.2z",
        "fillOpacity": 0.9
      }
    }]
  };
  var checkCircleFilled = vue.defineComponent({
    name: "CheckCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$15(_objectSpread$15({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$m, finalProps.value);
      };
    }
  });

  function ownKeys$14(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$14(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$14(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$14(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$l = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.5 8.2L7 10.7l4.5-4.5-.7-.7L7 9.3 5.2 7.5l-.7.7z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.11 2.18a7 7 0 117.78 11.64A7 7 0 014.1 2.18zm.56 10.8a6 6 0 106.66-9.97A6 6 0 004.67 13z",
        "fillOpacity": 0.9
      }
    }]
  };
  var checkCircle = vue.defineComponent({
    name: "CheckCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$14(_objectSpread$14({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$l, finalProps.value);
      };
    }
  });

  function ownKeys$13(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$13(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$13(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$13(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$k = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M6.43 9.92l6.23-6.22.92.92-7.15 7.14L1.97 7.3l.92-.92 3.54 3.54z",
        "fillOpacity": 0.9
      }
    }]
  };
  var check = vue.defineComponent({
    name: "CheckIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$13(_objectSpread$13({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$k, finalProps.value);
      };
    }
  });

  function ownKeys$12(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$12(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$12(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$j = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3.54 6.46l.92-.92L8 9.08l3.54-3.54.92.92L8 10.92 3.54 6.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronDown = vue.defineComponent({
    name: "ChevronDownIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-down", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$12(_objectSpread$12({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$j, finalProps.value);
      };
    }
  });

  function ownKeys$11(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$11(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$11(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$11(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$i = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.54 3.54l.92.92L6.92 8l3.54 3.54-.92.92L5.08 8l4.46-4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronLeft = vue.defineComponent({
    name: "ChevronLeftIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-left", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$11(_objectSpread$11({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$i, finalProps.value);
      };
    }
  });

  function ownKeys$10(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$10(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$10(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$10(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$h = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M6.46 12.46l-.92-.92L9.08 8 5.54 4.46l.92-.92L10.92 8l-4.46 4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronRight = vue.defineComponent({
    name: "ChevronRightIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-right", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$10(_objectSpread$10({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$h, finalProps.value);
      };
    }
  });

  function ownKeys$$(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$$(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$$(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$$(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$g = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12.46 9.54l-.92.92L8 6.92l-3.54 3.54-.92-.92L8 5.08l4.46 4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronUp = vue.defineComponent({
    name: "ChevronUpIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-up", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$$(_objectSpread$$({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$g, finalProps.value);
      };
    }
  });

  function ownKeys$_(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$_(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$_(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$_(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$f = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1a7 7 0 110 14A7 7 0 018 1zm0 1a6 6 0 100 12A6 6 0 008 2z",
        "opacity": 0.9,
        "fillOpacity": 0.9
      }
    }]
  };
  var circle = vue.defineComponent({
    name: "CircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$_(_objectSpread$_({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$f, finalProps.value);
      };
    }
  });

  function ownKeys$Z(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Z(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Z(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Z(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$e = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zM5.67 4.95L8 7.29l2.33-2.34.7.7L8.7 8l2.34 2.35-.71.7L8 8.71l-2.33 2.34-.7-.7L7.3 8 4.96 5.65l.71-.7z",
        "fillOpacity": 0.9
      }
    }]
  };
  var closeCircleFilled = vue.defineComponent({
    name: "CloseCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Z(_objectSpread$Z({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$e, finalProps.value);
      };
    }
  });

  function ownKeys$Y(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Y(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Y(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Y(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$d = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.98 10.31L7.3 8 5 5.69l.7-.7L8 7.28 10.31 5l.7.7L8.72 8l2.3 2.31-.7.7L8 8.72 5.69 11l-.7-.7z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1a7 7 0 110 14A7 7 0 018 1zm0 1a6 6 0 100 12A6 6 0 008 2z",
        "fillOpacity": 0.9
      }
    }]
  };
  var closeCircle = vue.defineComponent({
    name: "CloseCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Y(_objectSpread$Y({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$d, finalProps.value);
      };
    }
  });

  function ownKeys$X(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$X(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$X(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$X(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$c = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z",
        "fillOpacity": 0.9
      }
    }]
  };
  var close = vue.defineComponent({
    name: "CloseIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$X(_objectSpread$X({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$c, finalProps.value);
      };
    }
  });

  function ownKeys$W(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$W(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$W(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$W(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$b = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3 9a1 1 0 110-2 1 1 0 010 2zM7 8a1 1 0 102 0 1 1 0 00-2 0zM12 8a1 1 0 102 0 1 1 0 00-2 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var ellipsis = vue.defineComponent({
    name: "EllipsisIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-ellipsis", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$W(_objectSpread$W({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$b, finalProps.value);
      };
    }
  });

  function ownKeys$V(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$V(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$V(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$V(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$a = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zM8.5 4v5.5h-1V4h1zm-1.1 7h1.2v1.2H7.4V11z",
        "fillOpacity": 0.9
      }
    }]
  };
  var errorCircleFilled = vue.defineComponent({
    name: "ErrorCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-error-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$V(_objectSpread$V({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$a, finalProps.value);
      };
    }
  });

  function ownKeys$U(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$U(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$U(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$U(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$9 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8.5 4v5.5h-1V4h1zM8.6 10.5H7.4v1.2h1.2v-1.2z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zm-1 0A6 6 0 112 8a6 6 0 0112 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var errorCircle = vue.defineComponent({
    name: "ErrorCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-error-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$U(_objectSpread$U({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$9, finalProps.value);
      };
    }
  });

  function ownKeys$T(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$T(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$T(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$T(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$8 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zM7.4 4h1.2v1.2H7.4V4zm.1 2.5h1V12h-1V6.5z",
        "fillOpacity": 0.9
      }
    }]
  };
  var infoCircleFilled = vue.defineComponent({
    name: "InfoCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-info-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$T(_objectSpread$T({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$8, finalProps.value);
      };
    }
  });

  function ownKeys$S(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$S(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$S(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$S(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$7 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.5 12V6.5h1V12h-1zM8.6 4H7.4v1.2h1.2V4z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M1 8a7 7 0 1014 0A7 7 0 001 8zm1 0a6 6 0 1112 0A6 6 0 012 8z",
        "fillOpacity": 0.9
      }
    }]
  };
  var infoCircle = vue.defineComponent({
    name: "InfoCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-info-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$S(_objectSpread$S({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$7, finalProps.value);
      };
    }
  });

  function ownKeys$R(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$R(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$R(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$R(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$6 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1.5a6.5 6.5 0 000 13v-1.63A4.87 4.87 0 1112.88 8h1.62A6.5 6.5 0 008 1.5z",
        "fillOpacity": 0.9
      }
    }]
  };
  var loading = vue.defineComponent({
    name: "LoadingIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-loading", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$R(_objectSpread$R({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$6, finalProps.value);
      };
    }
  });

  function ownKeys$Q(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Q(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Q(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$5 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zm3.5-6.5h-7v-1h7v1z",
        "fillOpacity": 0.9,
        "fillRule": "evenodd",
        "clipRule": "evenodd"
      }
    }]
  };
  var minusCircleFilled = vue.defineComponent({
    name: "MinusCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-minus-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Q(_objectSpread$Q({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$5, finalProps.value);
      };
    }
  });

  function ownKeys$P(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$P(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$P(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$P(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$4 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 2.71c2.9 0 5.25 2.36 5.25 5.29h.96a6.2 6.2 0 00-11.5-3.28V2.64h-.96v3.1c0 .29.22.5.5.5h3.09v-.96H3.49A5.25 5.25 0 018 2.71zM1.79 8h.96a5.25 5.25 0 009.76 2.71h-1.85v-.96h3.09c.28 0 .5.22.5.5v3.1h-.96v-2.07A6.2 6.2 0 011.8 8z",
        "fillOpacity": 0.9
      }
    }]
  };
  var refresh = vue.defineComponent({
    name: "RefreshIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-refresh", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$P(_objectSpread$P({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$4, finalProps.value);
      };
    }
  });

  function ownKeys$O(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$O(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$O(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$O(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$3 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3.5 7.35h9v1.3h-9v-1.3z",
        "fillOpacity": 0.9
      }
    }]
  };
  var remove = vue.defineComponent({
    name: "RemoveIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-remove", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$O(_objectSpread$O({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$3, finalProps.value);
      };
    }
  });

  function ownKeys$N(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$N(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$N(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$N(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$2 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.51 10.22a4.76 4.76 0 11.7-.7l3.54 3.52-.7.71-3.54-3.53zm.77-3.7a3.76 3.76 0 10-7.53 0 3.76 3.76 0 007.53 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var search = vue.defineComponent({
    name: "SearchIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-search", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$N(_objectSpread$N({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$2, finalProps.value);
      };
    }
  });

  function ownKeys$M(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$M(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$M(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$M(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$1 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.6 1.82a.45.45 0 01.8 0l1.8 3.65 4.03.58c.37.05.52.5.25.77l-2.91 2.84.69 4a.45.45 0 01-.66.48L8 12.25l-3.6 1.9a.45.45 0 01-.65-.48l.68-4.01-2.9-2.84a.45.45 0 01.24-.77l4.03-.58 1.8-3.65z",
        "fillOpacity": 0.9
      }
    }]
  };
  var starFilled = vue.defineComponent({
    name: "StarFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-star-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$M(_objectSpread$M({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$1, finalProps.value);
      };
    }
  });

  function ownKeys$L(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$L(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$L(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$L(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.54 6.38L8 3.26 6.46 6.38l-3.44.5L5.5 9.31l-.59 3.43L8 11.12l3.08 1.62-.59-3.43L13 6.88l-3.45-.5zm5-.29a.3.3 0 01.16.52l-3.13 3.05.74 4.3a.3.3 0 01-.44.32L8 12.25l-3.87 2.03a.3.3 0 01-.43-.31l.73-4.31L1.3 6.6a.3.3 0 01.17-.52l4.33-.62 1.93-3.92a.3.3 0 01.54 0l1.94 3.92 4.32.62z",
        "fillOpacity": 0.9
      }
    }]
  };
  var star = vue.defineComponent({
    name: "StarIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-star", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$L(_objectSpread$L({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element, finalProps.value);
      };
    }
  });

  var NOOP = function NOOP() {};

  function isArray$a(x) {
    return Array.isArray(x);
  }
  function isNumber(x) {
    return Object.prototype.toString.call(x) === "[object Number]";
  }
  function isObject$5(x) {
    return x === null ? false : Object.prototype.toString.call(x) === "[object Object]";
  }
  function isFunction$3(x) {
    return Object.prototype.toString.call(x) === "[object Function]";
  }
  var inBrowser = typeof window !== "undefined";
  function getCharacterLength(str, maxCharacter) {
    var hasMaxCharacter = typeof maxCharacter === "number";
    if (!str || str.length === 0) {
      if (hasMaxCharacter) {
        return {
          length: 0,
          characters: str
        };
      }
      return 0;
    }
    var len = 0;
    for (var i = 0; i < str.length; i++) {
      var currentStringLength = 0;
      if (str.charCodeAt(i) > 127 || str.charCodeAt(i) === 94) {
        currentStringLength = 2;
      } else {
        currentStringLength = 1;
      }
      if (hasMaxCharacter && len + currentStringLength > maxCharacter) {
        return {
          length: len,
          characters: str.slice(0, i)
        };
      }
      len += currentStringLength;
    }
    if (hasMaxCharacter) {
      return {
        length: len,
        characters: str
      };
    }
    return len;
  }

  var withInstall = function withInstall(comp) {
    var c = comp;
    c.install = function (app, name) {
      var defaultName = c.name;
      app.component(name || defaultName, comp);
    };
    return c;
  };
  function extendAPI(apis) {
    var instance = vue.getCurrentInstance();
    if (instance && instance.proxy) {
      Object.assign(instance.proxy, apis);
    }
  }

  var config = {
    prefix: "t"
  };

  var prefix$17 = config.prefix;
  var SIZE_CLASSNAMES = {
    small: "".concat(prefix$17, "-size-s"),
    medium: "".concat(prefix$17, "-size-m"),
    large: "".concat(prefix$17, "-size-l"),
    default: "",
    xs: "".concat(prefix$17, "-size-xs"),
    xl: "".concat(prefix$17, "-size-xl"),
    block: "".concat(prefix$17, "-size-full-width")
  };
  var STATUS_CLASSNAMES = {
    loading: "".concat(prefix$17, "-is-loading"),
    disabled: "".concat(prefix$17, "-is-disabled"),
    focused: "".concat(prefix$17, "-is-focused"),
    success: "".concat(prefix$17, "-is-success"),
    error: "".concat(prefix$17, "-is-error"),
    warning: "".concat(prefix$17, "-is-warning"),
    selected: "".concat(prefix$17, "-is-selected"),
    active: "".concat(prefix$17, "-is-active"),
    checked: "".concat(prefix$17, "-is-checked"),
    current: "".concat(prefix$17, "-is-current"),
    hidden: "".concat(prefix$17, "-is-hidden"),
    visible: "".concat(prefix$17, "-is-visible"),
    expanded: "".concat(prefix$17, "-is-expanded"),
    indeterminate: "".concat(prefix$17, "-is-indeterminate")
  };
  var ClASSNAMES = {
    SIZE: SIZE_CLASSNAMES,
    STATUS: STATUS_CLASSNAMES
  };

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var freeGlobal$1 = _typeof$1(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$8 = freeGlobal || freeSelf || Function('return this')();
  var _root = root$8;

  var root$7 = _root;

  /** Built-in value references. */
  var _Symbol2 = root$7.Symbol;
  var _Symbol$4 = _Symbol2;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap$3(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  var _arrayMap = arrayMap$3;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$9 = Array.isArray;
  var isArray_1 = isArray$9;

  var _Symbol$3 = _Symbol$4;

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$b.toString;

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol$3 ? _Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$a.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }
  var _objectToString = objectToString$1;

  var _Symbol$2 = _Symbol$4,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = _Symbol$2 ? _Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$5(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var _baseGetTag = baseGetTag$5;

  function isObjectLike$6(value) {
    return value != null && _typeof$1(value) == 'object';
  }
  var isObjectLike_1 = isObjectLike$6;

  var baseGetTag$4 = _baseGetTag,
    isObjectLike$5 = isObjectLike_1;

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$4(value) {
    return _typeof$1(value) == 'symbol' || isObjectLike$5(value) && baseGetTag$4(value) == symbolTag$1;
  }
  var isSymbol_1 = isSymbol$4;

  var _Symbol$1 = _Symbol$4,
    arrayMap$2 = _arrayMap,
    isArray$8 = isArray_1,
    isSymbol$3 = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol$1 ? _Symbol$1.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString$1(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$8(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap$2(value, baseToString$1) + '';
    }
    if (isSymbol$3(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }
  var _baseToString = baseToString$1;

  var baseToString = _baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$5(value) {
    return value == null ? '' : baseToString(value);
  }
  var toString_1 = toString$5;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice$1(array, start, end) {
    var index = -1,
      length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  var _baseSlice = baseSlice$1;

  var baseSlice = _baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice$1(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  var _castSlice = castSlice$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = "\\ud800-\\udfff",
    rsComboMarksRange$3 = "\\u0300-\\u036f",
    reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = "\\ufe0e\\ufe0f";

  /** Used to compose unicode capture groups. */
  var rsZWJ$2 = "\\u200d";

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode$2(string) {
    return reHasUnicode.test(string);
  }
  var _hasUnicode = hasUnicode$2;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray$1(string) {
    return string.split('');
  }
  var _asciiToArray = asciiToArray$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = "\\ud800-\\udfff",
    rsComboMarksRange$2 = "\\u0300-\\u036f",
    reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = "\\ufe0e\\ufe0f";

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ$1 = "\\u200d";

  /** Used to compose unicode regexes. */
  var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray$1(string) {
    return string.match(reUnicode) || [];
  }
  var _unicodeToArray = unicodeToArray$1;

  var asciiToArray = _asciiToArray,
    hasUnicode$1 = _hasUnicode,
    unicodeToArray = _unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray$1(string) {
    return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  var _stringToArray = stringToArray$1;

  var castSlice = _castSlice,
    hasUnicode = _hasUnicode,
    stringToArray = _stringToArray,
    toString$4 = toString_1;

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst$1(methodName) {
    return function (string) {
      string = toString$4(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  var _createCaseFirst = createCaseFirst$1;

  var createCaseFirst = _createCaseFirst;

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst$1 = createCaseFirst('toUpperCase');
  var upperFirst_1 = upperFirst$1;

  var toString$3 = toString_1,
    upperFirst = upperFirst_1;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize$1(string) {
    return upperFirst(toString$3(string).toLowerCase());
  }
  var capitalize_1 = capitalize$1;

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce$1(array, iteratee, accumulator, initAccum) {
    var index = -1,
      length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  var _arrayReduce = arrayReduce$1;

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf$1(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }
  var _basePropertyOf = basePropertyOf$1;

  var basePropertyOf = _basePropertyOf;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter$1 = basePropertyOf(deburredLetters);
  var _deburrLetter = deburrLetter$1;

  var deburrLetter = _deburrLetter,
    toString$2 = toString_1;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange$1 = "\\u0300-\\u036f",
    reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

  /** Used to compose unicode capture groups. */
  var rsCombo$1 = '[' + rsComboRange$1 + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo$1, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('dj vu');
   * // => 'deja vu'
   */
  function deburr$1(string) {
    string = toString$2(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }
  var deburr_1 = deburr$1;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords$1(string) {
    return string.match(reAsciiWord) || [];
  }
  var _asciiWords = asciiWords$1;

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord$1(string) {
    return reHasUnicodeWord.test(string);
  }
  var _hasUnicodeWord = hasUnicodeWord$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = "\\u2700-\\u27bf",
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = "\\u2000-\\u206f",
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = "\\ufe0e\\ufe0f",
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = "\\u200d";

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords$1(string) {
    return string.match(reUnicodeWord) || [];
  }
  var _unicodeWords = unicodeWords$1;

  var asciiWords = _asciiWords,
    hasUnicodeWord = _hasUnicodeWord,
    toString$1 = toString_1,
    unicodeWords = _unicodeWords;

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words$1(string, pattern, guard) {
    string = toString$1(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  var words_1 = words$1;

  var arrayReduce = _arrayReduce,
    deburr = deburr_1,
    words = words_1;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder$1(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }
  var _createCompounder = createCompounder$1;

  var capitalize = capitalize_1,
    createCompounder = _createCompounder;

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  var camelCase_1 = camelCase;

  var renderTNode = function renderTNode(instance, name, options) {
    var _instance$slots$name3;
    if (instance === null) {
      return vue.h("", null);
    }
    var params = _typeof$1(options) === "object" && "params" in options ? options.params : null;
    var defaultNode = _typeof$1(options) === "object" && "defaultNode" in options ? options.defaultNode : options;
    var propsNode;
    if (name in instance.props || camelCase_1(name) in instance.props) {
      propsNode = instance.props[name] || instance.props[camelCase_1(name)];
    }
    if (instance.slots[name]) {
      var _instance$slots$name;
      return (_instance$slots$name = instance.slots[name]) === null || _instance$slots$name === void 0 ? void 0 : _instance$slots$name.call(params);
    }
    if (propsNode === true && defaultNode) {
      var _instance$slots$name2;
      return instance.slots[name] ? (_instance$slots$name2 = instance.slots[name]) === null || _instance$slots$name2 === void 0 ? void 0 : _instance$slots$name2.call(params) : defaultNode;
    }
    if (typeof propsNode === "function") return propsNode(vue.h, params);
    var isPropsEmpty = [void 0, params, ""].includes(propsNode);
    if (isPropsEmpty && instance.slots[name]) return (_instance$slots$name3 = instance.slots[name]) === null || _instance$slots$name3 === void 0 ? void 0 : _instance$slots$name3.call(params);
    return propsNode;
  };
  var renderContent = function renderContent(instance, name1, name2, options) {
    if (instance === null) {
      return vue.h("", null);
    }
    var params = _typeof$1(options) === "object" && "params" in options ? options.params : null;
    var defaultNode = _typeof$1(options) === "object" && "defaultNode" in options ? options.defaultNode : options;
    var toParams = params ? {
      params: params
    } : void 0;
    var node1 = renderTNode(instance, name1, toParams);
    var node2 = renderTNode(instance, name2, toParams);
    var r = [void 0, null, ""].includes(node1) ? node2 : node1;
    return [void 0, null, ""].includes(r) ? defaultNode : r;
  };

  var TNodeComponent = function TNodeComponent(props) {
    return props.content;
  };
  TNodeComponent.props = ["content"];

  function useToggle(values, defaultValue) {
    var innerValues = values || [true, false];
    var state = vue.ref();
    if (defaultValue === void 0) {
      state = vue.ref(innerValues[1]);
    } else if (vue.isRef(defaultValue)) {
      state = defaultValue;
    } else {
      state = vue.ref(defaultValue);
    }
    var toggle = function toggle(value) {
      if (value !== void 0) {
        state.value = value;
      } else {
        state.value = state.value === innerValues[1] ? innerValues[0] : innerValues[1];
      }
    };
    return {
      state: state,
      toggle: toggle
    };
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);

  (function (module) {
    var _typeof$1 = _typeof.exports["default"];
    function _regeneratorRuntime() {

      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
        return generator._invoke = function (innerFn, self, context) {
          var state = "suspendedStart";
          return function (method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");
            if ("completed" === state) {
              if ("throw" === method) throw arg;
              return doneResult();
            }
            for (context.method = method, context.arg = arg;;) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }
              if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                if ("suspendedStart" === state) throw state = "completed", context.arg;
                context.dispatchException(context.arg);
              } else "return" === context.method && context.abrupt("return", context.arg);
              state = "executing";
              var record = tryCatch(innerFn, self, context);
              if ("normal" === record.type) {
                if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                return {
                  value: record.arg,
                  done: context.done
                };
              }
              "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
          };
        }(innerFn, self, context), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg,
              value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        this._invoke = function (method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function (resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1,
              next = function next() {
                for (; ++i < iterable.length;) {
                  if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                }
                return next.value = undefined, next.done = !0, next;
              };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
              record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);

  // TODO(Babel 8): Remove this file.

  var runtime = regeneratorRuntime$1.exports();
  var regenerator = runtime;

  // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  var _a;
  var isClient = typeof window !== "undefined";
  var isDef = function isDef(val) {
    return typeof val !== "undefined";
  };
  var isString = function isString(val) {
    return typeof val === "string";
  };
  var noop = function noop() {};
  isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function tryOnScopeDispose(fn) {
    if (vue.getCurrentScope()) {
      vue.onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function tryOnMounted(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (vue.getCurrentInstance()) vue.onMounted(fn);else if (sync) fn();else vue.nextTick(fn);
  }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  function unrefElement(elRef) {
    var _a;
    var plain = vue.unref(elRef);
    return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
  }
  var defaultWindow = isClient ? window : void 0;
  function useEventListener() {
    var target;
    var event;
    var listener;
    var options;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (isString(args[0])) {
      event = args[0];
      listener = args[1];
      options = args[2];
      target = defaultWindow;
    } else {
      target = args[0];
      event = args[1];
      listener = args[2];
      options = args[3];
    }
    if (!target) return noop;
    var _cleanup = noop;
    var stopWatch = vue.watch(function () {
      return unrefElement(target);
    }, function (el) {
      _cleanup();
      if (!el) return;
      el.addEventListener(event, listener, options);
      _cleanup = function cleanup() {
        el.removeEventListener(event, listener, options);
        _cleanup = noop;
      };
    }, {
      immediate: true,
      flush: "post"
    });
    var stop = function stop() {
      stopWatch();
      _cleanup();
    };
    tryOnScopeDispose(stop);
    return stop;
  }
  function onClickOutside(target, handler) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _options$window = options.window,
      window = _options$window === void 0 ? defaultWindow : _options$window,
      ignore = options.ignore,
      _options$capture = options.capture,
      capture = _options$capture === void 0 ? true : _options$capture,
      _options$detectIframe = options.detectIframe,
      detectIframe = _options$detectIframe === void 0 ? false : _options$detectIframe;
    if (!window) return;
    var shouldListen = vue.ref(true);
    var fallback;
    var listener = function listener(event) {
      window.clearTimeout(fallback);
      var el = unrefElement(target);
      var composedPath = event.composedPath();
      if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value) return;
      if (ignore && ignore.length > 0) {
        if (ignore.some(function (target2) {
          var el2 = unrefElement(target2);
          return el2 && (event.target === el2 || composedPath.includes(el2));
        })) return;
      }
      handler(event);
    };
    var cleanup = [useEventListener(window, "click", listener, {
      passive: true,
      capture: capture
    }), useEventListener(window, "pointerdown", function (e) {
      var el = unrefElement(target);
      shouldListen.value = !!el && !e.composedPath().includes(el);
    }, {
      passive: true
    }), useEventListener(window, "pointerup", function (e) {
      if (e.button === 0) {
        var path = e.composedPath();
        e.composedPath = function () {
          return path;
        };
        fallback = window.setTimeout(function () {
          return listener(e);
        }, 50);
      }
    }, {
      passive: true
    }), detectIframe && useEventListener(window, "blur", function (event) {
      var _a;
      var el = unrefElement(target);
      if (((_a = document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(document.activeElement))) handler(event);
    })].filter(Boolean);
    var stop = function stop() {
      return cleanup.forEach(function (fn) {
        return fn();
      });
    };
    return stop;
  }
  function templateRef(key) {
    var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var instance = vue.getCurrentInstance();
    var _trigger = function _trigger() {};
    var element = vue.customRef(function (track, trigger) {
      _trigger = trigger;
      return {
        get: function get() {
          var _a, _b;
          track();
          return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
        },
        set: function set() {}
      };
    });
    tryOnMounted(_trigger);
    vue.onUpdated(_trigger);
    return element;
  }
  function useActiveElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$window2 = options.window,
      window = _options$window2 === void 0 ? defaultWindow : _options$window2;
    var counter = vue.ref(0);
    if (window) {
      useEventListener(window, "blur", function () {
        return counter.value += 1;
      }, true);
      useEventListener(window, "focus", function () {
        return counter.value += 1;
      }, true);
    }
    return vue.computed(function () {
      counter.value;
      return window == null ? void 0 : window.document.activeElement;
    });
  }
  var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var globalKey = "__vueuse_ssr_handlers__";
  _global[globalKey] = _global[globalKey] || {};
  _global[globalKey];
  var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
  var __hasOwnProp$e = Object.prototype.hasOwnProperty;
  var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
  var __objRest$2 = function __objRest$2(source, exclude) {
    var target = {};
    for (var prop in source) {
      if (__hasOwnProp$e.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    }
    if (source != null && __getOwnPropSymbols$e) {
      var _iterator10 = _createForOfIteratorHelper(__getOwnPropSymbols$e(source)),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var prop = _step10.value;
          if (exclude.indexOf(prop) < 0 && __propIsEnum$e.call(source, prop)) target[prop] = source[prop];
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
    return target;
  };
  function useResizeObserver(target, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a = options,
      _a$window = _a.window,
      window = _a$window === void 0 ? defaultWindow : _a$window,
      observerOptions = __objRest$2(_a, ["window"]);
    var observer;
    var isSupported = window && "ResizeObserver" in window;
    var cleanup = function cleanup() {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    var stopWatch = vue.watch(function () {
      return unrefElement(target);
    }, function (el) {
      cleanup();
      if (isSupported && window && el) {
        observer = new ResizeObserver(callback);
        observer.observe(el, observerOptions);
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var stop = function stop() {
      cleanup();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported: isSupported,
      stop: stop
    };
  }
  function useElementBounding(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$reset = options.reset,
      reset = _options$reset === void 0 ? true : _options$reset,
      _options$windowResize = options.windowResize,
      windowResize = _options$windowResize === void 0 ? true : _options$windowResize,
      _options$windowScroll = options.windowScroll,
      windowScroll = _options$windowScroll === void 0 ? true : _options$windowScroll,
      _options$immediate = options.immediate,
      immediate = _options$immediate === void 0 ? true : _options$immediate;
    var height = vue.ref(0);
    var bottom = vue.ref(0);
    var left = vue.ref(0);
    var right = vue.ref(0);
    var top = vue.ref(0);
    var width = vue.ref(0);
    var x = vue.ref(0);
    var y = vue.ref(0);
    function update() {
      var el = unrefElement(target);
      if (!el) {
        if (reset) {
          height.value = 0;
          bottom.value = 0;
          left.value = 0;
          right.value = 0;
          top.value = 0;
          width.value = 0;
          x.value = 0;
          y.value = 0;
        }
        return;
      }
      var rect = el.getBoundingClientRect();
      height.value = rect.height;
      bottom.value = rect.bottom;
      left.value = rect.left;
      right.value = rect.right;
      top.value = rect.top;
      width.value = rect.width;
      x.value = rect.x;
      y.value = rect.y;
    }
    useResizeObserver(target, update);
    vue.watch(function () {
      return unrefElement(target);
    }, function (ele) {
      return !ele && update();
    });
    if (windowScroll) useEventListener("scroll", update, {
      passive: true
    });
    if (windowResize) useEventListener("resize", update, {
      passive: true
    });
    tryOnMounted(function () {
      if (immediate) update();
    });
    return {
      height: height,
      bottom: bottom,
      left: left,
      right: right,
      top: top,
      width: width,
      x: x,
      y: y,
      update: update
    };
  }
  function useRafFn(fn) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$immediate2 = options.immediate,
      immediate = _options$immediate2 === void 0 ? true : _options$immediate2,
      _options$window11 = options.window,
      window = _options$window11 === void 0 ? defaultWindow : _options$window11;
    var isActive = vue.ref(false);
    var rafId = null;
    function loop() {
      if (!isActive.value || !window) return;
      fn();
      rafId = window.requestAnimationFrame(loop);
    }
    function resume() {
      if (!isActive.value && window) {
        isActive.value = true;
        loop();
      }
    }
    function pause() {
      isActive.value = false;
      if (rafId != null && window) {
        window.cancelAnimationFrame(rafId);
        rafId = null;
      }
    }
    if (immediate) resume();
    tryOnScopeDispose(pause);
    return {
      isActive: isActive,
      pause: pause,
      resume: resume
    };
  }
  function useElementSize(target) {
    var initialSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      width: 0,
      height: 0
    };
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var width = vue.ref(initialSize.width);
    var height = vue.ref(initialSize.height);
    useResizeObserver(target, function (_ref16) {
      var _ref17 = _slicedToArray(_ref16, 1),
        entry = _ref17[0];
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }, options);
    vue.watch(function () {
      return unrefElement(target);
    }, function (ele) {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    });
    return {
      width: width,
      height: height
    };
  }
  function useFocus(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$initialValue2 = options.initialValue,
      initialValue = _options$initialValue2 === void 0 ? false : _options$initialValue2;
    var activeElement = useActiveElement(options);
    var targetElement = vue.computed(function () {
      return unrefElement(target);
    });
    var focused = vue.computed({
      get: function get() {
        return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;
      },
      set: function set(value) {
        var _a, _b;
        if (!value && focused.value) (_a = targetElement.value) == null ? void 0 : _a.blur();
        if (value && !focused.value) (_b = targetElement.value) == null ? void 0 : _b.focus();
      }
    });
    vue.watch(targetElement, function () {
      focused.value = initialValue;
    }, {
      immediate: true,
      flush: "post"
    });
    return {
      focused: focused
    };
  }
  function useIntersectionObserver(target, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var root = options.root,
      _options$rootMargin = options.rootMargin,
      rootMargin = _options$rootMargin === void 0 ? "0px" : _options$rootMargin,
      _options$threshold = options.threshold,
      threshold = _options$threshold === void 0 ? 0.1 : _options$threshold,
      _options$window13 = options.window,
      window = _options$window13 === void 0 ? defaultWindow : _options$window13;
    var isSupported = window && "IntersectionObserver" in window;
    var _cleanup2 = noop;
    var stopWatch = isSupported ? vue.watch(function () {
      return {
        el: unrefElement(target),
        root: unrefElement(root)
      };
    }, function (_ref25) {
      var el = _ref25.el,
        root2 = _ref25.root;
      _cleanup2();
      if (!el) return;
      var observer = new IntersectionObserver(callback, {
        root: root2,
        rootMargin: rootMargin,
        threshold: threshold
      });
      observer.observe(el);
      _cleanup2 = function cleanup() {
        observer.disconnect();
        _cleanup2 = noop;
      };
    }, {
      immediate: true,
      flush: "post"
    }) : noop;
    var stop = function stop() {
      _cleanup2();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported: isSupported,
      stop: stop
    };
  }
  var SwipeDirection;
  (function (SwipeDirection2) {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
  })(SwipeDirection || (SwipeDirection = {}));
  function useSwipe(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$threshold2 = options.threshold,
      threshold = _options$threshold2 === void 0 ? 50 : _options$threshold2,
      onSwipe = options.onSwipe,
      onSwipeEnd = options.onSwipeEnd,
      onSwipeStart = options.onSwipeStart,
      _options$passive3 = options.passive,
      passive = _options$passive3 === void 0 ? true : _options$passive3,
      _options$window22 = options.window,
      window = _options$window22 === void 0 ? defaultWindow : _options$window22;
    var coordsStart = vue.reactive({
      x: 0,
      y: 0
    });
    var coordsEnd = vue.reactive({
      x: 0,
      y: 0
    });
    var diffX = vue.computed(function () {
      return coordsStart.x - coordsEnd.x;
    });
    var diffY = vue.computed(function () {
      return coordsStart.y - coordsEnd.y;
    });
    var max = Math.max,
      abs = Math.abs;
    var isThresholdExceeded = vue.computed(function () {
      return max(abs(diffX.value), abs(diffY.value)) >= threshold;
    });
    var isSwiping = vue.ref(false);
    var direction = vue.computed(function () {
      if (!isThresholdExceeded.value) return SwipeDirection.NONE;
      if (abs(diffX.value) > abs(diffY.value)) {
        return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
      } else {
        return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
      }
    });
    var getTouchEventCoords = function getTouchEventCoords(e) {
      return [e.touches[0].clientX, e.touches[0].clientY];
    };
    var updateCoordsStart = function updateCoordsStart(x, y) {
      coordsStart.x = x;
      coordsStart.y = y;
    };
    var updateCoordsEnd = function updateCoordsEnd(x, y) {
      coordsEnd.x = x;
      coordsEnd.y = y;
    };
    var listenerOptions;
    var isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);
    if (!passive) listenerOptions = isPassiveEventSupported ? {
      passive: false,
      capture: true
    } : {
      capture: true
    };else listenerOptions = isPassiveEventSupported ? {
      passive: true
    } : {
      capture: false
    };
    var onTouchEnd = function onTouchEnd(e) {
      if (isSwiping.value) onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isSwiping.value = false;
    };
    var stops = [useEventListener(target, "touchstart", function (e) {
      if (listenerOptions.capture && !listenerOptions.passive) e.preventDefault();
      var _getTouchEventCoords = getTouchEventCoords(e),
        _getTouchEventCoords2 = _slicedToArray(_getTouchEventCoords, 2),
        x = _getTouchEventCoords2[0],
        y = _getTouchEventCoords2[1];
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions), useEventListener(target, "touchmove", function (e) {
      var _getTouchEventCoords3 = getTouchEventCoords(e),
        _getTouchEventCoords4 = _slicedToArray(_getTouchEventCoords3, 2),
        x = _getTouchEventCoords4[0],
        y = _getTouchEventCoords4[1];
      updateCoordsEnd(x, y);
      if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
      if (isSwiping.value) onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions), useEventListener(target, "touchend", onTouchEnd, listenerOptions), useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)];
    var stop = function stop() {
      return stops.forEach(function (s) {
        return s();
      });
    };
    return {
      isPassiveEventSupported: isPassiveEventSupported,
      isSwiping: isSwiping,
      direction: direction,
      coordsStart: coordsStart,
      coordsEnd: coordsEnd,
      lengthX: diffX,
      lengthY: diffY,
      stop: stop
    };
  }
  function checkPassiveEventSupport(document) {
    if (!document) return false;
    var supportsPassive = false;
    var optionsBlock = {
      get passive() {
        supportsPassive = true;
        return false;
      }
    };
    document.addEventListener("x", noop, optionsBlock);
    document.removeEventListener("x", noop);
    return supportsPassive;
  }
  function useWindowSize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$window33 = options.window,
      window = _options$window33 === void 0 ? defaultWindow : _options$window33,
      _options$initialWidth = options.initialWidth,
      initialWidth = _options$initialWidth === void 0 ? Infinity : _options$initialWidth,
      _options$initialHeigh = options.initialHeight,
      initialHeight = _options$initialHeigh === void 0 ? Infinity : _options$initialHeigh,
      _options$listenOrient = options.listenOrientation,
      listenOrientation = _options$listenOrient === void 0 ? true : _options$listenOrient;
    var width = vue.ref(initialWidth);
    var height = vue.ref(initialHeight);
    var update = function update() {
      if (window) {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
      }
    };
    update();
    tryOnMounted(update);
    useEventListener("resize", update, {
      passive: true
    });
    if (listenOrientation) useEventListener("orientationchange", update, {
      passive: true
    });
    return {
      width: width,
      height: height
    };
  }

  var getRemainTimes = function getRemainTimes(time) {
    if (!time) {
      return {
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0
      };
    }
    var stime = Math.floor(time / 1e3);
    return {
      days: Math.floor(stime / 3600 / 24),
      hours: Math.floor(stime / 3600 % 24),
      minutes: Math.floor(stime / 60 % 60),
      seconds: stime % 60,
      milliseconds: time % 1e3
    };
  };
  var fillZero = function fillZero(num) {
    var isMillieconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (isMillieconds) {
      if (num >= 100) {
        return num;
      }
      return num >= 10 ? "0".concat(num) : "00".concat(num);
    }
    return num >= 10 ? num : "0".concat(num);
  };
  var getMark = function getMark(format, type) {
    var _format$split, _format$split$call, _format$split$call$, _format$split$call$$s, _format$split$call$$s2;
    return format === null || format === void 0 ? void 0 : (_format$split = format.split) === null || _format$split === void 0 ? void 0 : (_format$split$call = _format$split.call(format, type)) === null || _format$split$call === void 0 ? void 0 : (_format$split$call$ = _format$split$call[1]) === null || _format$split$call$ === void 0 ? void 0 : (_format$split$call$$s = _format$split$call$.split) === null || _format$split$call$$s === void 0 ? void 0 : (_format$split$call$$s2 = _format$split$call$$s.call(_format$split$call$, "")) === null || _format$split$call$$s2 === void 0 ? void 0 : _format$split$call$$s2[0];
  };
  var getShowTimes = function getShowTimes(times, format) {
    var _ref, _ref$toUpperCase, _format, _format2, _format3, _format4, _format5;
    var milliseconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    format = (_ref = format || "DD:HH:mm:ss") === null || _ref === void 0 ? void 0 : (_ref$toUpperCase = _ref.toUpperCase) === null || _ref$toUpperCase === void 0 ? void 0 : _ref$toUpperCase.call(_ref);
    milliseconds && !format.includes(":SSS") && (format = format.concat(":SSS"));
    var showTimes = [];
    if (((_format = format) === null || _format === void 0 ? void 0 : _format.indexOf("DD")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "DD"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.days)
      });
    }
    if (((_format2 = format) === null || _format2 === void 0 ? void 0 : _format2.indexOf("HH")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "HH"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.hours)
      });
    }
    if (((_format3 = format) === null || _format3 === void 0 ? void 0 : _format3.indexOf("MM")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "MM"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.minutes)
      });
    }
    if (((_format4 = format) === null || _format4 === void 0 ? void 0 : _format4.indexOf("SS")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "SS"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.seconds)
      });
    }
    if (((_format5 = format) === null || _format5 === void 0 ? void 0 : _format5.indexOf("SSS")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "SSS"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.milliseconds, true)
      });
    }
    return showTimes;
  };
  var getScreenFps = function () {
    var _ref2, _ref2$find;
    var _window = window,
      requestAnimationFrame = _window.requestAnimationFrame,
      mozRequestAnimationFrame = _window.mozRequestAnimationFrame,
      webkitRequestAnimationFrame = _window.webkitRequestAnimationFrame;
    var nextFrame = (_ref2 = [requestAnimationFrame, mozRequestAnimationFrame, webkitRequestAnimationFrame]) === null || _ref2 === void 0 ? void 0 : (_ref2$find = _ref2.find) === null || _ref2$find === void 0 ? void 0 : _ref2$find.call(_ref2, function (fn) {
      return fn;
    });
    if (!nextFrame) {
      console.error("requestAnimationFrame is not supported!");
      return;
    }
    return function () {
      var targetCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      if (targetCount < 1) {
        return;
      }
      var count = 0;
      var beginDate = Date.now();
      return new Promise(function (resolve) {
        (function log() {
          nextFrame === null || nextFrame === void 0 ? void 0 : nextFrame(function () {
            if (++count >= targetCount) {
              var diffDate = Date.now() - beginDate;
              var fps = count / diffDate * 1e3;
              return resolve(fps);
            }
            log();
          });
        })();
      });
    };
  }();

  function useCountDown(props) {
    var _ref = props || {},
      _ref$time = _ref.time,
      time = _ref$time === void 0 ? 0 : _ref$time,
      autoStart = _ref.autoStart,
      millisecond = _ref.millisecond,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? "HH:mm:ss" : _ref$format,
      onFinish = _ref.onFinish,
      onChange = _ref.onChange;
    var fps = vue.ref();
    var count = vue.ref(Number(time));
    var showTimes = vue.reactive(getShowTimes(getRemainTimes(time), format, !!millisecond));
    var _useRafFn = useRafFn( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var _getShowTimes, _getShowTimes$forEach;
        var res, times;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (fps.value) {
                  _context.next = 5;
                  break;
                }
                _context.next = 3;
                return getScreenFps === null || getScreenFps === void 0 ? void 0 : getScreenFps();
              case 3:
                res = _context.sent;
                fps.value = res || 60;
              case 5:
                count.value = parseInt("".concat(Number(count.value) - 1e3 / fps.value), 10);
                if (count.value <= 0) {
                  pause === null || pause === void 0 ? void 0 : pause();
                  count.value = 0;
                }
                times = getRemainTimes(count.value);
                onChange === null || onChange === void 0 ? void 0 : onChange(times);
                count.value === 0 && (onFinish === null || onFinish === void 0 ? void 0 : onFinish());
                (_getShowTimes = getShowTimes(times, format)) === null || _getShowTimes === void 0 ? void 0 : (_getShowTimes$forEach = _getShowTimes.forEach) === null || _getShowTimes$forEach === void 0 ? void 0 : _getShowTimes$forEach.call(_getShowTimes, function (i, idx) {
                  return showTimes[idx].value = i === null || i === void 0 ? void 0 : i.value;
                });
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), {
        immediate: autoStart
      }),
      pause = _useRafFn.pause,
      resume = _useRafFn.resume;
    return {
      time: count,
      showTimes: showTimes,
      pause: pause,
      resume: resume
    };
  }

  function getDefaultName(key) {
    var str = camelCase_1(key);
    return "default".concat(str[0].toLocaleUpperCase() + str.slice(1));
  }
  function getEventPropsName(eventName) {
    var str = camelCase_1(eventName);
    return "on".concat(str[0].toLocaleUpperCase()).concat(str.slice(1));
  }
  function useDefault(props, emit, key, eventName) {
    var modelValue = "modelValue";
    var defaultName = getDefaultName(String(key));
    var isUsedModelValue = props[modelValue] !== void 0;
    var isUsedKey = props[key] !== void 0;
    var innerValue = vue.ref();
    if (isUsedKey) {
      innerValue.value = props[key];
    } else if (isUsedModelValue) {
      innerValue.value = props[modelValue];
    } else {
      innerValue.value = props[defaultName];
    }
    vue.watchEffect(function () {
      if (isUsedModelValue) {
        innerValue.value = props[modelValue];
      }
      if (isUsedKey) {
        innerValue.value = props[key];
      }
    });
    function emitEvents(value) {
      var _props$propsEventName;
      for (var _len = arguments.length, arg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        arg[_key - 1] = arguments[_key];
      }
      var updateKeys = ["update:".concat(key)];
      if (isUsedModelValue) {
        updateKeys.push("update:modelValue");
      }
      updateKeys.forEach(function (updateKey) {
        emit.apply(void 0, [updateKey, value].concat(arg));
      });
      var propsEventName = getEventPropsName(eventName);
      (_props$propsEventName = props[propsEventName]) === null || _props$propsEventName === void 0 ? void 0 : _props$propsEventName.call.apply(_props$propsEventName, [props, value].concat(arg));
    }
    function setInnerValue(value) {
      if (!isUsedKey && !isUsedModelValue) {
        innerValue.value = value;
      }
      for (var _len2 = arguments.length, arg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        arg[_key2 - 1] = arguments[_key2];
      }
      emitEvents.apply(void 0, [value].concat(arg));
    }
    var innerValueRef = vue.computed({
      get: function get() {
        return innerValue.value;
      },
      set: function set(value) {
        setInnerValue(value);
      }
    });
    return [innerValueRef, setInnerValue];
  }

  function useEmitEvent(props, emit) {
    return function emitEvent(eventName) {
      var emitEventMethodName = "";
      if (typeof eventName === "string") {
        emitEventMethodName = camelCase_1("on-".concat(eventName));
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (typeof props[emitEventMethodName] === "function") {
        props[emitEventMethodName].apply(props, args);
      } else {
        emit.apply(void 0, [eventName].concat(args));
      }
    };
  }

  function useChildSlots(childComponentName, childInSlots) {
    var recurChildren = function recurChildren(children) {
      var result = [];
      if (Array.isArray(children)) {
        children.forEach(function (child) {
          if (vue.isVNode(child)) {
            var _child$component;
            result.push(child);
            if ((_child$component = child.component) !== null && _child$component !== void 0 && _child$component.subTree) {
              result.push(child.component.subTree);
              result.push.apply(result, _toConsumableArray(recurChildren(child.component.subTree.children)));
            }
            if (child.children) {
              result.push.apply(result, _toConsumableArray(recurChildren(child.children)));
            }
          }
        });
      }
      return result;
    };
    var targetChildren = [];
    if (childInSlots !== void 0) {
      targetChildren.push.apply(targetChildren, _toConsumableArray(recurChildren(childInSlots)));
    } else {
      var _getCurrentInstance;
      targetChildren.push.apply(targetChildren, _toConsumableArray(recurChildren((_getCurrentInstance = vue.getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.subTree.children)));
    }
    return targetChildren.filter(function (child) {
      var _child$type;
      return ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name) === childComponentName;
    });
  }

  function useVModel(value, modelValue, defaultValue, onChange) {
    var propName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "value";
    var _getCurrentInstance = vue.getCurrentInstance(),
      emit = _getCurrentInstance.emit;
    var internalValue = vue.ref();
    internalValue.value = defaultValue;
    if (typeof value.value !== "undefined") {
      return [value, function (newValue) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        emit === null || emit === void 0 ? void 0 : emit.apply(void 0, ["update:".concat(propName), newValue].concat(args));
        onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    if (typeof modelValue.value !== "undefined") {
      return [modelValue, function (newValue) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        emit === null || emit === void 0 ? void 0 : emit.apply(void 0, ["update:modelValue", newValue].concat(args));
        onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    return [internalValue, function (newValue) {
      internalValue.value = newValue;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
    }];
  }

  function getDirection(x, y) {
    if (x > y) {
      return "horizontal";
    }
    if (y > x) {
      return "vertical";
    }
    return "";
  }
  function useTouch$1() {
    var startX = vue.ref(0);
    var startY = vue.ref(0);
    var deltaX = vue.ref(0);
    var deltaY = vue.ref(0);
    var offsetX = vue.ref(0);
    var offsetY = vue.ref(0);
    var direction = vue.ref("");
    var isVertical = function isVertical() {
      return direction.value === "vertical";
    };
    var isHorizontal = function isHorizontal() {
      return direction.value === "horizontal";
    };
    var reset = function reset() {
      deltaX.value = 0;
      deltaY.value = 0;
      offsetX.value = 0;
      offsetY.value = 0;
      direction.value = "";
    };
    var start = function start(event) {
      reset();
      startX.value = event.touches[0].clientX;
      startY.value = event.touches[0].clientY;
    };
    var move = function move(event) {
      var touch = event.touches[0];
      deltaX.value = (touch.clientX < 0 ? 0 : touch.clientX) - startX.value;
      deltaY.value = touch.clientY - startY.value;
      offsetX.value = Math.abs(deltaX.value);
      offsetY.value = Math.abs(deltaY.value);
      var LOCK_DIRECTION_DISTANCE = 10;
      if (!direction.value || offsetX.value < LOCK_DIRECTION_DISTANCE && offsetY.value < LOCK_DIRECTION_DISTANCE) {
        direction.value = getDirection(offsetX.value, offsetY.value);
      }
    };
    return {
      move: move,
      start: start,
      reset: reset,
      startX: startX,
      startY: startY,
      deltaX: deltaX,
      deltaY: deltaY,
      offsetX: offsetX,
      offsetY: offsetY,
      direction: direction,
      isVertical: isVertical,
      isHorizontal: isHorizontal
    };
  }

  var overflowScrollReg = /scroll|auto/i;
  var defaultRoot = inBrowser ? window : void 0;
  function isElement$1(node) {
    var ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent$1(el) {
    var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRoot;
    var node = el;
    while (node && node !== root && isElement$1(node)) {
      var _window$getComputedSt = window.getComputedStyle(node),
        overflowY = _window$getComputedSt.overflowY;
      if (overflowScrollReg.test(overflowY)) {
        return node;
      }
      node = node.parentNode;
    }
    return root;
  }
  function useScrollParent(el) {
    var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRoot;
    var scrollParent = vue.ref();
    vue.onMounted(function () {
      if (el.value) {
        scrollParent.value = getScrollParent$1(el.value, root);
      }
    });
    return scrollParent;
  }

  function useExpose(apis) {
    var instance = vue.getCurrentInstance();
    if (instance) {
      Object.assign(instance.proxy, apis);
    }
  }

  var ButtonProps = {
    block: Boolean,
    content: {
      type: [String, Function]
    },
    disabled: Boolean,
    ghost: Boolean,
    icon: {
      type: Function
    },
    loading: Boolean,
    shape: {
      type: String,
      default: "rectangle",
      validator: function validator(val) {
        if (!val) return true;
        return ["rectangle", "square", "round", "circle"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        if (!val) return true;
        return ["default", "primary", "danger"].includes(val);
      }
    },
    variant: {
      type: String,
      default: "base",
      validator: function validator(val) {
        if (!val) return true;
        return ["base", "outline", "text"].includes(val);
      }
    },
    onClick: Function
  };

  function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$K(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$K(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$K(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$16 = config.prefix;
  var name$11 = "".concat(prefix$16, "-button");
  var loadingContent = vue.h(loading);
  var script$19 = vue.defineComponent({
    name: name$11,
    components: {
      TNode: TNodeComponent
    },
    props: ButtonProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var buttonClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$11), props.size ? ClASSNAMES.SIZE[props.size] : "", "".concat(name$11, "--").concat(props.variant), (_ref = {}, _defineProperty$2(_ref, "".concat(name$11, "--").concat(props.theme), props.theme), _defineProperty$2(_ref, "".concat(name$11, "--shape-").concat(props.shape), props.shape), _defineProperty$2(_ref, "".concat(name$11, "--ghost"), props.ghost), _defineProperty$2(_ref, "".concat(prefix$16, "-is-block"), props.block), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _defineProperty$2(_ref, ClASSNAMES.STATUS.loading, props.loading), _ref)];
      });
      var buttonContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return props.loading ? loadingContent : renderTNode(internalInstance, "icon");
      });
      var onClick = function onClick(e) {
        if (!props.loading && !props.disabled) {
          emitEvent("click", e);
        } else {
          e.stopPropagation();
        }
      };
      return _objectSpread$K(_objectSpread$K({
        name: name$11
      }, vue.toRefs(props)), {}, {
        buttonContent: buttonContent,
        iconContent: iconContent,
        buttonClass: buttonClass,
        onClick: onClick
      });
    }
  });

  var _hoisted_1$s = ["disabled", "aria-disabled"];
  function render$17(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("button", {
      class: vue.normalizeClass(_ctx.buttonClass),
      disabled: _ctx.disabled,
      role: "button",
      "aria-disabled": _ctx.disabled,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"]), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.buttonContent
    }, null, 8, ["content"])], 2)], 10, _hoisted_1$s);
  }

  script$19.render = render$17;

  var _Button = withInstall(script$19);

  var prefix$15 = config.prefix;
  var name$10 = "".concat(prefix$15, "-button-group");
  var script$18 = vue.defineComponent({
    name: name$10,
    props: {
      type: {
        type: String,
        default: "default"
      }
    },
    setup: function setup(props) {
      var classes = vue.computed(function () {
        return ["".concat(name$10), "".concat(name$10, "--").concat(props.type)];
      });
      return {
        classes: classes
      };
    }
  });

  function render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$18.render = render$16;

  var _ButtonGroup = withInstall(script$18);

  var DividerProps = {
    align: {
      type: String,
      default: "center",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right", "center"].includes(val);
      }
    },
    content: {
      type: [String, Function]
    },
    dashed: Boolean,
    default: {
      type: [String, Function]
    },
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    lineColor: {
      type: String,
      default: ""
    }
  };

  function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$J(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$J(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$J(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$14 = config.prefix;
  var name$$ = "".concat(prefix$14, "-divider");
  var script$17 = vue.defineComponent({
    name: name$$,
    components: {
      TNode: TNodeComponent
    },
    props: DividerProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var dividerContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var dividerClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$$), "".concat(name$$, "--hairline"), (_ref = {}, _defineProperty$2(_ref, "".concat(name$$, "--content-").concat(props.align), dividerContent.value), _defineProperty$2(_ref, "".concat(name$$, "--dashed"), props.dashed), _defineProperty$2(_ref, "".concat(name$$, "-vertical"), props.layout === "vertical"), _ref)];
      });
      return _objectSpread$J(_objectSpread$J({}, vue.toRefs(props)), {}, {
        dividerContent: dividerContent,
        dividerClass: dividerClass
      });
    }
  });

  function render$15(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "separator",
      class: vue.normalizeClass(_ctx.dividerClass),
      style: vue.normalizeStyle("border-color:".concat(_ctx.lineColor))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.dividerContent
    }, null, 8, ["content"])], 6);
  }

  script$17.render = render$15;

  var Divider = withInstall(script$17);

  var calendarProps = {
    confirmBtn: {
      type: [String, Object, Function],
      default: ""
    },
    firstDayOfWeek: {
      type: Number,
      default: 0
    },
    format: {
      type: Function
    },
    maxDate: {
      type: [Number, Date]
    },
    minDate: {
      type: [Number, Date]
    },
    title: {
      type: [String, Function]
    },
    type: {
      type: String,
      default: "single",
      validator: function validator(val) {
        if (!val) return true;
        return ["single", "multiple", "range"].includes(val);
      }
    },
    value: {
      type: [Number, Array, Date]
    },
    visible: Boolean,
    onConfirm: Function,
    onSelect: Function
  };

  function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$I(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$I(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$I(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var _hoisted_1$r = ["onClick"];
  var _hoisted_2$b = {
    class: "t-calendar__footer"
  };
  var prefix$13 = config.prefix;
  var name$_ = "".concat(prefix$13, "-calendar");
  var __default__ = {
    name: name$_
  };
  var script$16 = /* @__PURE__ */vue.defineComponent(_objectSpread$I(_objectSpread$I({}, __default__), {}, {
    props: calendarProps,
    emits: ["select", "confirm", "update:modelValue", "update:value", "update:visible"],
    setup: function setup(__props, _ref) {
      var emit = _ref.emit;
      var props = __props;
      var getYearMonthDay = function getYearMonthDay(date) {
        return {
          year: date.getFullYear(),
          month: date.getMonth(),
          date: date.getDate()
        };
      };
      var popup = vue.ref(props.visible);
      var valueRef = vue.ref(props.value);
      var selectedDate = vue.ref();
      var firstDayOfWeek = vue.computed(function () {
        return props.firstDayOfWeek;
      });
      var type = vue.computed(function () {
        return props.type;
      });
      var days = vue.computed(function () {
        var raw = "\u65E5\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D";
        var ans = [];
        var i = firstDayOfWeek.value % 7;
        while (ans.length < 7) {
          ans.push(raw[i]);
          i = (i + 1) % 7;
        }
        return ans;
      });
      var today = new Date();
      var minDate = props.minDate ? new Date(props.minDate) : today;
      var maxDate = props.maxDate ? new Date(props.maxDate) : new Date(today.getFullYear(), today.getMonth() + 6, today.getDate());
      var getDate = function getDate(year, month, day) {
        return new Date(year, month, day);
      };
      var handleSelect = function handleSelect(year, month, date, dateItem) {
        var _props$onSelect;
        if (dateItem.type === "disabled") return;
        var selected = new Date(year, month, date);
        if (type.value === "range" && Array.isArray(selectedDate.value)) {
          if (selectedDate.value.length === 1) {
            if (selectedDate.value[0] > selected) {
              selectedDate.value = [selected];
            } else {
              selectedDate.value = [selectedDate.value[0], selected];
            }
          } else {
            selectedDate.value = [selected];
          }
        } else if (props.type === "multiple") {
          var newVal = _toConsumableArray(selectedDate.value);
          var index = selectedDate.value.findIndex(function (item) {
            return isSameDate(item, selected);
          });
          if (index > -1) {
            newVal.splice(index, 1);
          } else {
            newVal.push(selected);
          }
          selectedDate.value = newVal;
        } else {
          selectedDate.value = selected;
        }
        (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 ? void 0 : _props$onSelect.call(props, vue.toRaw(selectedDate.value));
      };
      var handleConfirm = function handleConfirm() {
        var _props$onConfirm;
        popup.value = false;
        (_props$onConfirm = props.onConfirm) === null || _props$onConfirm === void 0 ? void 0 : _props$onConfirm.call(props, vue.toRaw(selectedDate.value));
      };
      var getMonthDates = function getMonthDates(date) {
        var _getYearMonthDay = getYearMonthDay(date),
          year = _getYearMonthDay.year,
          month = _getYearMonthDay.month;
        var firstDay = getDate(year, month, 1);
        var weekdayOfFirstDay = firstDay.getDay();
        var lastDate = new Date(+getDate(year, month + 1, 1) - 24 * 3600 * 1e3).getDate();
        return {
          year: year,
          month: month,
          weekdayOfFirstDay: weekdayOfFirstDay,
          lastDate: lastDate
        };
      };
      var isSameDate = function isSameDate(date1, date2) {
        if (date1 instanceof Date) date1 = getYearMonthDay(date1);
        if (date2 instanceof Date) date2 = getYearMonthDay(date2);
        var keys = ["year", "month", "date"];
        return keys.every(function (key) {
          return date1[key] === date2[key];
        });
      };
      var months = vue.computed(function () {
        var ans = [];
        var _getYearMonthDay2 = getYearMonthDay(minDate),
          minYear = _getYearMonthDay2.year,
          minMonth = _getYearMonthDay2.month;
        var _getYearMonthDay3 = getYearMonthDay(maxDate),
          maxYear = _getYearMonthDay3.year,
          maxMonth = _getYearMonthDay3.month;
        var calcType = function calcType(year, month, date) {
          var curDate = new Date(year, month, date, 23, 59, 59);
          if (type.value === "single") {
            if (isSameDate({
              year: year,
              month: month,
              date: date
            }, selectedDate.value)) return "selected";
          }
          if (type.value === "multiple") {
            var hit = selectedDate.value.some(function (item) {
              return isSameDate({
                year: year,
                month: month,
                date: date
              }, item);
            });
            if (hit) {
              return "selected";
            }
          }
          if (type.value === "range") {
            if (Array.isArray(selectedDate.value)) {
              var _selectedDate$value = _slicedToArray(selectedDate.value, 2),
                startDate = _selectedDate$value[0],
                endDate = _selectedDate$value[1];
              if (startDate && isSameDate({
                year: year,
                month: month,
                date: date
              }, startDate)) return "start";
              if (endDate && isSameDate({
                year: year,
                month: month,
                date: date
              }, endDate)) return "end";
              if (startDate && endDate && curDate.getTime() > startDate.getTime() && curDate.getTime() < endDate.getTime()) return "centre";
            }
          }
          var minCurDate = new Date(year, month, date, 0, 0, 0);
          if (curDate.getTime() < minDate.getTime() || minCurDate.getTime() > maxDate.getTime()) {
            return "disabled";
          }
          return "";
        };
        while (minYear < maxYear || minYear === maxYear && minMonth <= maxMonth) {
          var target = getMonthDates(getDate(minYear, minMonth, 1));
          var months2 = [];
          for (var i = 1; i <= 31; i++) {
            if (i > target.lastDate) break;
            var dateObj = {
              date: getDate(minYear, minMonth, i),
              day: i,
              type: calcType(minYear, minMonth, i)
            };
            months2.push(props.format ? props.format(dateObj) : dateObj);
          }
          ans.push({
            year: minYear,
            month: minMonth,
            months: months2,
            weekdayOfFirstDay: target.weekdayOfFirstDay
          });
          var curDate = getYearMonthDay(getDate(minYear, minMonth + 1, 1));
          minYear = curDate.year;
          minMonth = curDate.month;
        }
        return ans;
      });
      var confirmBtn = vue.computed(function () {
        if (props.confirmBtn === "string" || props.confirmBtn === "") return {
          content: props.confirmBtn || "\u786E\u8BA4"
        };
        return props.confirmBtn;
      });
      vue.watch(function () {
        return props.visible;
      }, function (val) {
        popup.value = val;
      });
      vue.watch(function () {
        return popup.value;
      }, function (val) {
        emit("update:visible", val);
      });
      vue.watch(valueRef, function () {
        if (Array.isArray(valueRef.value)) {
          selectedDate.value = valueRef.value.map(function (item) {
            return new Date(item);
          });
        } else if (valueRef.value) {
          selectedDate.value = new Date(valueRef.value);
        } else {
          selectedDate.value = props.type === "multiple" ? [new Date()] : new Date();
        }
      }, {
        immediate: true
      });
      return function (_ctx, _cache) {
        var _component_t_button = vue.resolveComponent("t-button");
        var _component_t_popup = vue.resolveComponent("t-popup");
        return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_t_popup, {
          modelValue: popup.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
            return popup.value = $event;
          }),
          placement: "bottom"
        }, {
          default: vue.withCtx(function () {
            return [vue.createElementVNode("div", {
              class: vue.normalizeClass(name$_)
            }, [vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$_, "__title"))
            }, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
              return [vue.createTextVNode(vue.toDisplayString(_ctx.title || "\u8BF7\u9009\u62E9\u65E5\u671F"), 1)];
            })], 2), vue.createVNode(vue.unref(close), {
              class: vue.normalizeClass("".concat(name$_, "__close-btn")),
              size: "24",
              onClick: _cache[0] || (_cache[0] = function ($event) {
                return popup.value = false;
              })
            }, null, 8, ["class"]), vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$_, "__days"))
            }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(days), function (item, index) {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: index,
                class: vue.normalizeClass("".concat(name$_, "__days-item"))
              }, vue.toDisplayString(item), 3);
            }), 128))], 2), vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$_, "__months"))
            }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(months), function (item, index) {
              return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
                key: index
              }, [vue.createElementVNode("div", {
                class: vue.normalizeClass("".concat(name$_, "__month"))
              }, vue.toDisplayString(item.year) + " \u5E74 " + vue.toDisplayString(item.month + 1) + " \u6708", 3), vue.createElementVNode("div", {
                class: vue.normalizeClass("".concat(name$_, "__dates"))
              }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.months, function (dateItem, dateIndex) {
                var _dateItem$className, _normalizeClass2;
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: dateIndex,
                  class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(name$_, "__dates-item"), true), _defineProperty$2(_normalizeClass2, "".concat(name$_, "__dates-item--").concat(dateItem.type), !!dateItem.type), _defineProperty$2(_normalizeClass2, "".concat((_dateItem$className = dateItem.className) !== null && _dateItem$className !== void 0 ? _dateItem$className : ""), true), _normalizeClass2)),
                  style: vue.normalizeStyle({
                    marginLeft: dateIndex === 0 ? "".concat(49 * ((item.weekdayOfFirstDay - vue.unref(firstDayOfWeek) + 7) % 7), "px") : 0
                  }),
                  onClick: function onClick($event) {
                    return handleSelect(item.year, item.month, dateItem.day, dateItem);
                  }
                }, [vue.renderSlot(_ctx.$slots, "cell", {
                  item: dateItem
                }, function () {
                  var _normalizeClass3;
                  return [dateItem.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass("".concat(name$_, "__dates-item-prefix"))
                  }, vue.toDisplayString(dateItem.prefix), 3)) : vue.createCommentVNode("", true), vue.createTextVNode(" " + vue.toDisplayString(dateItem.day) + " ", 1), dateItem.suffix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 1,
                    class: vue.normalizeClass((_normalizeClass3 = {}, _defineProperty$2(_normalizeClass3, "".concat(name$_, "__dates-item-suffix"), true), _defineProperty$2(_normalizeClass3, "".concat(name$_, "__dates-item-suffix--").concat(dateItem.type), !!dateItem.type), _normalizeClass3))
                  }, vue.toDisplayString(dateItem.suffix), 3)) : vue.createCommentVNode("", true)];
                })], 14, _hoisted_1$r);
              }), 128))], 2)], 64);
            }), 128))], 2), vue.createElementVNode("div", _hoisted_2$b, [vue.renderSlot(_ctx.$slots, "confirmBtn", {}, function () {
              return [vue.unref(confirmBtn) ? (vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
                key: 0,
                block: "",
                theme: "primary"
              }, vue.unref(confirmBtn), {
                onClick: handleConfirm
              }), null, 16)) : vue.createCommentVNode("", true)];
            })])])];
          }),
          _: 3
        }, 8, ["modelValue"])]);
      };
    }
  }));

  var _Calendar = withInstall(script$16);

  var CellProps = {
    align: {
      type: String,
      default: "middle",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "middle", "bottom"].includes(val);
      }
    },
    arrow: Boolean,
    bordered: {
      type: Boolean,
      default: true
    },
    description: {
      type: [String, Function]
    },
    hover: Boolean,
    image: {
      type: [String, Function]
    },
    leftIcon: {
      type: Function
    },
    note: {
      type: [String, Function]
    },
    required: Boolean,
    rightIcon: {
      type: Function
    },
    title: {
      type: [String, Function]
    },
    onClick: Function
  };

  function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$H(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$H(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$H(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$12 = config.prefix;
  var name$Z = "".concat(prefix$12, "-cell");
  var script$15 = vue.defineComponent({
    name: name$Z,
    components: {
      TNode: TNodeComponent
    },
    props: CellProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var noteContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "note");
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descriptionContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var rightIconContent = vue.computed(function () {
        if (props.arrow) {
          return vue.h(chevronRight);
        }
        return renderTNode(internalInstance, "rightIcon");
      });
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var leftIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "leftIcon");
      });
      var styleCell = vue.computed(function () {
        var _ref;
        return ["".concat(name$Z), "".concat(name$Z, "--").concat(props.align), (_ref = {}, _defineProperty$2(_ref, "".concat(name$Z, "--hover"), props.hover), _defineProperty$2(_ref, "".concat(name$Z, "--bordered"), props.bordered), _ref)];
      });
      var onClick = function onClick(e) {
        return emitEvent("click", e);
      };
      return _objectSpread$H(_objectSpread$H({}, vue.toRefs(props)), {}, {
        name: name$Z,
        onClick: onClick,
        styleCell: styleCell,
        imageContent: imageContent,
        rightIconContent: rightIconContent,
        leftIconContent: leftIconContent,
        noteContent: noteContent,
        titleContent: titleContent,
        descriptionContent: descriptionContent
      });
    }
  });

  var _hoisted_1$q = ["src"];
  function render$14(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.styleCell),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__left-icon"))
    }, [_ctx.leftIconContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.leftIconContent
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), _ctx.image ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
      key: 0,
      src: _ctx.image,
      class: vue.normalizeClass("".concat(_ctx.name, "__image"))
    }, null, 10, _hoisted_1$q)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 64)) : vue.createCommentVNode("", true)], 2), _ctx.titleContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"]), _ctx.required ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "--required"))
    }, "\xA0*", 2)) : vue.createCommentVNode("", true), _ctx.descriptionContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descriptionContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.noteContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__note"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.noteContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.rightIconContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__right-icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.rightIconContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$15.render = render$14;

  var _Cell = withInstall(script$15);

  var CellGroupProps = {
    bordered: Boolean,
    title: {
      type: String,
      default: ""
    }
  };

  var prefix$11 = config.prefix;
  var name$Y = "".concat(prefix$11, "-cell-group");
  var script$14 = vue.defineComponent({
    name: name$Y,
    props: CellGroupProps,
    setup: function setup() {
      return {
        name: name$Y
      };
    }
  });

  function render$13(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [_ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)];
    })], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__container"), true), _defineProperty$2(_normalizeClass2, "border--top-bottom", _ctx.bordered), _normalizeClass2))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2)], 2);
  }

  script$14.render = render$13;

  var _CellGroup = withInstall(script$14);

  var CheckboxProps$1 = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right"].includes(val);
      }
    },
    checkAll: Boolean,
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: Boolean,
    content: {
      type: [String, Function]
    },
    contentDisabled: Boolean,
    default: {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: Array
    },
    indeterminate: Boolean,
    label: {
      type: [String, Function]
    },
    maxContentRow: {
      type: Number,
      default: 5
    },
    maxLabelRow: {
      type: Number,
      default: 3
    },
    name: {
      type: String,
      default: ""
    },
    readonly: Boolean,
    value: {
      type: [String, Number]
    },
    onChange: Function
  };

  function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$G(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$G(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$G(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$10 = config.prefix;
  var name$X = "".concat(prefix$10, "-checkbox");
  var script$13 = vue.defineComponent({
    name: name$X,
    components: {
      TNode: TNodeComponent,
      MinusCircleFilledIcon: minusCircleFilled
    },
    props: _objectSpread$G(_objectSpread$G({}, CheckboxProps$1), {}, {
      borderless: {
        type: Boolean,
        value: false
      }
    }),
    emits: ["update:checked", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var flagName = name$X;
      var checkIcons = props.icon || [vue.h(checkCircleFilled), vue.h(circle)];
      var _useDefault = useDefault(props, context.emit, "checked", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerChecked = _useDefault2[0],
        setInnerChecked = _useDefault2[1];
      var internalInstance = vue.getCurrentInstance();
      var checkboxGroup = vue.inject("checkboxGroup", void 0);
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "label", "default");
      });
      var checkboxContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var indeterminate = vue.computed(function () {
        if (props.checkAll && checkboxGroup != null) return checkboxGroup.checkAllStatus.value === "indeterminate";
        return props.indeterminate;
      });
      var isChecked = vue.computed(function () {
        if (props.checkAll) return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.checkAllStatus.value) === "checked";
        if (checkboxGroup != null && props.value != null) {
          var _checkboxGroup$checke;
          return !!((_checkboxGroup$checke = checkboxGroup.checkedSet.value) !== null && _checkboxGroup$checke !== void 0 && _checkboxGroup$checke.has(props.value));
        }
        return innerChecked.value;
      });
      var isDisabled = vue.computed(function () {
        if (checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.max.value) return checkboxGroup.max.value <= checkboxGroup.innerValue.value.length && !isChecked.value;
        if (props.disabled != null) return props.disabled;
        return !!(checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.disabled.value);
      });
      var componentClass = vue.computed(function () {
        var _ref;
        return ["".concat(flagName), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, isChecked.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, isDisabled.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.indeterminate, indeterminate.value), _ref)];
      });
      var getLimitRowStyle = function getLimitRowStyle(row) {
        return {
          display: "-webkit-box",
          overflow: "hidden",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: row
        };
      };
      var labelStyle = vue.computed(function () {
        return _objectSpread$G({
          color: isDisabled.value ? "#dcdcdc" : "inherit"
        }, getLimitRowStyle(props.maxLabelRow));
      });
      var contentStyle = vue.computed(function () {
        return _objectSpread$G({}, getLimitRowStyle(props.maxContentRow));
      });
      var handleChange = function handleChange(e, source) {
        if (isDisabled.value) return;
        if (source === "content" && props.contentDisabled) return;
        var value = !isChecked.value;
        setInnerChecked(value, {
          e: e
        });
        e.stopPropagation();
        if (checkboxGroup && checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.onCheckedChange) {
          checkboxGroup.onCheckedChange({
            checked: value,
            checkAll: props.checkAll,
            e: e,
            option: props
          });
        }
      };
      return _objectSpread$G(_objectSpread$G({}, vue.toRefs(props)), {}, {
        isChecked: isChecked,
        checkIcons: checkIcons,
        labelContent: labelContent,
        labelStyle: labelStyle,
        checkboxContent: checkboxContent,
        contentStyle: contentStyle,
        isDisabled: isDisabled,
        flagName: flagName,
        componentClass: componentClass,
        indeterminate: indeterminate,
        handleChange: handleChange
      });
    }
  });

  var _hoisted_1$p = ["name", "value", "disabled", "readonly", "checked", "indeterminate"];
  var _hoisted_2$a = ["name", "value", "disabled", "readonly", "checked", "indeterminate"];
  function render$12(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_minus_circle_filled_icon = vue.resolveComponent("minus-circle-filled-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentClass)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.flagName, "__content-wrap"))
    }, [_ctx.align === "left" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__icon-left"))
    }, [vue.createElementVNode("input", {
      type: "checkbox",
      name: _ctx.name,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__original-left")),
      value: _ctx.value,
      disabled: _ctx.isDisabled,
      readonly: _ctx.readonly,
      checked: _ctx.isChecked,
      indeterminate: _ctx.indeterminate,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 10, _hoisted_1$p), !_ctx.indeterminate ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_minus_circle_filled_icon, {
      key: 1
    }))], 2)) : vue.createCommentVNode("", true), _ctx.labelContent || _ctx.checkboxContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.flagName, "__label"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.flagName, "__label-left"), _ctx.align === "right"), _normalizeClass2)),
      onClick: _cache[1] || (_cache[1] = function (e) {
        return _ctx.handleChange(e, "content");
      })
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      style: vue.normalizeStyle(_ctx.labelStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 4)) : vue.createCommentVNode("", true), _ctx.checkboxContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__description")),
      style: vue.normalizeStyle(_ctx.contentStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.checkboxContent
    }, null, 8, ["content"])], 6)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.align === "right" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__icon-right"))
    }, [vue.createElementVNode("input", {
      type: "checkbox",
      name: _ctx.name,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__original-right")),
      value: _ctx.value,
      disabled: _ctx.isDisabled,
      readonly: _ctx.readonly,
      checked: _ctx.isChecked,
      indeterminate: _ctx.indeterminate,
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 10, _hoisted_2$a), !_ctx.indeterminate ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_minus_circle_filled_icon, {
      key: 1
    }))], 2)) : vue.createCommentVNode("", true)], 2), !_ctx.borderless ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__border ").concat(_ctx.flagName, "__border--").concat(_ctx.align))
    }, null, 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$13.render = render$12;

  var CheckboxProps = {
    disabled: Boolean,
    max: {
      type: Number,
      default: void 0
    },
    name: {
      type: String,
      default: ""
    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    value: {
      type: Array,
      default: void 0
    },
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultValue: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    onChange: Function
  };

  function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$F(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$F(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$F(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var getOptionListBySlots = function getOptionListBySlots(nodes) {
    var arr = [];
    nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function (node) {
      var option = node.props;
      if ((option === null || option === void 0 ? void 0 : option["check-all"]) === "" || (option === null || option === void 0 ? void 0 : option["check-all"]) === true) {
        option.checkAll = true;
      }
      option && arr.push(option);
    });
    return arr;
  };
  var getOptions = function getOptions(props, slots) {
    var _toRefs = vue.toRefs(props),
      options = _toRefs.options;
    var optionList = vue.ref([]);
    vue.watch(options, function (options2) {
      if (!options2) return [];
      optionList.value = options2.map(function (item) {
        var r = {};
        if (_typeof$1(item) !== "object") {
          r = {
            label: String(item),
            value: item
          };
        } else {
          r = _objectSpread$F({}, item);
          r.disabled = r.disabled === void 0 ? props.disabled : r.disabled;
        }
        return r;
      });
    }, {
      immediate: true
    });
    vue.onMounted(function () {
      var nodes = slots.default && slots.default();
      if (nodes !== void 0) {
        optionList.value = getOptionListBySlots(useChildSlots("t-checkbox"));
      }
    });
    return optionList;
  };

  function isObject$4(value) {
    var type = _typeof$1(value);
    return value != null && (type == 'object' || type == 'function');
  }
  var isObject_1 = isObject$4;

  var baseGetTag$3 = _baseGetTag,
    isObject$3 = isObject_1;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject$3(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$3(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$2;

  var root$6 = _root;

  /** Used to detect overreaching core-js shims. */
  var coreJsData$1 = root$6['__core-js_shared__'];
  var _coreJsData = coreJsData$1;

  var coreJsData = _coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }
  var _toSource = toSource$2;

  var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$2 = isObject_1,
    toSource$1 = _toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$9 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value));
  }
  var _baseIsNative = baseIsNative$1;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }
  var _getValue = getValue$1;

  var baseIsNative = _baseIsNative,
    getValue = _getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$7(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  var _getNative = getNative$7;

  var getNative$6 = _getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate$4 = getNative$6(Object, 'create');
  var _nativeCreate = nativeCreate$4;

  var nativeCreate$3 = _nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;

  var nativeCreate$2 = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
  }
  var _hashGet = hashGet$1;

  var nativeCreate$1 = _nativeCreate;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);
  }
  var _hashHas = hashHas$1;

  var nativeCreate = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }
  var _hashSet = hashSet$1;

  var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype['delete'] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_1 = eq$2;

  var eq$1 = eq_1;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$4(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;

  var assocIndexOf$3 = _assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
      index = assocIndexOf$3(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;

  var assocIndexOf$2 = _assocIndexOf;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
      index = assocIndexOf$2(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  var _listCacheGet = listCacheGet$1;

  var assocIndexOf$1 = _assocIndexOf;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;

  var assocIndexOf = _assocIndexOf;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;

  var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$4(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$4.prototype.clear = listCacheClear;
  ListCache$4.prototype['delete'] = listCacheDelete;
  ListCache$4.prototype.get = listCacheGet;
  ListCache$4.prototype.has = listCacheHas;
  ListCache$4.prototype.set = listCacheSet;
  var _ListCache = ListCache$4;

  var getNative$5 = _getNative,
    root$5 = _root;

  /* Built-in method references that are verified to be native. */
  var Map$3 = getNative$5(root$5, 'Map');
  var _Map = Map$3;

  var Hash = _Hash,
    ListCache$3 = _ListCache,
    Map$2 = _Map;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache$3)(),
      'string': new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;

  function isKeyable$1(value) {
    var type = _typeof$1(value);
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  var _isKeyable = isKeyable$1;

  var isKeyable = _isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$4(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  var _getMapData = getMapData$4;

  var getMapData$3 = _getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;

  var getMapData$2 = _getMapData;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;

  var getMapData$1 = _getMapData;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;

  var getMapData = _getMapData;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;

  var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$3(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$3.prototype.clear = mapCacheClear;
  MapCache$3.prototype['delete'] = mapCacheDelete;
  MapCache$3.prototype.get = mapCacheGet;
  MapCache$3.prototype.has = mapCacheHas;
  MapCache$3.prototype.set = mapCacheSet;
  var _MapCache = MapCache$3;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd$1(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  var _setCacheAdd = setCacheAdd$1;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas$1(value) {
    return this.__data__.has(value);
  }
  var _setCacheHas = setCacheHas$1;

  var MapCache$2 = _MapCache,
    setCacheAdd = _setCacheAdd,
    setCacheHas = _setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache$2(values) {
    var index = -1,
      length = values == null ? 0 : values.length;
    this.__data__ = new MapCache$2();
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
  SetCache$2.prototype.has = setCacheHas;
  var _SetCache = SetCache$2;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
    var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  var _baseFindIndex = baseFindIndex$2;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN$1(value) {
    return value !== value;
  }
  var _baseIsNaN = baseIsNaN$1;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf$1(array, value, fromIndex) {
    var index = fromIndex - 1,
      length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  var _strictIndexOf = strictIndexOf$1;

  var baseFindIndex$1 = _baseFindIndex,
    baseIsNaN = _baseIsNaN,
    strictIndexOf = _strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf$1(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex$1(array, baseIsNaN, fromIndex);
  }
  var _baseIndexOf = baseIndexOf$1;

  var baseIndexOf = _baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes$1(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  var _arrayIncludes = arrayIncludes$1;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith$1(array, value, comparator) {
    var index = -1,
      length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  var _arrayIncludesWith = arrayIncludesWith$1;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary$2(func) {
    return function (value) {
      return func(value);
    };
  }
  var _baseUnary = baseUnary$2;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas$2(cache, key) {
    return cache.has(key);
  }
  var _cacheHas = cacheHas$2;

  var SetCache$1 = _SetCache,
    arrayIncludes = _arrayIncludes,
    arrayIncludesWith = _arrayIncludesWith,
    arrayMap$1 = _arrayMap,
    baseUnary$1 = _baseUnary,
    cacheHas$1 = _cacheHas;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMin = Math.min;

  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */
  function baseIntersection$1(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap$1(array, baseUnary$1(iteratee));
      }
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache$1(othIndex && array) : undefined;
    }
    array = arrays[0];
    var index = -1,
      seen = caches[0];
    outer: while (++index < length && result.length < maxLength) {
      var value = array[index],
        computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas$1(seen, computed) : includes(result, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas$1(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }
  var _baseIntersection = baseIntersection$1;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$3(value) {
    return value;
  }
  var identity_1 = identity$3;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply$1(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  var _apply = apply$1;

  var apply = _apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest$1(func, start, transform) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  var _overRest = overRest$1;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$1(value) {
    return function () {
      return value;
    };
  }
  var constant_1 = constant$1;

  var getNative$4 = _getNative;
  var defineProperty$1 = function () {
    try {
      var func = getNative$4(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();
  var _defineProperty = defineProperty$1;

  var constant = constant_1,
    defineProperty = _defineProperty,
    identity$2 = identity_1;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString$1 = !defineProperty ? identity$2 : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString$1;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
    HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut$1(func) {
    var count = 0,
      lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  var _shortOut = shortOut$1;

  var baseSetToString = _baseSetToString,
    shortOut = _shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString$1 = shortOut(baseSetToString);
  var _setToString = setToString$1;

  var identity$1 = identity_1,
    overRest = _overRest,
    setToString = _setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest$1(func, start) {
    return setToString(overRest(func, start, identity$1), func + '');
  }
  var _baseRest = baseRest$1;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$3(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }
  var isLength_1 = isLength$3;

  var isFunction = isFunction_1,
    isLength$2 = isLength_1;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$2(value) {
    return value != null && isLength$2(value.length) && !isFunction(value);
  }
  var isArrayLike_1 = isArrayLike$2;

  var isArrayLike$1 = isArrayLike_1,
    isObjectLike$4 = isObjectLike_1;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject$1(value) {
    return isObjectLike$4(value) && isArrayLike$1(value);
  }
  var isArrayLikeObject_1 = isArrayLikeObject$1;

  var isArrayLikeObject = isArrayLikeObject_1;

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */
  function castArrayLikeObject$1(value) {
    return isArrayLikeObject(value) ? value : [];
  }
  var _castArrayLikeObject = castArrayLikeObject$1;

  var arrayMap = _arrayMap,
    baseIntersection = _baseIntersection,
    baseRest = _baseRest,
    castArrayLikeObject = _castArrayLikeObject;

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */
  var intersection = baseRest(function (arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });
  var intersection_1 = intersection;

  var setCheckAllStatus = function setCheckAllStatus(optionList, innerValue, checkedSet) {
    var isArray = Array.isArray;
    var intersectionLen = vue.computed(function () {
      var _optionList$value;
      var values = (_optionList$value = optionList.value) === null || _optionList$value === void 0 ? void 0 : _optionList$value.map(function (item) {
        return item.value;
      });
      if (isArray(innerValue.value)) {
        return intersection_1(innerValue.value, values).length;
      }
      return 0;
    });
    var isAllChecked = vue.computed(function () {
      if (checkedSet.value.size !== optionList.value.length - 1) {
        return false;
      }
      return intersectionLen.value === optionList.value.length - 1;
    });
    var indeterminate = vue.computed(function () {
      return !isAllChecked.value && intersectionLen.value < optionList.value.length && intersectionLen.value > 0;
    });
    return vue.computed(function () {
      if (isAllChecked.value) return "checked";
      if (indeterminate.value) return "indeterminate";
      return "uncheck";
    });
  };

  function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$E(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$E(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$E(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$$ = config.prefix;
  var name$W = "".concat(prefix$$, "-checkbox-group");
  var script$12 = vue.defineComponent({
    name: name$W,
    components: {
      Checkbox: script$13
    },
    props: CheckboxProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var isArray = Array.isArray;
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerValue = _useDefault2[0],
        setinnerValue = _useDefault2[1];
      var optionList = getOptions(props, context.slots);
      var checkedSet = vue.computed(function () {
        if (isArray(innerValue.value)) {
          return new Set(innerValue.value);
        }
        return /* @__PURE__ */new Set();
      });
      var checkAllStatus = setCheckAllStatus(optionList, innerValue, checkedSet);
      var maxExceeded = vue.computed(function () {
        return props.max !== void 0 && innerValue.value.length === props.max;
      });
      var onCheckedChange = function onCheckedChange(p) {
        var checked = p.checked,
          checkAll = p.checkAll,
          e = p.e;
        if (checkAll) {
          onCheckAllChange(checked, {
            e: e
          });
        } else {
          handleCheckboxChange(p);
        }
      };
      var handleCheckboxChange = function handleCheckboxChange(data) {
        var currentValue = data.option.value;
        if (isArray(innerValue.value)) {
          if (currentValue === void 0) {
            return;
          }
          var val = _toConsumableArray(innerValue.value);
          if (data.checked) {
            val.push(currentValue);
          } else {
            var i = val.indexOf(currentValue);
            val.splice(i, 1);
          }
          setinnerValue(val, {
            e: data.e,
            current: data.option.value,
            type: data.checked ? "check" : "uncheck"
          });
        } else {
          console.warn("TDesign CheckboxGroup Warn: `value` must be an array, instead of ".concat(_typeof$1(innerValue.value)));
        }
      };
      var getAllCheckboxValue = function getAllCheckboxValue() {
        var val = /* @__PURE__ */new Set();
        for (var i = 0, len = optionList.value.length; i < len; i++) {
          var item = optionList.value[i];
          if (item.checkAll) continue;
          if (item.value === void 0) continue;
          val.add(item.value);
          if (maxExceeded.value) break;
        }
        return _toConsumableArray(val);
      };
      var onCheckAllChange = function onCheckAllChange(checked, context2) {
        var value = checked ? getAllCheckboxValue() : [];
        setinnerValue(value, {
          e: context2.e,
          type: checked ? "check" : "uncheck",
          current: void 0
        });
      };
      vue.provide("checkboxGroup", _objectSpread$E(_objectSpread$E({}, vue.toRefs(props)), {}, {
        innerValue: innerValue,
        checkAllStatus: checkAllStatus,
        checkedSet: checkedSet,
        onCheckedChange: onCheckedChange
      }));
      return {
        prefix: prefix$$,
        optionList: optionList
      };
    }
  });

  var _hoisted_1$o = {
    key: 1
  };
  function render$11(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_checkbox = vue.resolveComponent("checkbox");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.prefix, "-checkbox-group"))
    }, [!(_ctx.options && _ctx.options.length) ? vue.renderSlot(_ctx.$slots, "default", {
      key: 0
    }) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$o, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.optionList, function (item, idx) {
      return vue.openBlock(), vue.createBlock(_component_checkbox, {
        key: idx,
        name: item.name,
        label: item.label,
        value: item.value,
        "check-all": item.checkAll
      }, null, 8, ["name", "label", "value", "check-all"]);
    }), 128))]))], 2);
  }

  script$12.render = render$11;

  var CheckBox = withInstall(script$13);
  var CheckboxGroup = withInstall(script$12);

  var InputProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        return ["left", "center", "right"].includes(val);
      }
    },
    autocomplete: Boolean,
    autofocus: Boolean,
    clearable: Boolean,
    disabled: Boolean,
    errorMessage: {
      type: String,
      default: ""
    },
    label: {
      type: [String, Function]
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: Number
    },
    name: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: void 0
    },
    prefixIcon: {
      type: Function
    },
    readonly: Boolean,
    required: Boolean,
    size: {
      type: String,
      default: "small",
      validator: function validator(val) {
        return ["small", "medium"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    type: {
      type: String,
      default: "text",
      validator: function validator(val) {
        return ["text", "number", "url", "tel", "password", "search", "submit", "hidden"].includes(val);
      }
    },
    value: {
      type: [String, Number]
    },
    modelValue: {
      type: [String, Number]
    },
    defaultValue: {
      type: [String, Number]
    },
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onFocus: Function
  };

  function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$D(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$_ = config.prefix;
  var componentName$5 = "".concat(prefix$_, "-input");
  var script$11 = vue.defineComponent({
    name: componentName$5,
    components: {
      TNode: TNodeComponent,
      TCell: _Cell,
      CloseCircleFilledIcon: closeCircleFilled
    },
    props: InputProps,
    emits: ["update:value", "update:modelValue", "click-icon", "focus", "blur", "change", "clear"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var inputRef = vue.ref();
      var _toRefs = vue.toRefs(props),
        autofocus = _toRefs.autofocus;
      var internalInstance = vue.getCurrentInstance();
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        innerValue = _useDefault2[0];
      var styleLabel = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(componentName$5, "--label"), true), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _ref;
      });
      var _useFocus = useFocus(inputRef, {
          initialValue: props.autofocus
        }),
        focused = _useFocus.focused;
      var labelContent = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var suffixIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "suffixIcon");
      });
      var prefixIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "prefixIcon");
      });
      var suffixContent = vue.computed(function () {
        return renderTNode(internalInstance, "suffix");
      });
      var styleControl = vue.computed(function () {
        return ["".concat(componentName$5, "__control"), _defineProperty$2({}, "".concat(componentName$5, "__control--").concat(props.align), props.align !== "left")];
      });
      var styleWrapper = vue.computed(function () {
        var _ref3;
        return _ref3 = {}, _defineProperty$2(_ref3, componentName$5, true), _defineProperty$2(_ref3, "".concat(componentName$5, "--size-").concat(props.size), props.size), _defineProperty$2(_ref3, "".concat(componentName$5, "__error"), !!props.errorMessage), _ref3;
      });
      var setInputValue = function setInputValue() {
        var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var input = inputRef.value;
        var sV = String(v);
        if (!input) {
          return;
        }
        if (input.value !== sV) {
          input.value = sV;
        }
      };
      var handleInput = function handleInput(e) {
        var checkInputType = e.inputType && e.inputType === "insertCompositionText";
        if (e.isComposing || checkInputType) return;
        inputValueChangeHandle(e);
      };
      var inputValueChangeHandle = function inputValueChangeHandle(e) {
        var value = e.target.value;
        var maxcharacter = props.maxcharacter;
        if (maxcharacter && maxcharacter > 0 && !Number.isNaN(maxcharacter)) {
          var _getCharacterLength = getCharacterLength(value, maxcharacter);
            _getCharacterLength.length;
            var _getCharacterLength$c = _getCharacterLength.characters,
            characters = _getCharacterLength$c === void 0 ? "" : _getCharacterLength$c;
          innerValue.value = characters;
        } else {
          innerValue.value = value;
        }
        vue.nextTick(function () {
          return setInputValue(innerValue.value);
        });
      };
      var focus = function focus() {
        focused.value = true;
      };
      var blur = function blur() {
        focused.value = false;
      };
      extendAPI({
        focus: focus,
        blur: blur
      });
      var handleClear = function handleClear(e) {
        innerValue.value = "";
        focused.value = true;
        emitEvent("clear", {
          e: e
        });
      };
      var handleFocus = function handleFocus(e) {
        emitEvent("focus", innerValue.value, {
          e: e
        });
      };
      var handleBlur = function handleBlur(e) {
        emitEvent("blur", innerValue.value, {
          e: e
        });
      };
      var handleCompositionend = function handleCompositionend(e) {
        inputValueChangeHandle(e);
      };
      vue.watch(autofocus, function (autofocus2, prevAutofocus) {
        if (autofocus2 === true) {
          vue.nextTick(function () {
            focused.value = true;
          });
        }
      });
      return _objectSpread$D(_objectSpread$D({
        componentName: componentName$5
      }, vue.toRefs(props)), {}, {
        styleLabel: styleLabel,
        styleWrapper: styleWrapper,
        styleControl: styleControl,
        suffixContent: suffixContent,
        suffixIconContent: suffixIconContent,
        prefixIconContent: prefixIconContent,
        labelContent: labelContent,
        innerValue: innerValue,
        inputRef: inputRef,
        handleClear: handleClear,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleInput: handleInput,
        handleCompositionend: handleCompositionend
      });
    }
  });

  var _hoisted_1$n = ["value", "name", "type", "disabled", "autocomplete", "placeholder", "readonly", "maxlength"];
  function render$10(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_circle_filled_icon = vue.resolveComponent("close-circle-filled-icon");
    var _component_t_cell = vue.resolveComponent("t-cell");
    return vue.openBlock(), vue.createBlock(_component_t_cell, {
      required: _ctx.required,
      class: vue.normalizeClass(_ctx.styleWrapper)
    }, vue.createSlots({
      note: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap"))
        }, [vue.createElementVNode("input", {
          ref: "inputRef",
          value: _ctx.innerValue,
          name: _ctx.name,
          class: vue.normalizeClass(_ctx.styleControl),
          type: _ctx.type,
          disabled: _ctx.disabled,
          autocomplete: _ctx.autocomplete ? "On" : "Off",
          placeholder: _ctx.placeholder,
          readonly: _ctx.readonly,
          maxlength: _ctx.maxlength || -1,
          onFocus: _cache[0] || (_cache[0] = function () {
            return _ctx.handleFocus && _ctx.handleFocus.apply(_ctx, arguments);
          }),
          onBlur: _cache[1] || (_cache[1] = function () {
            return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
          }),
          onInput: _cache[2] || (_cache[2] = function () {
            return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
          }),
          onCompositionend: _cache[3] || (_cache[3] = function () {
            return _ctx.handleCompositionend && _ctx.handleCompositionend.apply(_ctx, arguments);
          })
        }, null, 42, _hoisted_1$n), _ctx.clearable && _ctx.innerValue && _ctx.innerValue.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--icon")),
          onClick: _cache[4] || (_cache[4] = function () {
            return _ctx.handleClear && _ctx.handleClear.apply(_ctx, arguments);
          })
        }, [vue.createVNode(_component_close_circle_filled_icon)], 2)) : vue.createCommentVNode("", true), _ctx.suffixContent ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--suffix"))
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.suffixContent
        }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2), _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__error-msg"))
        }, vue.toDisplayString(_ctx.errorMessage), 3)) : vue.createCommentVNode("", true)];
      }),
      _: 2
    }, [_ctx.labelContent ? {
      name: "title",
      fn: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.styleLabel)
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.labelContent
        }, null, 8, ["content"])], 2)];
      }),
      key: "0"
    } : void 0, _ctx.prefixIconContent ? {
      name: "leftIcon",
      fn: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.prefixIconContent
        }, null, 8, ["content"])];
      }),
      key: "1"
    } : void 0, _ctx.suffixIconContent ? {
      name: "rightIcon",
      fn: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.suffixIconContent
        }, null, 8, ["content"])];
      }),
      key: "2"
    } : void 0]), 1032, ["required", "class"]);
  }

  script$11.render = render$10;

  var _Input = withInstall(script$11);

  var TextareaProps = {
    autofocus: Boolean,
    autosize: Boolean,
    disabled: Boolean,
    label: {
      type: [String, Function]
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: Number
    },
    name: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: void 0
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: void 0
    },
    onBlur: Function,
    onChange: Function,
    onFocus: Function
  };

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  function getIEVersion() {
    var _navigator = navigator,
      userAgent = _navigator.userAgent;
    var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1;
    var isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
    if (isIE) {
      var reIE = new RegExp("MSIE (\\d+\\.\\d+);");
      var match = userAgent.match(reIE);
      if (!match) return -1;
      var fIEVersion = parseFloat(match[1]);
      return fIEVersion < 7 ? 6 : fIEVersion;
    }
    if (isIE11) {
      return 11;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  var DOM_STYLE_PROPS = ["padding-top", "padding-bottom", "padding-left", "padding-right", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "border-width", "box-sizing", "line-height", "letter-spacing"];
  function calculateNodeSize(targetElement) {
    var style = window.getComputedStyle(targetElement);
    var boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
    var paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    var borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    var sizingStyle = DOM_STYLE_PROPS.map(function (name) {
      return "".concat(name, ":").concat(style.getPropertyValue(name));
    }).join(";");
    return {
      paddingSize: paddingSize,
      borderSize: borderSize,
      boxSizing: boxSizing,
      sizingStyle: sizingStyle
    };
  }

  var TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
  var hiddenTextarea;
  function calcTextareaHeight(targetElement) {
    var _hiddenTextarea, _hiddenTextarea$paren;
    var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      document.body.appendChild(hiddenTextarea);
    }
    var _calculateNodeSize = calculateNodeSize(targetElement),
      paddingSize = _calculateNodeSize.paddingSize,
      borderSize = _calculateNodeSize.borderSize,
      boxSizing = _calculateNodeSize.boxSizing,
      sizingStyle = _calculateNodeSize.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(TEXTAREA_STYLE));
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
    var height = hiddenTextarea.scrollHeight;
    var result = {};
    var isBorderbox = boxSizing === "border-box";
    var isContentbox = boxSizing === "content-box";
    if (isBorderbox) {
      height += borderSize;
    } else if (isContentbox) {
      height -= paddingSize;
    }
    hiddenTextarea.value = "";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    (_hiddenTextarea = hiddenTextarea) === null || _hiddenTextarea === void 0 ? void 0 : (_hiddenTextarea$paren = _hiddenTextarea.parentNode) === null || _hiddenTextarea$paren === void 0 ? void 0 : _hiddenTextarea$paren.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    var calcHeight = function calcHeight(rows) {
      var rowsHeight = singleRowHeight * rows;
      if (isBorderbox) {
        rowsHeight = rowsHeight + paddingSize + borderSize;
      }
      return rowsHeight;
    };
    if (minRows !== null) {
      var minHeight = calcHeight(minRows);
      height = Math.max(minHeight, height);
      result.minHeight = "".concat(minHeight, "px");
    }
    if (maxRows !== null) {
      height = Math.min(calcHeight(maxRows), height);
    }
    result.height = "".concat(height, "px");
    return result;
  }

  function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$C(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$Z = config.prefix;
  var componentName$4 = "".concat(prefix$Z, "-textarea");
  var script$10 = vue.defineComponent({
    name: componentName$4,
    components: {
      TNode: TNodeComponent
    },
    props: TextareaProps,
    emits: ["update:value", "update:modelValue", "focus", "blur", "change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var textareaRef = vue.ref(null);
      var textareaStyle = vue.ref();
      var textareaLength = vue.ref(0);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerValue = _useVModel2[0],
        setInnerValue = _useVModel2[1];
      var textareaClassNames = vue.computed(function () {
        return ["".concat(componentName$4, "__wrapper"), _defineProperty$2({}, "".concat(componentName$4, "-is-disabled"), props.disabled)];
      });
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var setInputValue = function setInputValue() {
        var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var input = textareaRef.value;
        var sV = String(v);
        if (!input) {
          return;
        }
        if (input.value !== sV) {
          input.value = sV;
        }
      };
      var adjustTextareaHeight = function adjustTextareaHeight() {
        if (props.autosize === true) {
          textareaStyle.value = calcTextareaHeight(textareaRef.value);
        } else if (_typeof$1(props.autosize) === "object") {
          var _props$autosize = props.autosize,
            minRows = _props$autosize.minRows,
            maxRows = _props$autosize.maxRows;
          textareaStyle.value = calcTextareaHeight(textareaRef.value, minRows, maxRows);
        } else if (context.attrs.rows) {
          textareaStyle.value = {
            height: "auto",
            minHeight: "auto"
          };
        }
      };
      var handleInput = function handleInput(e) {
        if (e.isComposing || e.inputType === "insertCompositionText") return;
        textareaValueChangeHandle(e);
      };
      var textareaValueChangeHandle = function textareaValueChangeHandle(e) {
        var target = e.target;
        var value2 = target.value;
        if (props.maxcharacter && props.maxcharacter > 0 && !Number.isNaN(props.maxcharacter)) {
          var _getCharacterLength = getCharacterLength(value2, props.maxcharacter),
            _getCharacterLength$l = _getCharacterLength.length,
            length = _getCharacterLength$l === void 0 ? 0 : _getCharacterLength$l,
            _getCharacterLength$c = _getCharacterLength.characters,
            characters = _getCharacterLength$c === void 0 ? "" : _getCharacterLength$c;
          setInnerValue(characters);
          textareaLength.value = length;
        } else {
          setInnerValue(value2);
          textareaLength.value = String(innerValue.value).length;
        }
        vue.nextTick(function () {
          return setInputValue(innerValue.value);
        });
        adjustTextareaHeight();
      };
      var handleCompositionend = function handleCompositionend(e) {
        textareaValueChangeHandle(e);
      };
      var handleFocus = function handleFocus(e) {
        emitEvent("focus", innerValue.value, {
          e: e
        });
      };
      var handleBlur = function handleBlur(e) {
        emitEvent("blur", innerValue.value, {
          e: e
        });
      };
      vue.onMounted(function () {
        if (props.autofocus) {
          var _textareaRef$value;
          (_textareaRef$value = textareaRef.value) === null || _textareaRef$value === void 0 ? void 0 : _textareaRef$value.focus();
        }
        adjustTextareaHeight();
      });
      return _objectSpread$C(_objectSpread$C({
        componentName: componentName$4
      }, vue.toRefs(props)), {}, {
        labelContent: labelContent,
        innerValue: innerValue,
        textareaRef: textareaRef,
        textareaStyle: textareaStyle,
        textareaClassNames: textareaClassNames,
        textareaLength: textareaLength,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleInput: handleInput,
        handleCompositionend: handleCompositionend
      });
    }
  });

  var _hoisted_1$m = ["value", "name", "maxlength", "disabled", "placeholder"];
  function render$$(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentName)
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__name"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.textareaClassNames)
    }, [vue.createElementVNode("textarea", {
      ref: "textareaRef",
      value: _ctx.innerValue,
      style: vue.normalizeStyle(_ctx.textareaStyle),
      name: _ctx.name,
      maxlength: _ctx.maxlength || -1,
      disabled: _ctx.disabled,
      placeholder: _ctx.placeholder,
      onFocus: _cache[0] || (_cache[0] = function () {
        return _ctx.handleFocus && _ctx.handleFocus.apply(_ctx, arguments);
      }),
      onBlur: _cache[1] || (_cache[1] = function () {
        return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
      }),
      onInput: _cache[2] || (_cache[2] = function () {
        return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
      }),
      onCompositionend: _cache[3] || (_cache[3] = function () {
        return _ctx.handleCompositionend && _ctx.handleCompositionend.apply(_ctx, arguments);
      })
    }, null, 44, _hoisted_1$m), _ctx.maxcharacter || _ctx.maxlength ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__count"))
    }, vue.toDisplayString("".concat(_ctx.textareaLength, "/").concat(_ctx.maxcharacter || _ctx.maxlength)), 3)) : vue.createCommentVNode("", true)], 2)], 2);
  }

  script$10.render = render$$;

  var _Textarea = withInstall(script$10);

  var props$6 = {
    duration: {
      type: Number,
      default: 300
    },
    preventScrollThrough: {
      type: Boolean,
      default: true
    },
    transparent: Boolean,
    visible: {
      type: Boolean,
      default: true,
      required: true
    },
    zIndex: {
      type: Number,
      default: 1e3
    },
    customStyle: {
      type: String,
      default: ""
    },
    onClick: Function
  };

  var prefix$Y = config.prefix;
  var name$V = "".concat(prefix$Y, "-overlay");
  var script$$ = vue.defineComponent({
    name: name$V,
    props: props$6,
    setup: function setup(props2) {
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$V), true), _defineProperty$2(_ref, "".concat(name$V, "--active"), props2.visible), _defineProperty$2(_ref, "".concat(name$V, "--transparent"), props2.transparent), _ref;
      });
      var rootStyles = vue.computed(function () {
        return props2.customStyle || props2.zIndex || props2.duration ? (props2.customStyle && "".concat(props2.customStyle, ";")) + (props2.zIndex && "z-index:".concat(props2.zIndex, ";")) + (props2.duration && "transition-duration:".concat(props2.duration, "ms;")) : void 0;
      });
      var handleTouchMove = function handleTouchMove(e) {
        if (props2.preventScrollThrough) {
          e.stopPropagation();
          e.preventDefault();
        }
      };
      var handleClick = function handleClick(e) {
        var _props2$onClick;
        (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 ? void 0 : _props2$onClick.call(props2, {
          e: e
        });
      };
      return {
        name: name$V,
        classes: classes,
        rootStyles: rootStyles,
        handleClick: handleClick,
        handleTouchMove: handleTouchMove
      };
    }
  });

  function render$_(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      name: _ctx.name
    }, {
      default: vue.withCtx(function () {
        return [vue.withDirectives(vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.classes),
          style: vue.normalizeStyle(_ctx.rootStyles),
          onClick: _cache[0] || (_cache[0] = function () {
            return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
          }),
          onTouchmove: _cache[1] || (_cache[1] = function () {
            return _ctx.handleTouchMove && _ctx.handleTouchMove.apply(_ctx, arguments);
          })
        }, [vue.renderSlot(_ctx.$slots, "default")], 38), [[vue.vShow, _ctx.visible]])];
      }),
      _: 3
    }, 8, ["name"]);
  }

  script$$.render = render$_;

  var Overlay = withInstall(script$$);

  var _excluded = ["from", "to", "direction"];
  function getBackgroundColor(color) {
    if (typeof color === "string") {
      return color;
    }
    if (Array.isArray(color)) {
      if (color[0] && color[0][0] === "#") {
        color.unshift("90deg");
      }
      return "linear-gradient( ".concat(color.join(","), " )");
    }
    var from = color.from,
      to = color.to,
      _color$direction = color.direction,
      direction = _color$direction === void 0 ? "to right" : _color$direction,
      rest = _objectWithoutProperties(color, _excluded);
    var keys = Object.keys(rest);
    if (keys.length) {
      keys = keys.sort(function (a, b) {
        return parseFloat(a.substr(0, a.length - 1)) - parseFloat(b.substr(0, b.length - 1));
      });
      var tempArr = keys.map(function (key) {
        return "".concat(rest[key], " ").concat(key);
      });
      return "linear-gradient(".concat(direction, ", ").concat(tempArr.join(","), ")");
    }
    return "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")");
  }

  var progressProps = {
    color: {
      type: [String, Object, Array],
      default: ""
    },
    label: {
      type: [String, Boolean, Function],
      default: true
    },
    percentage: {
      type: Number,
      default: 0
    },
    status: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["success", "error", "warning", "active"].includes(val);
      }
    },
    strokeWidth: {
      type: [String, Number]
    },
    trackColor: {
      type: String,
      default: ""
    }
  };

  var prefix$X = config.prefix;
  var name$U = "".concat(prefix$X, "-progress");
  var script$_ = vue.defineComponent({
    name: name$U,
    components: {
      TNode: TNodeComponent
    },
    props: progressProps,
    setup: function setup(props) {
      var progressPercent = vue.computed(function () {
        return Math.max(0, Math.min(props.percentage, 100));
      });
      var progressStatusStyle = vue.computed(function () {
        if (props.percentage >= 100) {
          return "success";
        }
        return props.status;
      });
      var progressBarStyle = vue.computed(function () {
        var height = typeof props.strokeWidth === "string" ? props.strokeWidth : "".concat(props.strokeWidth, "px");
        return {
          height: height,
          backgroundColor: props.trackColor
        };
      });
      var progressBarPercenStyle = vue.computed(function () {
        return {
          width: "".concat(progressPercent.value, "%"),
          background: props.color && getBackgroundColor(props.color)
        };
      });
      var rootClasses = vue.computed(function () {
        return ["".concat(name$U), "".concat(name$U, "--status--").concat(progressStatusStyle.value)];
      });
      var internalInstance = vue.getCurrentInstance();
      var progressLabelContent = vue.computed(function () {
        return props.label && (_typeof$1(renderTNode(internalInstance, "label")) === "object" ? renderTNode(internalInstance, "label") : "".concat(progressPercent.value, "%"));
      });
      return {
        name: name$U,
        rootClasses: rootClasses,
        progressBarPercenStyle: progressBarPercenStyle,
        progressBarStyle: progressBarStyle,
        progressLabelContent: progressLabelContent
      };
    }
  });

  function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bar")),
      style: vue.normalizeStyle(_ctx.progressBarStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bar-percent")),
      style: vue.normalizeStyle(_ctx.progressBarPercenStyle)
    }, null, 6)], 6), _ctx.progressLabelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__label"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.progressLabelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)], 2);
  }

  script$_.render = render$Z;

  var _Progress = withInstall(script$_);

  var RadioProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        return ["left", "right"].includes(val);
      }
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: Boolean,
    content: {
      type: [String, Function]
    },
    contentDisabled: Boolean,
    default: {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: [String, Array],
      default: "fill-circle"
    },
    label: {
      type: [String, Function]
    },
    name: {
      type: String,
      default: ""
    },
    value: {
      type: [String, Number, Boolean],
      default: false
    },
    onChange: Function
  };

  function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$B(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$W = config.prefix;
  var name$T = "".concat(prefix$W, "-radio");
  var iconDefault$2 = [vue.h(check), ""];
  var script$Z = vue.defineComponent({
    name: name$T,
    components: {
      TNode: TNodeComponent
    },
    props: _objectSpread$B(_objectSpread$B({}, RadioProps), {}, {
      borderless: {
        type: Boolean,
        value: false
      }
    }),
    emits: ["update:checked", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _toRefs = vue.toRefs(props),
        checked = _toRefs.checked,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(checked, modelValue, props.defaultChecked, props.onChange, "checked"),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerChecked = _useVModel2[0],
        setInnerChecked = _useVModel2[1];
      var rootGroupProps = vue.inject("rootGroupProps", {});
      var rootGroupValue = vue.inject("rootGroupValue");
      var rootGroupChange = vue.inject("rootGroupChange", NOOP);
      var disabled = vue.computed(function () {
        return rootGroupProps.disabled !== void 0 ? rootGroupProps.disabled : props.disabled;
      });
      var radioChecked = vue.computed(function () {
        return rootGroupValue ? props.value === rootGroupValue.value : innerChecked.value;
      });
      var inputProps = vue.computed(function () {
        return {
          name: rootGroupProps.name || props.name,
          checked: radioChecked.value,
          disabled: disabled.value,
          value: props.value
        };
      });
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "label");
      });
      var radioContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var iconContent = vue.computed(function () {
        if (!props.icon) {
          return;
        }
        var iconIndex = radioChecked.value ? 0 : 1;
        var isIconArray = Array.isArray(props.icon);
        if (isIconArray) {
          return props.icon[iconIndex];
        }
        return iconDefault$2[iconIndex];
      });
      var radioClasses = vue.computed(function () {
        var _ref;
        return ["".concat(name$T), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, radioChecked.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, disabled.value), _ref)];
      });
      var titleClasses = vue.computed(function () {
        var _ref2;
        return ["".concat(name$T, "__content-title"), (_ref2 = {}, _defineProperty$2(_ref2, ClASSNAMES.STATUS.disabled, disabled.value), _defineProperty$2(_ref2, "".concat(name$T, "__content-right-title"), props.align === "right"), _ref2)];
      });
      var iconClass = vue.computed(function () {
        var _ref3;
        return ["".concat(name$T, "__icon"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(name$T, "__icon--checked"), radioChecked.value), _defineProperty$2(_ref3, "".concat(name$T, "__icon--disabled"), disabled.value), _defineProperty$2(_ref3, "".concat(name$T, "__icon--strock"), props.icon === "stroke-line"), _defineProperty$2(_ref3, "".concat(name$T, "__icon--custom"), Array.isArray(props.icon)), _ref3)];
      });
      var radioContentChange = function radioContentChange(e) {
        if (props.contentDisabled) {
          return;
        }
        radioOrgChange(e);
      };
      var radioOrgChange = function radioOrgChange(e) {
        if (disabled.value) {
          return;
        }
        if (rootGroupChange !== NOOP && props.value !== void 0) {
          rootGroupChange(props.value, e);
        } else {
          setInnerChecked(!radioChecked.value, {
            e: e
          });
        }
      };
      return {
        name: name$T,
        iconClass: iconClass,
        radioContent: radioContent,
        labelContent: labelContent,
        iconContent: iconContent,
        radioContentChange: radioContentChange,
        radioOrgChange: radioOrgChange,
        radioClasses: radioClasses,
        titleClasses: titleClasses,
        inputProps: inputProps
      };
    }
  });

  function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.radioClasses)
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__content-wrap")])
    }, [_ctx.align === "left" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-wrap ").concat(_ctx.name, "__icon-left-wrap"))
    }, [vue.createElementVNode("input", vue.mergeProps({
      type: "radio",
      class: "".concat(_ctx.name, "__original-left")
    }, _ctx.inputProps, {
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true), _ctx.labelContent || _ctx.radioContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass(["".concat(_ctx.name, "__label-wrap")])
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass(_ctx.titleClasses),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.radioContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__content-inner")),
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.radioContentChange && _ctx.radioContentChange.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.radioContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.align === "right" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-wrap ").concat(_ctx.name, "__icon-right-wrap"))
    }, [vue.createElementVNode("input", vue.mergeProps({
      type: "radio",
      class: "".concat(_ctx.name, "__original-right")
    }, _ctx.inputProps, {
      onClick: _cache[3] || (_cache[3] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true)], 2), !_ctx.borderless ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__border ").concat(_ctx.name, "__border--").concat(_ctx.align))
    }, null, 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$Z.render = render$Y;

  var _Radio = withInstall(script$Z);

  var RadioGroupProps = {
    disabled: {
      type: Boolean,
      default: void 0
    },
    name: {
      type: String,
      default: ""
    },
    options: {
      type: Array
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean],
      default: false
    },
    onChange: Function
  };

  function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$A(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$V = config.prefix;
  var componentName$3 = "".concat(prefix$V, "-radio-group");
  var script$Y = vue.defineComponent({
    name: componentName$3,
    components: {
      Radio: script$Z
    },
    props: RadioGroupProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        groupValue = _useDefault2[0],
        setGroupValue = _useDefault2[1];
      var groupOptions = vue.computed(function () {
        var _props$options;
        return (_props$options = props.options) === null || _props$options === void 0 ? void 0 : _props$options.map(function (option) {
          var opt = option;
          if (typeof option === "string" || typeof option === "number") {
            opt = {
              value: option,
              label: option.toString()
            };
          }
          return opt;
        });
      });
      var handleRadioChange = function handleRadioChange(val, e) {
        setGroupValue(val, {
          e: e
        });
      };
      vue.provide("rootGroupProps", props);
      vue.provide("rootGroupValue", groupValue);
      vue.provide("rootGroupChange", handleRadioChange);
      return _objectSpread$A(_objectSpread$A({}, vue.toRefs(props)), {}, {
        componentName: componentName$3,
        groupOptions: groupOptions
      });
    }
  });

  function render$X(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_radio = vue.resolveComponent("radio");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentName),
      role: "radiogroup"
    }, [_ctx.options ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.groupOptions, function (opt, idx) {
      return vue.openBlock(), vue.createBlock(_component_radio, {
        key: "radio-group-options-".concat(idx, "-").concat(Math.random()),
        name: _ctx.name,
        checked: _ctx.value === opt.value,
        disabled: "disabled" in opt ? opt.disabled : _ctx.disabled,
        value: opt.value,
        label: opt.label
      }, null, 8, ["name", "checked", "disabled", "value", "label"]);
    }), 128)) : vue.createCommentVNode("", true), !_ctx.options ? vue.renderSlot(_ctx.$slots, "default", {
      key: 1
    }) : vue.createCommentVNode("", true)], 2);
  }

  script$Y.render = render$X;

  var _RadioGroup = withInstall(script$Y);

  var rateProps = {
    allowHalf: Boolean,
    clearable: Boolean,
    color: {
      type: [String, Array]
    },
    count: {
      type: Number,
      default: 5
    },
    disabled: Boolean,
    gap: {
      type: Number,
      default: 6
    },
    showText: Boolean,
    size: {
      type: String,
      default: ""
    },
    texts: {
      type: Array
    },
    value: {
      type: Number,
      default: void 0
    },
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultValue: {
      type: Number,
      default: void 0
    },
    variant: {
      type: String,
      default: "filled",
      validator: function validator(val) {
        return ["outline", "filled"].includes(val);
      }
    },
    onChange: Function
  };

  var prefix$U = config.prefix;
  var name$S = "".concat(prefix$U, "-rate");
  var script$X = vue.defineComponent({
    name: name$S,
    components: {
      StarFilledIcon: starFilled,
      StarIcon: star
    },
    props: rateProps,
    emits: ["change", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var rateWrapper = vue.ref(null);
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        actualVal = _useDefault2[0];
      var rateText = vue.computed(function () {
        if (Array.isArray(props.texts) && props.texts.length > 0) {
          return props.texts[actualVal.value - 1];
        }
        return actualVal.value > 0 ? "".concat(actualVal.value, " \u5206") : "";
      });
      var colors = vue.computed(function () {
        if (Array.isArray(props.color)) return props.color;
        return [props.color, void 0];
      });
      var iconHalfStyle = function iconHalfStyle(n) {
        return {
          color: actualVal.value + 0.5 === n || actualVal.value >= n ? colors.value[0] : "transparent"
        };
      };
      var iconFullStyle = function iconFullStyle(n) {
        return {
          color: actualVal.value >= n ? colors.value[0] : "transparent"
        };
      };
      var startComponent = props.variant === "filled" ? starFilled : star;
      var classes = function classes(n) {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$S, "--item"), true), _defineProperty$2(_ref, "".concat(name$S, "-full"), actualVal.value >= n), _defineProperty$2(_ref, "".concat(name$S, "-half"), actualVal.value + 0.5 === n), _ref;
      };
      function onClick(current) {
        if (props.disabled) return;
        actualVal.value = props.clearable && actualVal.value === current ? 0 : current;
      }
      var ranges = [];
      function onTouchstart() {
        ranges = [];
        if (rateWrapper.value) {
          var items = rateWrapper.value.children;
          Array.from(items).forEach(function (node, index) {
            var _node$getBoundingClie = node.getBoundingClientRect(),
              left = _node$getBoundingClie.left,
              width = _node$getBoundingClie.width;
            if (props.allowHalf) {
              ranges.push({
                score: index + 0.5,
                left: left
              }, {
                score: index + 1,
                left: left + width / 2
              });
            } else {
              ranges.push({
                score: index + 1,
                left: left
              });
            }
          });
        }
      }
      function onTouchmove(e) {
        if (props.disabled) return;
        var clientX = e.touches[0].clientX;
        var score = props.allowHalf ? 0.5 : 1;
        for (var i = ranges.length - 1; i >= 0; i--) {
          if (clientX > ranges[i].left) {
            score = ranges[i].score;
            break;
          } else {
            score = 0;
          }
        }
        actualVal.value = score;
      }
      return {
        name: vue.ref(name$S),
        classes: classes,
        rateWrapper: rateWrapper,
        actualVal: actualVal,
        iconHalfStyle: iconHalfStyle,
        iconFullStyle: iconFullStyle,
        colors: colors,
        startComponent: startComponent,
        rateText: rateText,
        onClick: onClick,
        onTouchstart: onTouchstart,
        onTouchmove: onTouchmove
      };
    }
  });

  var _hoisted_1$l = ["onClick"];
  var _hoisted_2$9 = ["onClick"];
  var _hoisted_3$1 = ["onClick"];
  function render$W(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_star_filled_icon = vue.resolveComponent("star-filled-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("ul", {
      ref: "rateWrapper",
      class: vue.normalizeClass("".concat(_ctx.name, "--list")),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.onTouchstart && _ctx.onTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.onTouchmove && _ctx.onTouchmove.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.count, function (n) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: n,
        class: vue.normalizeClass(_ctx.classes(n)),
        style: vue.normalizeStyle({
          marginRight: "".concat(_ctx.count > n ? _ctx.gap : 0, "px")
        })
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--placeholder"))
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.startComponent), {
          size: _ctx.size,
          style: vue.normalizeStyle({
            color: _ctx.colors[1]
          })
        }, null, 8, ["size", "style"]))];
      })], 2), _ctx.allowHalf ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: 0
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--icon-left")),
        onClick: function onClick($event) {
          return _ctx.onClick(n - 0.5);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconHalfStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_1$l), vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--icon-right")),
        onClick: function onClick($event) {
          return _ctx.onClick(n);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconFullStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_2$9)], 64)) : (vue.openBlock(), vue.createElementBlock("span", {
        key: 1,
        class: vue.normalizeClass("".concat(_ctx.name, "--icon")),
        onClick: function onClick($event) {
          return _ctx.onClick(n);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconFullStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_3$1))], 6);
    }), 128))], 34), _ctx.showText ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "--text"))
    }, vue.toDisplayString(_ctx.rateText), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$X.render = render$W;

  var _Rate = withInstall(script$X);

  var SwitchProps = {
    colors: {
      type: Array
    },
    customValue: {
      type: Array
    },
    disabled: Boolean,
    label: {
      type: String,
      default: ""
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    onChange: Function
  };

  function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$z(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$T = config.prefix;
  var name$R = "".concat(prefix$T, "-switch");
  var script$W = vue.defineComponent({
    name: name$R,
    props: SwitchProps,
    emits: ["change", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var switchValues = props.customValue || [true, false];
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        innerValue = _useDefault2[0];
      var _useToggle = useToggle(switchValues, innerValue.value),
        state = _useToggle.state,
        toggle = _useToggle.toggle;
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$R), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, innerValue.value === switchValues[0]), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _ref)];
      });
      var backgroundColor = vue.computed(function () {
        if (!props.disabled && props.colors) {
          return "background-color: ".concat(innerValue.value === switchValues[0] ? props.colors[0] : props.colors[1]);
        }
        return "";
      });
      function handleToggle(event) {
        event.preventDefault();
        if (props.disabled) {
          return;
        }
        toggle();
        innerValue.value = state.value;
      }
      return _objectSpread$z(_objectSpread$z({
        name: name$R,
        classes: classes,
        backgroundColor: backgroundColor
      }, vue.toRefs(props)), {}, {
        handleToggle: handleToggle
      });
    }
  });

  function render$V(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.label ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, vue.toDisplayString(_ctx.label), 3)) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__node")),
      style: vue.normalizeStyle(_ctx.backgroundColor),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleToggle && _ctx.handleToggle.apply(_ctx, arguments);
      })
    }, null, 6)], 2);
  }

  script$W.render = render$V;

  var _Switch = withInstall(script$W);

  var StepperProps = {
    disabled: Boolean,
    disableInput: Boolean,
    inputWidth: {
      type: Number
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    theme: {
      type: String,
      default: "normal",
      validator: function validator(val) {
        return ["normal", "grey"].includes(val);
      }
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: 0
    },
    onBlur: Function,
    onChange: Function,
    onOverlimit: Function
  };

  function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$y(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$S = config.prefix;
  var name$Q = "".concat(prefix$S, "-stepper");
  var disabledClass = ClASSNAMES.STATUS.disabled;
  var script$V = vue.defineComponent({
    name: name$Q,
    components: {
      AddIcon: add,
      RemoveIcon: remove
    },
    props: StepperProps,
    emits: ["update:value", "update:modelValue", "blur", "change", "overlimit"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        stepperValue = _useDefault2[0];
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        min = _toRefs.min,
        max = _toRefs.max,
        step = _toRefs.step,
        inputWidth = _toRefs.inputWidth,
        theme = _toRefs.theme,
        disabled = _toRefs.disabled;
      var isPureMode = vue.computed(function () {
        return theme.value === "grey";
      });
      var inputStyle = vue.computed(function () {
        return inputWidth ? {
          width: "".concat(inputWidth.value, "px")
        } : "";
      });
      var isDisabled = function isDisabled(type) {
        if (disabled.value) return true;
        if (type === "minus" && stepperValue.value <= min.value) {
          return true;
        }
        if (type === "plus" && stepperValue.value >= max.value) {
          return true;
        }
        return false;
      };
      var formatValue = function formatValue(value) {
        return Math.max(Math.min(max.value, value, Number.MAX_SAFE_INTEGER), min.value, Number.MIN_SAFE_INTEGER);
      };
      var updateValue = function updateValue(value) {
        stepperValue.value = formatValue(value);
      };
      var plusValue = function plusValue() {
        if (isDisabled("plus")) {
          emitEvent("overlimit", "plus");
          return;
        }
        updateValue(Number(stepperValue.value) + step.value);
      };
      var minusValue = function minusValue() {
        if (isDisabled("minus")) {
          emitEvent("overlimit", "minus");
          return;
        }
        updateValue(Number(stepperValue.value) - step.value);
      };
      var handleInput = function handleInput(e) {
        handleChange(e);
      };
      var handleChange = function handleChange(e) {
        var value = e.target.value.match(/^\d+\.\d+|^\d+/g);
        if (isNaN(Number(value))) return;
        var formattedValue = formatValue(Number(value));
        updateValue(Number(formattedValue));
      };
      var handleBlur = function handleBlur(e) {
        handleChange(e);
        emitEvent("blur", stepperValue.value);
      };
      return _objectSpread$y({
        name: name$Q,
        disabledClass: disabledClass,
        minusValue: minusValue,
        stepperValue: stepperValue,
        plusValue: plusValue,
        handleInput: handleInput,
        handleChange: handleChange,
        inputStyle: inputStyle,
        handleBlur: handleBlur,
        isPureMode: isPureMode
      }, vue.toRefs(props));
    }
  });

  var _hoisted_1$k = ["disabled", "readonly"];
  function render$U(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_remove_icon = vue.resolveComponent("remove-icon");
    var _component_add_icon = vue.resolveComponent("add-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(["".concat(_ctx.name), "".concat(_ctx.disabled ? _ctx.disabledClass : ""), "".concat(_ctx.isPureMode ? "".concat(_ctx.name, "__pure") : "")])
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__minus"), "".concat(_ctx.disabled || _ctx.stepperValue <= _ctx.min ? "t-is-disabled" : "")]),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.minusValue && _ctx.minusValue.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_remove_icon, {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, null, 8, ["class"])], 2), vue.withDirectives(vue.createElementVNode("input", {
      "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
        return _ctx.stepperValue = $event;
      }),
      class: vue.normalizeClass("".concat(_ctx.name, "__input")),
      type: "tel",
      style: vue.normalizeStyle(_ctx.inputStyle),
      disabled: _ctx.disableInput || _ctx.disabled,
      readonly: _ctx.disableInput,
      onBlur: _cache[2] || (_cache[2] = function () {
        return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
      }),
      onInput: _cache[3] || (_cache[3] = function () {
        return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
      })
    }, null, 46, _hoisted_1$k), [[vue.vModelText, _ctx.stepperValue]]), vue.createElementVNode("div", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__plus"), "".concat(_ctx.disabled || _ctx.stepperValue >= _ctx.max ? "t-is-disabled" : "")]),
      onClick: _cache[4] || (_cache[4] = function () {
        return _ctx.plusValue && _ctx.plusValue.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_add_icon, {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, null, 8, ["class"])], 2)], 2);
  }

  script$V.render = render$U;

  var Stepper = withInstall(script$V);

  var props$5 = {
    disabled: Boolean,
    label: {
      type: [String, Boolean, Function],
      default: true
    },
    marks: {
      type: [Object, Array]
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    range: Boolean,
    showExtremeValue: Boolean,
    step: {
      type: Number,
      default: 1
    },
    value: {
      type: [Number, Array]
    },
    modelValue: {
      type: [Number, Array]
    },
    defaultValue: {
      type: [Number, Array]
    },
    onChange: Function,
    onDragend: Function,
    onDragstart: Function
  };

  var prefix$R = config.prefix;
  var name$P = "".concat(prefix$R, "-slider");
  var isArray$7 = Array.isArray;
  var script$U = vue.defineComponent({
    name: name$P,
    components: {
      TNode: TNodeComponent
    },
    props: props$5,
    emits: ["drag-start", "drag-end", "update:modelValue", "change"],
    setup: function setup(props2, context) {
      var rootRef = vue.ref(null);
      var barRef = vue.ref(null);
      var defaultValue = props2.defaultValue || props2.min;
      var _toRefs = vue.toRefs(props2),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue,
        max = _toRefs.max,
        min = _toRefs.min;
      var _useVModel = useVModel(value, modelValue, defaultValue, props2.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerValue = _useVModel2[0],
        setInnerValue = _useVModel2[1];
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return !props2.range && props2.label && (_typeof$1(renderTNode(internalInstance, "label")) === "object" ? renderTNode(internalInstance, "label") : "".concat(innerValue.value));
      });
      var isRange = vue.computed(function () {
        return props2.range && isArray$7(innerValue.value) && innerValue.value.length === 2;
      });
      var dots = vue.computed(function () {
        if (isRange.value) return innerValue.value;
        if (typeof innerValue.value === "number") return [innerValue.value];
        return [];
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$P, "-wrap"), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$R, "-is-disabled"), props2.disabled), _defineProperty$2(_ref, "".concat(prefix$R, "-is-mark"), props2.marks), _defineProperty$2(_ref, "".concat(prefix$R, "-is-value"), props2.showExtremeValue), _ref)];
      });
      var handleClass = vue.computed(function () {
        return ["".concat(name$P, "__handle")];
      });
      var marksData = vue.computed(function () {
        var sorter = function sorter(a, b) {
          return a[0] - b[0];
        };
        if (!props2.range && props2.marks) {
          if (isArray$7(props2.marks)) {
            return props2.marks.map(function (val) {
              return [val, val];
            }).sort(sorter);
          }
          return Object.entries(props2.marks).map(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
              key = _ref3[0],
              value2 = _ref3[1];
            return [parseInt(key, 10), value2];
          }).sort(sorter);
        }
        return [];
      });
      var dragStatus = vue.ref("");
      var touchData = vue.reactive({
        startValue: 0,
        newValue: 0,
        startX: 0,
        deltaX: 0,
        offsetX: 0
      });
      function onTouchStart(event, value2) {
        if (props2.disabled) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        touchData.deltaX = 0;
        touchData.offsetX = 0;
        touchData.startX = event.touches[0].clientX;
        touchData.startValue = format(value2);
        dragStatus.value = "start";
      }
      function onTouchMove(event, index) {
        if (props2.disabled) return;
        if (!barRef.value) return;
        event.stopPropagation();
        event.preventDefault();
        if (dragStatus.value === "start") {
          context.emit("drag-start");
        }
        var touch = event.touches[0];
        touchData.deltaX = touch.clientX - touchData.startX;
        touchData.offsetX = Math.abs(touchData.deltaX);
        dragStatus.value = "dragging";
        var rect = barRef.value.getBoundingClientRect();
        var delta = touchData.deltaX;
        var total = rect.width;
        var diff = delta / total * (props2.max - props2.min);
        touchData.newValue = touchData.startValue + diff;
        updateValue(touchData.newValue, index);
      }
      function onTouchEnd(event, index) {
        if (props2.disabled) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        if (dragStatus.value === "dragging") {
          updateValue(touchData.newValue, index, true);
          context.emit("drag-end");
        }
        dragStatus.value = "";
      }
      function onClick(event) {
        var _innerValue$value;
        event.stopPropagation();
        if (props2.disabled) return;
        if (!barRef.value) return;
        var rect = barRef.value.getBoundingClientRect();
        var delta = event.clientX - rect.left;
        var total = rect.width;
        var current = +props2.min + delta / total * (props2.max - props2.min);
        var index = 0;
        if (props2.range && innerValue.value) {
          if (Math.abs(current - innerValue.value[0]) > Math.abs(current - innerValue.value[1])) {
            index = 1;
          }
        }
        touchData.startValue = (_innerValue$value = innerValue.value) === null || _innerValue$value === void 0 ? void 0 : _innerValue$value[index];
        updateValue(current, index, true);
      }
      function format(value2) {
        var current = value2;
        if (!props2.range && props2.marks) {
          var _marksData$value;
          if (marksData !== null && marksData !== void 0 && (_marksData$value = marksData.value) !== null && _marksData$value !== void 0 && _marksData$value.length) {
            var _marksData$value$ = _slicedToArray(marksData.value[0], 1),
              min2 = _marksData$value$[0];
            marksData.value.forEach(function (_ref4) {
              var _ref5 = _slicedToArray(_ref4, 1),
                marksDataItemValue = _ref5[0];
              if (Math.abs(marksDataItemValue - value2) < Math.abs(min2 - value2)) {
                min2 = marksDataItemValue;
              }
            });
            current = min2;
          }
        }
        return Math.round(Math.max(props2.min, Math.min(current, props2.max)) / props2.step) * props2.step;
      }
      function updateValue(newValue, index) {
        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var formatValue = format(newValue);
        if (props2.range && Array.isArray(innerValue.value)) {
          var tmpValue = _toConsumableArray(innerValue.value);
          tmpValue[index] = formatValue;
          if (end && formatValue !== touchData.startValue) {
            tmpValue.sort(function (a, b) {
              return a - b;
            });
            setInnerValue(tmpValue);
          } else if (formatValue !== touchData.startValue) {
            setInnerValue(tmpValue);
          }
        } else if (formatValue !== touchData.startValue) {
          setInnerValue(formatValue);
        }
      }
      var getPercentage = function getPercentage(value2) {
        return (value2 ? value2 - props2.min : 0) / (props2.max - props2.min) * 100;
      };
      var trackStyle = vue.computed(function () {
        if (props2.range && isArray$7(innerValue.value)) {
          return {
            left: "".concat(getPercentage(Math.min(innerValue.value[0], innerValue.value[1])), "%"),
            width: "".concat(getPercentage(Math.abs(innerValue.value[1] - innerValue.value[0])), "%")
          };
        }
        if (!isArray$7(innerValue.value)) {
          return {
            width: "".concat(getPercentage(innerValue.value), "%")
          };
        }
        return {};
      });
      return {
        max: max,
        min: min,
        name: vue.ref(name$P),
        marksData: marksData,
        rootRef: rootRef,
        barRef: barRef,
        dots: dots,
        value: innerValue,
        labelContent: labelContent,
        classes: classes,
        handleClass: handleClass,
        trackStyle: trackStyle,
        getPercentage: getPercentage,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd,
        onClick: onClick
      };
    }
  });

  var _hoisted_1$j = ["onTouchstart", "onTouchmove", "onTouchend"];
  function render$T(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "rootRef",
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.showExtremeValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value--left"))
    }, vue.toDisplayString(_ctx.min), 3)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name)),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      ref: "barRef",
      class: vue.normalizeClass("".concat(_ctx.name, "__bar"))
    }, null, 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__track")),
      style: vue.normalizeStyle(_ctx.trackStyle)
    }, null, 6), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.dots, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index + 1,
        class: vue.normalizeClass(_ctx.handleClass),
        style: vue.normalizeStyle("left:".concat(_ctx.getPercentage(item), "%")),
        onTouchstart: function onTouchstart($event) {
          return _ctx.onTouchStart($event, item);
        },
        onTouchmove: function onTouchmove($event) {
          return _ctx.onTouchMove($event, index);
        },
        onTouchend: function onTouchend($event) {
          return _ctx.onTouchEnd($event, index);
        }
      }, null, 46, _hoisted_1$j);
    }), 128)), _ctx.marksData ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__mark"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.marksData, function (v, k) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: k,
        class: vue.normalizeClass("".concat(_ctx.name, "__mark-text t-is-").concat(_ctx.value && _ctx.value > v[0] ? "active" : "")),
        style: vue.normalizeStyle("left: ".concat(_ctx.getPercentage(v[0]), "%"))
      }, vue.toDisplayString(typeof v[1] === "function" ? v[1](v[0]) : v[1]), 7);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 2), _ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.showExtremeValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value"))
    }, vue.toDisplayString(_ctx.max), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$U.render = render$T;

  var _Slider = withInstall(script$U);

  var popupProps = {
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    customStyle: {
      type: String,
      default: ""
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    overlayProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    placement: {
      type: String,
      default: "top",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "left", "right", "bottom", "center"].includes(val);
      }
    },
    showOverlay: {
      type: Boolean,
      default: true
    },
    to: String,
    transitionName: {
      type: String,
      default: ""
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    zIndex: {
      type: Number
    },
    onClose: Function,
    onClosed: Function,
    onOpen: Function,
    onOpened: Function,
    onVisibleChange: Function
  };

  var prefix$Q = config.prefix;
  var name$O = "".concat(prefix$Q, "-popup");
  var script$T = vue.defineComponent({
    name: name$O,
    components: {
      TOverlay: Overlay
    },
    props: popupProps,
    emits: ["open", "close", "opened", "closed", "visible-change", "update:visible", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "visible", "visible-change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        currentVisible = _useDefault2[0];
      var rootClasses = vue.computed(function () {
        return name$O;
      });
      var rootStyles = vue.computed(function () {
        return props.customStyle || props.zIndex ? (props.customStyle && "".concat(props.customStyle, ";")) + (props.zIndex && "z-index:".concat(props.zIndex, ";")) : void 0;
      });
      var contentClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$O, "--content"), true), _defineProperty$2(_ref, "".concat(name$O, "--content-").concat(props.placement), true), _ref;
      });
      var contentTransitionName = vue.computed(function () {
        var transitionName = props.transitionName,
          placement = props.placement;
        if (transitionName) return transitionName;
        if (placement === "center") return "fade-zoom";
        return "slide-".concat(placement);
      });
      vue.watch(function () {
        return currentVisible.value;
      }, function (val) {
        var cls = "".concat(prefix$Q, "-overflow-hidden");
        if (val) {
          document.body.classList.add(cls);
          emitEvent("open");
          currentVisible.value = true;
        } else {
          document.body.classList.remove(cls);
        }
      });
      var handleOverlayClick = function handleOverlayClick() {
        if (!props.closeOnOverlayClick) {
          return;
        }
        emitEvent("close");
        currentVisible.value = false;
      };
      var handleMove = function handleMove(e) {
        if (props.lockScroll) {
          e.preventDefault();
        }
      };
      var afterLeave = function afterLeave() {
        return emitEvent("closed");
      };
      var afterEnter = function afterEnter() {
        return emitEvent("opened");
      };
      return {
        name: vue.ref(name$O),
        currentVisible: currentVisible,
        rootClasses: rootClasses,
        rootStyles: rootStyles,
        contentClasses: contentClasses,
        contentTransitionName: contentTransitionName,
        afterEnter: afterEnter,
        afterLeave: afterLeave,
        handleOverlayClick: handleOverlayClick,
        handleMove: handleMove
      };
    }
  });

  function render$S(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    return vue.openBlock(), vue.createBlock(vue.Teleport, {
      to: _ctx.to,
      disabled: !_ctx.to
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass([_ctx.rootClasses, _ctx.$attrs.class]),
      style: vue.normalizeStyle(_ctx.rootStyles),
      onTouchmove: _cache[0] || (_cache[0] = function () {
        return _ctx.handleMove && _ctx.handleMove.apply(_ctx, arguments);
      })
    }, [vue.createVNode(vue.Transition, {
      name: "fade"
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_overlay, vue.mergeProps(_ctx.overlayProps, {
          visible: _ctx.currentVisible,
          transparent: !_ctx.showOverlay,
          onClick: _ctx.handleOverlayClick
        }), null, 16, ["visible", "transparent", "onClick"])];
      }),
      _: 1
    }), vue.createVNode(vue.Transition, {
      name: _ctx.contentTransitionName,
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave
    }, {
      default: vue.withCtx(function () {
        return [vue.withDirectives(vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.contentClasses)
        }, [vue.renderSlot(_ctx.$slots, "default")], 2), [[vue.vShow, _ctx.currentVisible]])];
      }),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])], 38)], 8, ["to", "disabled"]);
  }

  script$T.render = render$S;

  var _Popup = withInstall(script$T);

  var DialogProps = {
    actions: {
      type: [Array, Function]
    },
    buttonLayout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    cancelBtn: {
      type: [String, Object, Function],
      default: ""
    },
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    confirmBtn: {
      type: [String, Object, Function],
      default: ""
    },
    content: {
      type: [String, Function]
    },
    destroyOnClose: Boolean,
    preventScrollThrough: {
      type: Boolean,
      default: true
    },
    showInAttachedElement: Boolean,
    showOverlay: {
      type: Boolean,
      default: true
    },
    title: {
      type: [String, Function]
    },
    visible: Boolean,
    width: {
      type: [String, Number]
    },
    zIndex: {
      type: Number
    },
    onCancel: Function,
    onClose: Function,
    onConfirm: Function,
    onOverlayClick: Function
  };

  function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$x(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$P = config.prefix;
  var name$N = "".concat(prefix$P, "-dialog");
  var script$S = vue.defineComponent({
    name: name$N,
    components: {
      TPopup: _Popup,
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: DialogProps,
    emits: ["update:visible", "confirm", "overlay-click", "cancel", "change", "close"],
    setup: function setup(props, context) {
      var internalInstance = vue.getCurrentInstance();
      var dialogContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var innerValue = vue.ref("");
      var dClassName = vue.computed(function () {
        return "".concat(name$N);
      });
      var dBoxClassName = vue.computed(function () {
        return "".concat(name$N, "__box");
      });
      var dHeaderClassName = vue.computed(function () {
        return ["".concat(name$N, "__header"), _defineProperty$2({}, "".concat(name$N, "__header--has-content"), dialogContent)];
      });
      var dTitleClassName = vue.computed(function () {
        return "".concat(name$N, "__title");
      });
      var dBodyClassName = vue.computed(function () {
        return "".concat(name$N, "__body");
      });
      var dTextClassName = vue.computed(function () {
        return "".concat(name$N, "__text");
      });
      var dInputClassName = vue.computed(function () {
        return "".concat(name$N, "__input");
      });
      var dFooterClassName = vue.computed(function () {
        return [_defineProperty$2({}, "".concat(name$N, "__vertical-footer"), props.buttonLayout === "vertical"), "".concat(name$N, "__footer")];
      });
      var dDefaultBtnClassName = vue.computed(function () {
        return ["".concat(name$N, "__btn"), "".concat(name$N, "__btn--default"), "".concat(name$N, "__").concat(props.buttonLayout, "-btn")];
      });
      var dConfirmBtnClassName = vue.computed(function () {
        return ["".concat(name$N, "__btn"), "".concat(name$N, "__btn--primary"), "".concat(name$N, "__").concat(props.buttonLayout, "-btn")];
      });
      var rootStyles = vue.computed(function () {
        return {
          zIndex: props.zIndex,
          width: typeof props.width === "string" ? props.width : "".concat(props.width, "px")
        };
      });
      var handleConfirm = function handleConfirm() {
        context.emit("update:visible", false);
        context.emit("confirm");
      };
      var handleCancel = function handleCancel() {
        context.emit("update:visible", false);
        context.emit("close", "cancel");
        context.emit("cancel");
      };
      var handleOverlayClick = function handleOverlayClick() {
        if (!props.closeOnOverlayClick) {
          return;
        }
        context.emit("update:visible", false);
        context.emit("close", "overlay");
        context.emit("overlay-click");
      };
      vue.watch(function () {
        return props.visible;
      }, function (val) {
        context.emit("change", val);
      });
      var calcBtn = function calcBtn(btn) {
        return typeof btn === "string" ? {
          content: btn
        } : btn;
      };
      var confirmBtnProps = vue.computed(function () {
        return calcBtn(props.confirmBtn);
      });
      var cancelBtnProps = vue.computed(function () {
        return calcBtn(props.cancelBtn);
      });
      var actionsBtnProps = vue.computed(function () {
        var _props$actions;
        return (_props$actions = props.actions) === null || _props$actions === void 0 ? void 0 : _props$actions.map(function (item) {
          return calcBtn(item);
        });
      });
      return _objectSpread$x({
        innerValue: innerValue,
        dClassName: dClassName,
        dBoxClassName: dBoxClassName,
        dHeaderClassName: dHeaderClassName,
        dTitleClassName: dTitleClassName,
        dBodyClassName: dBodyClassName,
        dTextClassName: dTextClassName,
        dInputClassName: dInputClassName,
        dFooterClassName: dFooterClassName,
        dDefaultBtnClassName: dDefaultBtnClassName,
        dConfirmBtnClassName: dConfirmBtnClassName,
        dialogContent: dialogContent,
        confirmBtnProps: confirmBtnProps,
        cancelBtnProps: cancelBtnProps,
        actionsBtnProps: actionsBtnProps,
        handleConfirm: handleConfirm,
        handleCancel: handleCancel,
        handleOverlayClick: handleOverlayClick,
        rootStyles: rootStyles
      }, vue.toRefs(props));
    }
  });

  function render$R(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      visible: _ctx.visible,
      placement: "center",
      "mask-transparent": !_ctx.showOverlay,
      "teleport-disabled": true,
      "lock-scroll": _ctx.preventScrollThrough,
      onClose: _ctx.handleOverlayClick
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          id: "root",
          class: vue.normalizeClass(_ctx.dClassName),
          style: vue.normalizeStyle(_ctx.rootStyles)
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dHeaderClassName)
        }, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
          return [_ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(_ctx.dTitleClassName)
          }, vue.toDisplayString(_ctx.title), 3)) : vue.createCommentVNode("", true)];
        })], 2), _ctx.content ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(_ctx.dBodyClassName)
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dTextClassName)
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.dialogContent
        }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dFooterClassName)
        }, [vue.renderSlot(_ctx.$slots, "actions", {}, function () {
          return [_ctx.actionsBtnProps ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
            key: 0
          }, vue.renderList(_ctx.actionsBtnProps, function (item, index) {
            return vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
              key: index
            }, item, {
              variant: "text",
              class: _ctx.dDefaultBtnClassName,
              onClick: _ctx.handleCancel
            }), null, 16, ["class", "onClick"]);
          }), 128)) : vue.createCommentVNode("", true)];
        }), vue.renderSlot(_ctx.$slots, "cancelBtn", {}, function () {
          return [_ctx.cancelBtn ? (vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
            key: 0
          }, _ctx.cancelBtnProps, {
            variant: "text",
            class: _ctx.dDefaultBtnClassName,
            onClick: _ctx.handleCancel
          }), null, 16, ["class", "onClick"])) : vue.createCommentVNode("", true)];
        }), vue.renderSlot(_ctx.$slots, "confirmBtn", {}, function () {
          return [_ctx.confirmBtn ? (vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
            key: 0
          }, _ctx.confirmBtnProps, {
            variant: "text",
            class: _ctx.dConfirmBtnClassName,
            onClick: _ctx.handleConfirm
          }), null, 16, ["class", "onClick"])) : vue.createCommentVNode("", true)];
        })], 2)], 6)];
      }),
      _: 3
    }, 8, ["visible", "mask-transparent", "lock-scroll", "onClose"]);
  }

  script$S.render = render$R;

  function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$w(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var DialogPropsDefault = {
    title: "\u6E29\u99A8\u63D0\u9192",
    content: "",
    type: "",
    confirmBtn: "\u786E\u8BA4",
    cancelBtn: "\u53D6\u6D88",
    visible: false,
    zIndex: 2500,
    showOverlay: true,
    width: "320px",
    closeOnOverlayClick: false
  };
  var instance$1;
  function create$1(props) {
    var visible = vue.ref(false);
    var root = document.createElement("div");
    document.body.appendChild(root);
    var propsObject = _objectSpread$w(_objectSpread$w({}, DialogPropsDefault), typeof props === "string" ? {
      content: props
    } : props);
    if (instance$1) {
      instance$1.clear();
    }
    instance$1 = vue.defineComponent({
      render: function render() {
        return vue.h(script$S, _objectSpread$w(_objectSpread$w({}, propsObject), {}, {
          visible: visible.value,
          onConfirm: function onConfirm(context) {
            if (typeof propsObject.onConfirm === "function") {
              propsObject.onConfirm(context);
            }
            visible.value = false;
          },
          onCancel: function onCancel(context) {
            if (typeof propsObject.onCancel === "function") {
              propsObject.onCancel(context);
            }
            visible.value = false;
          },
          onOverlayClick: function onOverlayClick(context) {
            if (typeof propsObject.onOverlayClick === "function") {
              propsObject.onOverlayClick(context);
            }
            visible.value = false;
          },
          onClose: function onClose(context) {
            root.remove();
            if (typeof propsObject.onClose === "function") {
              propsObject.onClose(context);
            }
          }
        }));
      }
    });
    instance$1.clear = function () {
      root.remove();
    };
    vue.createApp(instance$1).mount(root);
    vue.nextTick(function () {
      visible.value = true;
    });
    return instance$1;
  }
  ["show", "alert", "confirm"].forEach(function (type) {
    script$S[type] = function (options) {
      var props = {
        content: "",
        type: type
      };
      if (typeof options === "string") {
        props.content = options;
      } else {
        props = _objectSpread$w(_objectSpread$w({}, props), options);
      }
      return create$1(props);
    };
  });
  script$S.install = function (app) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    app.component(name || script$S.name, script$S);
    app.config.globalProperties.$dialog = script$S;
    app.provide("$dialog", script$S);
  };
  var DialogPlugin = script$S;

  var prefix$O = config.prefix;
  var name$M = "".concat(prefix$O, "-action-sheet");
  var script$R = vue.defineComponent({
    props: {
      items: {
        type: Array,
        required: true
      }
    },
    emits: ["selected"],
    setup: function setup(props, context) {
      var handleSelected = function handleSelected(index) {
        context.emit("selected", index);
      };
      return {
        name: vue.ref(name$M),
        handleSelected: handleSelected
      };
    }
  });

  var _hoisted_1$i = ["disabled", "onClick"];
  function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__menu"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("button", {
        key: index,
        class: vue.normalizeClass("".concat(_ctx.name, "__cell")),
        disabled: item.disabled,
        onClick: function onClick($event) {
          return _ctx.handleSelected(index);
        }
      }, [vue.renderSlot(_ctx.$slots, "cell", {
        item: item
      }, function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.name, "__cell-text")),
          style: vue.normalizeStyle({
            color: item.color
          })
        }, vue.toDisplayString(item.label), 7)];
      })], 10, _hoisted_1$i);
    }), 128))], 2);
  }

  script$R.render = render$Q;

  var gridProps = {
    align: {
      type: String,
      default: "center",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "center"].includes(val);
      }
    },
    border: {
      type: [Boolean, Object],
      default: false
    },
    column: {
      type: Number,
      default: 4
    },
    gutter: {
      type: Number
    }
  };

  var prefix$N = config.prefix;
  var name$L = "".concat(prefix$N, "-grid");
  var script$Q = vue.defineComponent({
    name: name$L,
    props: gridProps,
    setup: function setup(props) {
      var _toRefs = vue.toRefs(props),
        column = _toRefs.column,
        gutter = _toRefs.gutter,
        border = _toRefs.border,
        align = _toRefs.align;
      vue.provide("grid", {
        column: column,
        gutter: gutter,
        border: border,
        align: align
      });
      return {
        name: name$L
      };
    }
  });

  function render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$Q.render = render$P;

  var BadgeProps = {
    color: {
      type: String,
      default: ""
    },
    content: {
      type: [String, Function]
    },
    count: {
      type: [String, Number, Function],
      default: 0
    },
    dot: Boolean,
    maxCount: {
      type: Number,
      default: 99
    },
    offset: {
      type: Array
    },
    shape: {
      type: String,
      default: "circle",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round", "ribbon"].includes(val);
      }
    },
    showZero: Boolean,
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["small", "medium"].includes(val);
      }
    }
  };

  function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$v(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var name$K = "".concat(config.prefix, "-badge");
  var script$P = vue.defineComponent({
    name: name$K,
    components: {
      TNode: TNodeComponent
    },
    props: BadgeProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var badgeContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var countContent = vue.computed(function () {
        if (props.dot) {
          return "";
        }
        if (typeof props.count === "function") {
          return renderTNode(internalInstance, "count");
        }
        var count = Number(props.count);
        if (isNaN(count)) {
          return props.count;
        }
        return count > props.maxCount ? "".concat(props.maxCount, "+") : count;
      });
      var isIndependent = vue.computed(function () {
        return badgeContent.value === void 0;
      });
      var showDot = vue.computed(function () {
        return props.dot || props.count !== 0 || props.showZero;
      });
      var badgeClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$K), true), _defineProperty$2(_ref, "".concat(name$K, "__ribbon--outer"), props.shape === "ribbon"), _ref;
      });
      var badgeInnerClasses = vue.computed(function () {
        var _ref2;
        return _ref2 = {}, _defineProperty$2(_ref2, "".concat(name$K, "__inner"), true), _defineProperty$2(_ref2, "".concat(name$K, "--has-children"), !isIndependent.value), _defineProperty$2(_ref2, "".concat(name$K, "--").concat(props.size), props.size), _defineProperty$2(_ref2, "".concat(name$K, "--").concat(props.shape), props.shape && !props.dot), _defineProperty$2(_ref2, "".concat(name$K, "--dot"), props.dot), _ref2;
      });
      var badgeStyles = vue.computed(function () {
        if (!props.offset) {
          return {
            background: props.color
          };
        }
        var _props$offset = _slicedToArray(props.offset, 2),
          xOffset = _props$offset[0],
          yOffset = _props$offset[1];
        xOffset = isNaN(Number(xOffset)) ? xOffset : "".concat(xOffset, "px");
        yOffset = isNaN(Number(yOffset)) ? yOffset : "".concat(yOffset, "px");
        return {
          background: props.color,
          right: xOffset,
          top: yOffset
        };
      });
      return _objectSpread$v(_objectSpread$v({
        badgeContent: badgeContent,
        showDot: showDot,
        badgeStyles: badgeStyles,
        badgeClasses: badgeClasses,
        badgeInnerClasses: badgeInnerClasses
      }, vue.toRefs(props)), {}, {
        countContent: countContent
      });
    }
  });

  function render$O(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.badgeClasses)
    }, [_ctx.showDot ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.badgeInnerClasses),
      style: vue.normalizeStyle(_ctx.badgeStyles)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.countContent
    }, null, 8, ["content"])], 6)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.badgeContent
    }, null, 8, ["content"])], 2);
  }

  script$P.render = render$O;

  var _Badge = withInstall(script$P);

  var gridItemProps = {
    badgeProps: {
      type: Object
    },
    description: {
      type: [String, Function]
    },
    image: {
      type: [String, Function]
    },
    layout: {
      type: String,
      default: "vertical",
      validator: function validator(val) {
        if (!val) return true;
        return ["vertical", "horizontal"].includes(val);
      }
    },
    text: {
      type: [String, Function]
    }
  };

  function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$u(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$M = config.prefix;
  var name$J = "".concat(prefix$M, "-grid-item");
  var script$O = vue.defineComponent({
    name: name$J,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge
    },
    props: gridItemProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var isHorz = props.layout === "horizontal";
      var _inject = vue.inject("grid"),
        column = _inject.column,
        gutter = _inject.gutter,
        border = _inject.border,
        align = _inject.align;
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var textContent = vue.computed(function () {
        return renderTNode(internalInstance, "text");
      });
      var descContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var rootClass = vue.computed(function () {
        return ["".concat(name$J), _defineProperty$2({}, "".concat(name$J, "--bordered"), border.value)];
      });
      var rootStyle = vue.computed(function () {
        var percent = "".concat(100 / +column.value, "%");
        var borderStyle = {};
        if (border.value) {
          if (typeof border.value !== "boolean") {
            var _border$value = border.value,
              color = _border$value.color,
              width = _border$value.width,
              style2 = _border$value.style;
            return {
              borderColor: color,
              borderWidth: width,
              borderStyle: style2
            };
          }
        }
        var style = _objectSpread$u({
          flexBasis: percent,
          flexDirection: isHorz ? "row" : "column",
          paddingLeft: gutter.value ? "".concat(gutter.value, "px") : 0,
          paddingRight: gutter.value ? "".concat(gutter.value, "px") : 0,
          alignItems: "center",
          justifyContent: "center",
          textAlign: ["center", "left"].includes(align.value) ? align.value : "center"
        }, borderStyle);
        return style;
      });
      var imgStyle = vue.computed(function () {
        var imgSize = 32;
        if (column.value >= 5) {
          imgSize = 28;
        } else if (column.value <= 3) {
          imgSize = 48;
        }
        return {
          width: "".concat(imgSize, "px"),
          height: "".concat(imgSize, "px")
        };
      });
      var textStyle = vue.computed(function () {
        return {
          paddingLeft: isHorz ? "12px" : 0
        };
      });
      var titleStyle = vue.computed(function () {
        return {
          paddingTop: isHorz ? 0 : "8px",
          marginBottom: "4px"
        };
      });
      return {
        name: name$J,
        rootStyle: rootStyle,
        rootClass: rootClass,
        imgStyle: imgStyle,
        textStyle: textStyle,
        titleStyle: titleStyle,
        imageContent: imageContent,
        textContent: textContent,
        descContent: descContent
      };
    }
  });

  var _hoisted_1$h = ["src"];
  var _hoisted_2$8 = ["src"];
  function render$N(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClass),
      style: vue.normalizeStyle(_ctx.rootStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__image-box"))
    }, [_ctx.badgeProps ? (vue.openBlock(), vue.createBlock(_component_t_badge, {
      key: 0,
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset
    }, {
      default: vue.withCtx(function () {
        return [_ctx.image ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 0
        }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
          key: 0,
          src: _ctx.image,
          class: vue.normalizeClass("".concat(_ctx.name, "__image")),
          style: vue.normalizeStyle(_ctx.imgStyle)
        }, null, 14, _hoisted_1$h)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 1,
          content: _ctx.imageContent
        }, null, 8, ["content"]))], 64)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 8, ["count", "max-count", "dot", "content", "size", "offset"])) : _ctx.image ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
      key: 0,
      src: _ctx.image,
      class: vue.normalizeClass("".concat(_ctx.name, "__image")),
      style: vue.normalizeStyle(_ctx.imgStyle)
    }, null, 14, _hoisted_2$8)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 64)) : vue.createCommentVNode("", true)], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      style: vue.normalizeStyle(_ctx.textStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title")),
      style: vue.normalizeStyle(_ctx.titleStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.textContent
    }, null, 8, ["content"])], 6), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descContent
    }, null, 8, ["content"])], 2)], 6)], 6);
  }

  script$O.render = render$N;

  var Grid = withInstall(script$Q);
  var GridItem = withInstall(script$O);

  var prefix$L = config.prefix;
  var name$I = "".concat(prefix$L, "-action-sheet");
  var script$N = vue.defineComponent({
    components: {
      TGrid: Grid,
      TGridItem: GridItem
    },
    props: {
      items: {
        type: Array,
        required: true
      },
      count: {
        type: Number,
        default: 8
      }
    },
    emits: ["selected"],
    setup: function setup(props, context) {
      var containerWrapper = vue.ref(null);
      var moveOffset = vue.ref(0);
      var currentIndex = vue.ref(0);
      var useTransition = vue.ref(true);
      var startX = 0;
      var startOffset = 0;
      var canMove = true;
      var wrapperStyle = vue.computed(function () {
        return {
          transform: "translate3d(".concat(moveOffset.value, "px, 0, 0)"),
          transition: useTransition.value ? "transform 300ms" : "all"
        };
      });
      var gridColumn = vue.computed(function () {
        return Math.ceil(props.count / 2);
      });
      var pageNum = vue.computed(function () {
        return Math.ceil(props.items.length / props.count);
      });
      var actionItems = vue.computed(function () {
        var res = [];
        for (var i = 0; i < pageNum.value; i++) {
          var temp = props.items.slice(i * props.count, (i + 1) * props.count);
          res.push(temp);
        }
        return res;
      });
      var handleSelected = function handleSelected(index) {
        context.emit("selected", index);
      };
      var moveByIndex = function moveByIndex(index) {
        useTransition.value = true;
        if (containerWrapper.value) {
          moveOffset.value = pageNum.value > 1 ? index * containerWrapper.value.offsetWidth * -1 : 0;
        }
      };
      var getMaxOffset = function getMaxOffset() {
        if (!containerWrapper.value) return 0;
        return (pageNum.value - 1) * containerWrapper.value.offsetWidth;
      };
      var handleTouchstart = function handleTouchstart(e) {
        canMove = true;
        useTransition.value = false;
        startX = e.touches[0].clientX;
        startOffset = startX - moveOffset.value;
      };
      var handleTouchmove = function handleTouchmove(e) {
        var clientX = e.touches[0].clientX;
        var minOffset = 0;
        var maxOffset = getMaxOffset();
        if (Math.abs(clientX - startX) < 15) return;
        moveOffset.value = clientX - startOffset;
        if (moveOffset.value > minOffset) {
          moveOffset.value = minOffset;
          canMove = false;
        }
        if (Math.abs(moveOffset.value) >= maxOffset) {
          moveOffset.value = maxOffset * -1;
          canMove = false;
        }
      };
      var handleTouchend = function handleTouchend(e) {
        if (!canMove) return;
        var distance = e.changedTouches[0].clientX - startX;
        var targetIndex = Math.abs(distance) > 50 ? currentIndex.value + (distance < 0 ? 1 : -1) : currentIndex.value;
        currentIndex.value = targetIndex;
        moveByIndex(targetIndex);
      };
      return {
        name: vue.ref(name$I),
        gridColumn: gridColumn,
        pageNum: pageNum,
        actionItems: actionItems,
        currentIndex: currentIndex,
        containerWrapper: containerWrapper,
        wrapperStyle: wrapperStyle,
        handleSelected: handleSelected,
        handleTouchstart: handleTouchstart,
        handleTouchmove: handleTouchmove,
        handleTouchend: handleTouchend
      };
    }
  });

  function render$M(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_grid_item = vue.resolveComponent("t-grid-item");
    var _component_t_grid = vue.resolveComponent("t-grid");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "containerWrapper",
      class: vue.normalizeClass("".concat(_ctx.name, "__menu-wrapper"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__menu-slider")),
      style: vue.normalizeStyle(_ctx.wrapperStyle),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.handleTouchstart && _ctx.handleTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.handleTouchmove && _ctx.handleTouchmove.apply(_ctx, arguments);
      }),
      onTouchend: _cache[2] || (_cache[2] = function () {
        return _ctx.handleTouchend && _ctx.handleTouchend.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.actionItems, function (Items, i) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: i,
        class: vue.normalizeClass("".concat(_ctx.name, "__menu"))
      }, [vue.createVNode(_component_t_grid, {
        column: _ctx.gridColumn
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(Items, function (item, index) {
            return vue.openBlock(), vue.createBlock(_component_t_grid_item, {
              key: index,
              text: item.label,
              image: item.icon,
              onClick: function onClick($event) {
                return _ctx.handleSelected(i * _ctx.count + index);
              }
            }, null, 8, ["text", "image", "onClick"]);
          }), 128))];
        }),
        _: 2
      }, 1032, ["column"])], 2);
    }), 128))], 38), _ctx.pageNum > 1 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__indicator"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.pageNum, function (index) {
      var _normalizeClass2;
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index,
        class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__indicator-item"), true), _defineProperty$2(_normalizeClass2, "on", _ctx.currentIndex === index - 1), _normalizeClass2))
      }, null, 2);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$N.render = render$M;

  var prefix$K = config.prefix;
  var name$H = "".concat(prefix$K, "-action-sheet");
  var script$M = vue.defineComponent({
    name: name$H,
    components: {
      TPopup: _Popup,
      MenuList: script$R,
      MenuGrid: script$N
    },
    props: {
      modelValue: Boolean,
      visible: {
        type: Boolean,
        default: false
      },
      items: {
        type: Array,
        required: true
      },
      type: {
        type: String,
        default: "list"
      },
      count: {
        type: Number,
        default: 8
      },
      showCancel: {
        type: Boolean,
        default: true
      },
      cancelText: {
        type: String,
        default: "\u53D6\u6D88"
      }
    },
    emits: ["selected", "update:modelValue", "cancel", "close"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var actionItems = vue.ref([]);
      var currentVisible = vue.computed(function () {
        return props.modelValue || props.visible;
      });
      var rootClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$H, "__panel"), true), _defineProperty$2(_ref, "".concat(name$H, "__panel-list"), props.type === "list"), _defineProperty$2(_ref, "".concat(name$H, "__panel-grid"), props.type === "grid"), _ref;
      });
      vue.watch(function () {
        return props.items;
      }, function (val) {
        var items = JSON.parse(JSON.stringify(val));
        items = items.map(function (item) {
          if (typeof item === "string") {
            return {
              label: item
            };
          }
          return item;
        });
        actionItems.value = items;
      }, {
        immediate: true,
        deep: true
      });
      var handleCancel = function handleCancel() {
        emitEvent("cancel");
        context.emit("update:modelValue", false);
      };
      var handleSelected = function handleSelected(index) {
        emitEvent("selected", props.items[index], index);
      };
      var handleClose = function handleClose() {
        emitEvent("close");
        context.emit("update:modelValue", false);
      };
      return {
        name: vue.ref(name$H),
        rootClasses: rootClasses,
        actionItems: actionItems,
        currentVisible: currentVisible,
        handleCancel: handleCancel,
        handleSelected: handleSelected,
        handleClose: handleClose
      };
    }
  });

  function render$L(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_menu_list = vue.resolveComponent("menu-list");
    var _component_menu_grid = vue.resolveComponent("menu-grid");
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      class: vue.normalizeClass(_ctx.name),
      visible: _ctx.currentVisible,
      placement: "bottom",
      onClose: _ctx.handleClose
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.rootClasses)
        }, [_ctx.type === "list" ? (vue.openBlock(), vue.createBlock(_component_menu_list, {
          key: 0,
          items: _ctx.actionItems,
          onSelected: _ctx.handleSelected
        }, {
          cell: vue.withCtx(function (slotProps) {
            return [vue.renderSlot(_ctx.$slots, "cell", {
              item: slotProps.item
            })];
          }),
          _: 3
        }, 8, ["items", "onSelected"])) : (vue.openBlock(), vue.createBlock(_component_menu_grid, {
          key: 1,
          items: _ctx.actionItems,
          count: _ctx.count,
          onSelected: _ctx.handleSelected
        }, {
          cell: vue.withCtx(function (slotProps) {
            return [vue.renderSlot(_ctx.$slots, "cell", {
              item: slotProps.item
            })];
          }),
          _: 3
        }, 8, ["items", "count", "onSelected"])), _ctx.showCancel ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 2
        }, [_ctx.type === "list" ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.name, "__separation"))
        }, null, 2)) : vue.createCommentVNode("", true), vue.createElementVNode("button", {
          class: vue.normalizeClass("".concat(_ctx.name, "__action")),
          onClick: _cache[0] || (_cache[0] = function () {
            return _ctx.handleCancel && _ctx.handleCancel.apply(_ctx, arguments);
          })
        }, vue.toDisplayString(_ctx.cancelText), 3)], 64)) : vue.createCommentVNode("", true)], 2)];
      }),
      _: 3
    }, 8, ["class", "visible", "onClose"]);
  }

  script$M.render = render$L;

  var _ActionSheet = withInstall(script$M);

  var props$4 = {
    buttonProps: {
      type: Object
    },
    icon: {
      type: Function
    },
    style: {
      type: String,
      default: "right: 16px; bottom: 32px;"
    },
    text: {
      type: String,
      default: ""
    },
    onClick: Function
  };

  function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$t(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$J = config.prefix;
  var name$G = "".concat(prefix$J, "-fab");
  var script$L = vue.defineComponent({
    name: name$G,
    components: {
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: props$4,
    emits: ["click"],
    setup: function setup(props2, context) {
      var emitEvent = useEmitEvent(props2, context.emit);
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$G), true), _defineProperty$2(_ref, "".concat(name$G, "--icononly"), props2.icon && !props2.text), _ref;
      });
      var onClick = function onClick(e) {
        return emitEvent("click", {
          e: e
        });
      };
      var baseButtonProps = {
        size: "middle",
        shape: "round",
        theme: "primary"
      };
      var customButtonProps = vue.computed(function () {
        return _objectSpread$t(_objectSpread$t({}, baseButtonProps), props2.buttonProps);
      });
      var internalInstance = vue.getCurrentInstance();
      var iconTNode = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      return {
        name: name$G,
        classes: classes,
        iconTNode: iconTNode,
        customButtonProps: customButtonProps,
        onClick: onClick
      };
    }
  });

  function render$K(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps(_ctx.customButtonProps, {
      class: _ctx.classes,
      style: _ctx.style,
      onClick: _ctx.onClick
    }), {
      default: vue.withCtx(function () {
        return [_ctx.iconTNode ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.iconTNode
        }, null, 8, ["content"])) : vue.createCommentVNode("", true), _ctx.text ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass("".concat(_ctx.name, "__text"))
        }, vue.toDisplayString(_ctx.text), 3)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 16, ["class", "style", "onClick"]);
  }

  script$L.render = render$K;

  var _Fab = withInstall(script$L);

  var ImageViewerProps = {
    closeBtn: {
      type: [Boolean, Function],
      default: true
    },
    images: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 3
    },
    showIndex: Boolean,
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    onClose: Function,
    onIndexChange: Function
  };

  var SwiperProps = {
    animation: {
      type: String,
      default: "slide",
      validator: function validator(val) {
        if (!val) return true;
        return ["slide"].includes(val);
      }
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    current: {
      type: Number,
      default: void 0
    },
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultCurrent: {
      type: Number,
      default: 0
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    duration: {
      type: Number,
      default: 300
    },
    height: {
      type: Number
    },
    interval: {
      type: Number,
      default: 5e3
    },
    loop: {
      type: Boolean,
      default: true
    },
    navigation: {
      type: [Object, Function]
    },
    paginationPosition: {
      type: String,
      default: "bottom",
      validator: function validator(val) {
        if (!val) return true;
        return ["top-left", "top", "top-right", "bottom-left", "bottom", "bottom-right"].includes(val);
      }
    },
    onChange: Function
  };

  var prefix$I = config.prefix;
  var name$F = "".concat(prefix$I, "-swiper");
  var setOffset = function setOffset(element, offset) {
    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "X";
    element.style.transform = "translate".concat(direction, "(").concat(offset, "px)");
  };
  var script$K = vue.defineComponent({
    name: name$F,
    components: {
      ChevronLeftIcon: chevronLeft,
      ChevronRightIcon: chevronRight,
      TNode: TNodeComponent
    },
    props: SwiperProps,
    emits: ["change", "update:current", "update:modelValue"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "current", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2);
        _useDefault2[0];
        var setSwiperValue = _useDefault2[1];
      var self = vue.getCurrentInstance();
      var swiperContainer = vue.ref(null);
      var computedNavigation = vue.computed(function () {
        return renderTNode(self, "navigation");
      });
      var height = props.height || 180;
      var state = vue.reactive({
        showNavigation: true,
        activeIndex: 0,
        itemLength: 0,
        itemWidth: 0,
        isControl: false,
        btnDisabled: false,
        children: []
      });
      var paginationList = vue.computed(function () {
        return new Array(state.itemLength).fill(1);
      });
      var showPageNum = vue.computed(function () {
        var activeIndex = state.activeIndex,
          itemLength = state.itemLength;
        if (activeIndex > itemLength - 1) return itemLength;
        if (activeIndex < 0) return 1;
        return activeIndex + 1;
      });
      vue.computed(function () {
        return state.children.length;
      });
      var getContainer = function getContainer() {
        var _self$proxy;
        return self === null || self === void 0 ? void 0 : (_self$proxy = self.proxy) === null || _self$proxy === void 0 ? void 0 : _self$proxy.$el.querySelector(".".concat(name$F, "__container"));
      };
      var initSwiper = function initSwiper() {
        var _swiperContainer$chil, _swiperContainer$quer;
        var _swiperContainer = getContainer();
        _swiperContainer.querySelectorAll(".copy-item").forEach(function (ele) {
          _swiperContainer.removeChild(ele);
        });
        var items = _swiperContainer.querySelectorAll(".".concat(name$F, "-item"));
        state.itemLength = ((_swiperContainer$chil = _swiperContainer.children) === null || _swiperContainer$chil === void 0 ? void 0 : _swiperContainer$chil.length) || 0;
        var itemWidth = ((_swiperContainer$quer = _swiperContainer.querySelector(".".concat(name$F, "-item"))) === null || _swiperContainer$quer === void 0 ? void 0 : _swiperContainer$quer.getBoundingClientRect().width) || 0;
        state.itemWidth = itemWidth;
        if (items.length <= 0) return false;
        if (computedNavigation.value && "minShowNum" in computedNavigation.value && items.length < computedNavigation.value.minShowNum) {
          state.showNavigation = false;
        }
        if (props !== null && props !== void 0 && props.loop) {
          var first = items[0].cloneNode(true);
          first.classList.add("copy-item");
          var last = items[items.length - 1].cloneNode(true);
          last.classList.add("copy-item");
          _swiperContainer.appendChild(first);
          _swiperContainer.insertBefore(last, items[0]);
        }
        move(0);
        startAutoplay();
        if (typeof props.current === "number") {
          state.isControl = true;
          next(props.current);
        }
      };
      vue.onMounted(function () {
        vue.nextTick(function () {
          console.info("swiper mounted");
          initSwiper();
        });
      });
      vue.watch(function () {
        return state.children.length;
      }, function () {
        vue.nextTick(function () {
          console.info("swiper mounted");
          initSwiper();
        });
      });
      var autoplayTimer = null;
      var actionIsTrust = true;
      var move = function move(targetIndex) {
        var isTrust = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var _swiperContainer = getContainer();
        var moveDirection = (props === null || props === void 0 ? void 0 : props.direction) === "horizontal" ? "X" : "Y";
        var moveLength = (props === null || props === void 0 ? void 0 : props.direction) === "vertical" ? height : state.itemWidth;
        actionIsTrust = isTrust;
        _swiperContainer.dataset.isTrust = "".concat(isTrust);
        var toIndex = props !== null && props !== void 0 && props.loop ? targetIndex + 1 : targetIndex;
        _swiperContainer.style.transform = "translate".concat(moveDirection, "(-").concat(moveLength * toIndex, "px)");
      };
      var addAnimation = function addAnimation() {
        var _swiperContainer = getContainer();
        _swiperContainer.style.transition = "transform ".concat(props === null || props === void 0 ? void 0 : props.duration, "ms");
      };
      var removeAnimation = function removeAnimation() {
        var _swiperContainer = getContainer();
        _swiperContainer.style.transition = "none";
      };
      var handleAnimationEnd = function handleAnimationEnd() {
        state.btnDisabled = false;
        removeAnimation();
        if (state.activeIndex >= state.itemLength) {
          state.activeIndex = 0;
          move(0);
        }
        if (state.activeIndex <= -1) {
          state.activeIndex = state.itemLength - 1;
          move(state.itemLength - 1);
        }
        setTimeout(function () {
          actionIsTrust && emitCurrentChange(state.activeIndex);
        }, 0);
      };
      var stopAutoplay = function stopAutoplay() {
        if (!autoplayTimer) return;
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      };
      var startAutoplay = function startAutoplay() {
        if (typeof props.current === "number") return false;
        if (!(props !== null && props !== void 0 && props.autoplay) || autoplayTimer !== null) return false;
        autoplayTimer = setInterval(function () {
          state.activeIndex += 1;
          if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex >= state.children.length - 1) {
            state.activeIndex = 0;
          }
          if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex <= 0) {
            state.activeIndex = state.children.length - 1;
          }
          addAnimation();
          move(state.activeIndex);
        }, props === null || props === void 0 ? void 0 : props.interval);
      };
      var emitCurrentChange = function emitCurrentChange(index) {
        var resultIndex = index;
        if (index >= state.itemLength) resultIndex = 0;
        if (index < 0) resultIndex = state.itemLength - 1;
        setSwiperValue(resultIndex);
      };
      var prev = function prev() {
        var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var cannotMovePrev = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === 0;
        if (state.btnDisabled || cannotMovePrev) {
          move(state.activeIndex);
          return false;
        }
        stopAutoplay();
        state.activeIndex -= step;
        addAnimation();
        move(state.activeIndex);
        startAutoplay();
        state.btnDisabled = true;
      };
      var next = function next() {
        var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var cannotMoveLast = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === state.itemLength - 1;
        if (state.btnDisabled || cannotMoveLast) {
          move(state.activeIndex);
          return false;
        }
        stopAutoplay();
        state.activeIndex += step;
        addAnimation();
        move(state.activeIndex);
        startAutoplay();
        state.btnDisabled = true;
      };
      var _useSwipe = useSwipe(swiperContainer, {
          passive: false,
          onSwipeStart: function onSwipeStart(e) {
            if (state.btnDisabled) return false;
            stopAutoplay();
          },
          onSwipe: function onSwipe(e) {
            if (state.btnDisabled) return false;
            onTouchMove(e);
          },
          onSwipeEnd: function onSwipeEnd() {
            onTouchEnd();
          }
        }),
        lengthX = _useSwipe.lengthX,
        lengthY = _useSwipe.lengthY;
      var onTouchMove = function onTouchMove(event) {
        event.preventDefault();
        var activeIndex = state.activeIndex,
          itemWidth = state.itemWidth;
        var distanceX = lengthX.value;
        var distanceY = lengthY.value;
        var _container = getContainer();
        removeAnimation();
        var toIndex = props !== null && props !== void 0 && props.loop ? activeIndex + 1 : activeIndex;
        if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal") {
          setOffset(_container, -(toIndex * itemWidth + distanceX));
        } else {
          var _props$height = props.height,
            height2 = _props$height === void 0 ? 180 : _props$height;
          setOffset(_container, -(toIndex * height2 + distanceY), "Y");
        }
      };
      var onTouchEnd = function onTouchEnd() {
        var distanceX = lengthX.value;
        var distanceY = lengthY.value;
        addAnimation();
        if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal" && distanceX < -100 || (props === null || props === void 0 ? void 0 : props.direction) === "vertical" && distanceY < -100) {
          prev(1);
        } else if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal" && distanceX > 100 || (props === null || props === void 0 ? void 0 : props.direction) === "vertical" && distanceY > 100) {
          next(1);
        } else {
          move(state.activeIndex);
        }
        startAutoplay();
      };
      var relation = function relation(child) {
        if (child.proxy) {
          state.children.push(child.proxy);
        }
      };
      vue.provide("parent", {
        props: props,
        relation: relation
      });
      vue.watch(function () {
        return props.current;
      }, function (newPage, oldPage) {
        if (state.isControl) {
          state.activeIndex = newPage || 0;
          addAnimation();
          move(state.activeIndex, false);
        }
      });
      return {
        swiperContainer: swiperContainer,
        name: name$F,
        computedNavigation: computedNavigation,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd,
        handleAnimationEnd: handleAnimationEnd,
        state: state,
        paginationList: paginationList,
        showPageNum: showPageNum,
        prev: prev,
        next: next
      };
    }
  });

  var _hoisted_1$g = {
    key: 0
  };
  var _hoisted_2$7 = {
    key: 1
  };
  function render$J(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_chevron_left_icon = vue.resolveComponent("chevron-left-icon");
    var _component_chevron_right_icon = vue.resolveComponent("chevron-right-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      style: vue.normalizeStyle({
        height: "".concat(_ctx.height, "px"),
        overflow: "hidden"
      }),
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("div", {
      ref: "swiperContainer",
      class: vue.normalizeClass("".concat(_ctx.name, "__container")),
      style: vue.normalizeStyle({
        height: "".concat(_ctx.height, "px"),
        flexDirection: _ctx.direction === "horizontal" ? "row" : "column"
      }),
      onTransitionend: _cache[0] || (_cache[0] = function () {
        return _ctx.handleAnimationEnd && _ctx.handleAnimationEnd.apply(_ctx, arguments);
      })
    }, [vue.renderSlot(_ctx.$slots, "default")], 38), _ctx.navigation && _ctx.state.showNavigation ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [_ctx.direction === "horizontal" && "showSlideBtn" in _ctx.navigation && _ctx.navigation.showSlideBtn ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$g, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__btn btn-prev")),
      onClick: _cache[1] || (_cache[1] = function ($event) {
        return _ctx.prev(1);
      })
    }, [vue.createVNode(_component_chevron_left_icon, {
      size: "20px"
    })], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__btn btn-next")),
      onClick: _cache[2] || (_cache[2] = function ($event) {
        return _ctx.next(1);
      })
    }, [vue.createVNode(_component_chevron_right_icon, {
      size: "20px"
    })], 2)])) : vue.createCommentVNode("", true), "type" in _ctx.navigation ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__pagination ").concat(_ctx.name, "__pagination-").concat(_ctx.navigation.type || "", " ").concat(_ctx.name, "__pagination-").concat(_ctx.paginationPosition))
    }, [["dots", "dots-bar"].includes(_ctx.navigation.type || "") ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.state.children.length, function (item, index) {
      var _normalizeClass2;
      return vue.openBlock(), vue.createElementBlock("span", {
        key: "page" + index,
        class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "-dot"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "-dot--active"), index === _ctx.state.activeIndex), _normalizeClass2))
      }, null, 2);
    }), 128)) : vue.createCommentVNode("", true), _ctx.navigation.type && _ctx.navigation.type === "fraction" ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$7, vue.toDisplayString(_ctx.showPageNum + "/" + _ctx.state.children.length), 1)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true)], 64)) : _ctx.computedNavigation !== void 0 ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.computedNavigation,
      style: {}
    }, null, 8, ["content"])) : vue.createCommentVNode("", true)], 6);
  }

  script$K.render = render$J;

  var prefix$H = config.prefix;
  var name$E = "".concat(prefix$H, "-swiper-item");
  var script$J = vue.defineComponent({
    name: name$E,
    setup: function setup() {
      var parent = vue.inject("parent");
      parent.relation(vue.getCurrentInstance());
      return {
        name: name$E
      };
    }
  });

  function render$I(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$J.render = render$I;

  var Swiper = withInstall(script$K);
  var SwiperItem = withInstall(script$J);

  function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$s(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$G = config.prefix;
  var name$D = "".concat(prefix$G, "-image-viewer");
  var getDistance = function getDistance(touches) {
    return Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));
  };
  var script$I = vue.defineComponent({
    name: name$D,
    components: {
      CloseCircleFilledIcon: closeCircleFilled,
      TSwiper: Swiper,
      TSwiperItem: SwiperItem,
      TOverlay: Overlay,
      TNode: TNodeComponent
    },
    props: ImageViewerProps,
    emits: ["close", "index-change", "update:visible", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var state = vue.reactive({
        zooming: false,
        scale: 1
      });
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "visible", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        visible = _useDefault2[0],
        setVisible = _useDefault2[1];
      var lazyVisible = vue.ref(visible.value);
      var touch = useTouch$1();
      var internalInstance = vue.getCurrentInstance();
      var closeBtnTNode = vue.computed(function () {
        return renderTNode(internalInstance, "closeBtn");
      });
      var navigation = vue.computed(function () {
        if (props.showIndex) {
          return {
            type: "fraction"
          };
        }
        return {
          type: "dots",
          showSlideBtn: false
        };
      });
      var imageStyle = vue.computed(function () {
        var scale = state.scale,
          zooming = state.zooming;
        var style = {
          transitionDuration: zooming ? "0s" : ".3s"
        };
        if (scale !== 1) {
          style.transform = "scale(".concat(scale, ", ").concat(scale, ")");
        }
        return style;
      });
      var handleClose = function handleClose(e, trigger) {
        setVisible(false);
        emitEvent("close", {
          trigger: trigger,
          e: e
        });
      };
      var onSwiperChange = function onSwiperChange(index, context2) {
        emitEvent("index-change", index);
      };
      var fingerNum;
      var startScale;
      var startDistance;
      var doubleTapTimer;
      var touchStartTime;
      var onTouchStart = function onTouchStart(event) {
        event.preventDefault();
        event.stopPropagation();
        var touches = event.touches;
        touch.start(event);
        fingerNum = touches.length;
        touchStartTime = Date.now();
        state.zooming = fingerNum === 2;
        if (state.zooming) {
          startScale = state.scale;
          startDistance = getDistance(event.touches);
        }
      };
      var onTouchMove = function onTouchMove(event) {
        var touches = event.touches;
        touch.move(event);
        event.preventDefault();
        event.stopPropagation();
        if (state.zooming) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (state.zooming && touches.length === 2) {
          var distance = getDistance(touches);
          var scale = startScale * distance / startDistance;
          setScale(scale);
        }
      };
      var setScale = function setScale(scale) {
        scale = Math.min(scale, +props.maxZoom + 1);
        if (scale !== state.scale) {
          state.scale = scale;
        }
      };
      var resetScale = function resetScale() {
        setScale(1);
      };
      var toggleScale = function toggleScale() {
        var scale = state.scale > 1 ? 1 : 2;
        setScale(scale);
      };
      var checkTap = function checkTap(event) {
        if (fingerNum > 1) {
          return;
        }
        var offsetX = touch.offsetX,
          offsetY = touch.offsetY;
        var deltaTime = Date.now() - touchStartTime;
        var TAP_TIME = 250;
        var TAP_OFFSET = 5;
        if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {
          if (doubleTapTimer) {
            clearTimeout(doubleTapTimer);
            doubleTapTimer = null;
            toggleScale();
          } else {
            doubleTapTimer = window.setTimeout(function () {
              handleClose(event, "overlay");
              doubleTapTimer = null;
            }, TAP_TIME);
          }
        }
      };
      var onTouchEnd = function onTouchEnd(event) {
        event.preventDefault();
        if (state.zooming) {
          event.stopPropagation();
          if (!event.touches.length) {
            if (state.zooming) {
              state.zooming = false;
            }
            startScale = 1;
            if (state.scale < 1) {
              resetScale();
            }
            if (state.scale > props.maxZoom) {
              state.scale = +props.maxZoom;
            }
          }
        }
        checkTap(event);
        touch.reset();
      };
      vue.watch(function () {
        return visible.value;
      }, function (value) {
        if (!value) {
          resetScale();
        }
        setTimeout(function () {
          lazyVisible.value = value;
        }, 300);
      });
      return _objectSpread$s(_objectSpread$s({
        name: name$D,
        prefix: prefix$G,
        closeBtnTNode: closeBtnTNode,
        navigation: navigation,
        imageStyle: imageStyle,
        lazyVisible: lazyVisible
      }, vue.toRefs(props)), {}, {
        visible: visible,
        handleClose: handleClose,
        onSwiperChange: onSwiperChange,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd
      });
    }
  });

  var _hoisted_1$f = ["src"];
  function render$H(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_circle_filled_icon = vue.resolveComponent("close-circle-filled-icon");
    var _component_t_swiper_item = vue.resolveComponent("t-swiper-item");
    var _component_t_swiper = vue.resolveComponent("t-swiper");
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    return vue.openBlock(), vue.createBlock(_component_t_overlay, {
      class: vue.normalizeClass("".concat(_ctx.prefix, "-image-viewer")),
      visible: _ctx.visible
    }, {
      default: vue.withCtx(function () {
        return [_ctx.lazyVisible ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 0
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.name, "__close-icon")),
          onClick: _cache[0] || (_cache[0] = function ($event) {
            return _ctx.handleClose($event, "close-btn");
          })
        }, [!(typeof _ctx.closeBtnTNode === "boolean") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.closeBtnTNode
        }, null, 8, ["content"])) : typeof _ctx.closeBtn === "boolean" && _ctx.closeBtn ? (vue.openBlock(), vue.createBlock(_component_close_circle_filled_icon, {
          key: 1
        })) : vue.createCommentVNode("", true)], 2), vue.createVNode(_component_t_swiper, {
          autoplay: false,
          class: vue.normalizeClass("".concat(_ctx.name, "__swipe")),
          "default-current": _ctx.initialIndex,
          navigation: _ctx.navigation,
          "on-change": _ctx.onSwiperChange
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.images, function (image, index) {
              return vue.openBlock(), vue.createBlock(_component_t_swiper_item, {
                key: image + index,
                class: vue.normalizeClass("".concat(_ctx.name, "__swipe-item")),
                onTouchstart: _ctx.onTouchStart,
                onTouchmove: _ctx.onTouchMove,
                onTouchend: _ctx.onTouchEnd
              }, {
                default: vue.withCtx(function () {
                  return [vue.createElementVNode("img", {
                    src: image,
                    style: vue.normalizeStyle(_ctx.imageStyle),
                    class: vue.normalizeClass("".concat(_ctx.name, "__image"))
                  }, null, 14, _hoisted_1$f)];
                }),
                _: 2
              }, 1032, ["class", "onTouchstart", "onTouchmove", "onTouchend"]);
            }), 128))];
          }),
          _: 1
        }, 8, ["class", "default-current", "navigation", "on-change"])], 64)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 8, ["class", "visible"]);
  }

  script$I.render = render$H;

  var _ImageViewer = withInstall(script$I);

  var DrawerProps = {
    items: {
      type: Array
    },
    placement: {
      type: String,
      default: "right",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right", "top", "bottom"].includes(val);
      }
    },
    showOverlay: {
      type: Boolean,
      default: true
    },
    visible: Boolean,
    zIndex: {
      type: Number
    },
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    onClose: Function,
    onItemClick: Function,
    onOverlayClick: Function
  };

  var prefix$F = config.prefix;
  var name$C = "".concat(prefix$F, "-drawer");
  var script$H = vue.defineComponent({
    name: name$C,
    components: {
      TPopup: _Popup
    },
    props: DrawerProps,
    emits: ["update:visible", "itemClick", "overlayClick"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        items = _toRefs.items,
        placement = _toRefs.placement,
        showOverlay = _toRefs.showOverlay,
        zIndex = _toRefs.zIndex,
        closeOnOverlayClick = _toRefs.closeOnOverlayClick;
      var open = vue.ref(visible.value || false);
      var dSideBarClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar");
      });
      var dSideBarItemClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item");
      });
      var dSideBarItemIconClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item-icon");
      });
      var dSideBarItemTitleClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item-title");
      });
      vue.watch(open, function () {
        emitEvent("update:visible", open.value);
      });
      vue.watch(visible, function () {
        open.value = visible.value;
      });
      var onItemClick = function onItemClick(index, item, context2) {
        emitEvent("itemClick", index, item, context2);
      };
      var onVisibleChange = function onVisibleChange(visible2) {
        if (showOverlay.value) {
          emitEvent("overlayClick", {
            visible: visible2
          });
        }
      };
      var onClose = function onClose() {
        emitEvent("close", {
          trigger: "overlay"
        });
      };
      return {
        items: items,
        placement: placement,
        showOverlay: showOverlay,
        zIndex: zIndex,
        closeOnOverlayClick: closeOnOverlayClick,
        open: open,
        dSideBarClassName: dSideBarClassName,
        dSideBarItemClassName: dSideBarItemClassName,
        dSideBarItemIconClassName: dSideBarItemIconClassName,
        dSideBarItemTitleClassName: dSideBarItemTitleClassName,
        onItemClick: onItemClick,
        onVisibleChange: onVisibleChange,
        onClose: onClose
      };
    }
  });

  var _hoisted_1$e = ["onClick"];
  function render$G(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      modelValue: _ctx.open,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
        return _ctx.open = $event;
      }),
      placement: _ctx.placement,
      "show-overlay": _ctx.showOverlay,
      "z-index": _ctx.zIndex,
      "close-on-overlay-click": _ctx.closeOnOverlayClick,
      onVisibleChange: _ctx.onVisibleChange,
      onClose: _ctx.onClose
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dSideBarClassName)
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (item, index) {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: item.title,
            class: vue.normalizeClass(_ctx.dSideBarItemClassName),
            onClick: function onClick($event) {
              return _ctx.onItemClick(index, item, {
                e: $event
              });
            }
          }, [!!item.icon ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: vue.normalizeClass(_ctx.dSideBarItemIconClassName)
          }, [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.icon)))], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.dSideBarItemTitleClassName)
          }, vue.toDisplayString(item.title), 3)], 10, _hoisted_1$e);
        }), 128))], 2)];
      }),
      _: 1
    }, 8, ["modelValue", "placement", "show-overlay", "z-index", "close-on-overlay-click", "onVisibleChange", "onClose"]);
  }

  script$H.render = render$G;

  var _Drawer = withInstall(script$H);

  var NavbarProps = {
    leftArrow: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: "NavBar \u5BFC\u822A\u6761"
    },
    maxLen: {
      type: Number,
      default: 6
    },
    rightShow: {
      type: Boolean,
      default: true
    }
  };

  var prefix$E = config.prefix;
  var name$B = "".concat(prefix$E, "-navbar");
  var script$G = vue.defineComponent({
    name: name$B,
    components: {
      TChevronLeftIcon: chevronLeft
    },
    props: NavbarProps,
    emits: ["click-right", "click-text"],
    setup: function setup(props, context) {
      var nTitleContent = vue.computed(function () {
        var title = props.title,
          maxLen = props.maxLen;
        if (title && title.trim().length > maxLen) {
          return "".concat(title.slice(0, maxLen), "...");
        }
        return title;
      });
      var handleBack = function handleBack() {
        if (history.length > 1) {
          history.back();
        }
      };
      var handleMore = function handleMore(evt) {
        context.emit("click-right", evt);
      };
      var clickText = function clickText(evt) {
        context.emit("click-text", evt);
      };
      return {
        name: name$B,
        nTitleContent: nTitleContent,
        handleBack: handleBack,
        handleMore: handleMore,
        clickText: clickText
      };
    }
  });

  var _hoisted_1$d = /* @__PURE__ */vue.createElementVNode("svg", {
    t: "1614321969302",
    class: "icon",
    viewBox: "0 0 1024 1024",
    version: "1.1",
    xmlns: "http://www.w3.org/2000/svg",
    "p-id": "2091",
    width: "24",
    height: "24"
  }, [/* @__PURE__ */vue.createElementVNode("path", {
    d: "M512 449.749333a64 64 0 1 1 0 128 64 64 0 0 1 0-128z m-318.805333-1.109333a64 64 0 1 1 0 128 64 64 0 0 1 0-128z m638.677333 0a64 64 0 1 1 0 128 64 64 0 0 1 0-128z",
    fill: "#444444",
    "p-id": "2092"
  })], -1);
  var _hoisted_2$6 = [_hoisted_1$d];
  function render$F(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_chevron_left_icon = vue.resolveComponent("t-chevron-left-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__back"))
    }, [_ctx.leftArrow ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__back--arrow")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleBack && _ctx.handleBack.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_chevron_left_icon)], 2)) : vue.createCommentVNode("", true), vue.renderSlot(_ctx.$slots, "left")], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.clickText && _ctx.clickText.apply(_ctx, arguments);
      })
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.nTitleContent), 1)];
    })], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__right"))
    }, [vue.renderSlot(_ctx.$slots, "right"), _ctx.rightShow ? (vue.openBlock(), vue.createElementBlock("i", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__right--more")),
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.handleMore && _ctx.handleMore.apply(_ctx, arguments);
      })
    }, _hoisted_2$6, 2)) : vue.createCommentVNode("", true)], 2)], 2);
  }

  script$G.render = render$F;

  var _Navbar = withInstall(script$G);

  var messageProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "center"].includes(val);
      }
    },
    closeBtn: {
      type: [String, Boolean, Function],
      default: void 0
    },
    content: {
      type: [String, Function]
    },
    duration: {
      type: Number,
      default: 3e3
    },
    marquee: {
      type: [Boolean, Object],
      default: false
    },
    theme: {
      type: String,
      default: "info",
      validator: function validator(val) {
        if (!val) return true;
        return ["info", "success", "warning", "error"].includes(val);
      }
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    zIndex: {
      type: Number
    },
    onChange: Function,
    onClose: Function,
    onClosed: Function,
    onOpen: Function,
    onOpened: Function
  };

  var prefix$D = config.prefix;
  var name$A = "".concat(prefix$D, "-message");
  var script$F = vue.defineComponent({
    name: name$A,
    components: {
      CheckCircleFilledIcon: checkCircleFilled,
      ErrorCircleFilledIcon: errorCircleFilled,
      CloseIcon: close,
      TNode: TNodeComponent
    },
    props: messageProps,
    emits: ["visible-change", "open", "opened", "close", "closed"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var root = vue.ref(null);
      var internalInstance = vue.getCurrentInstance();
      var closeBtnContent = vue.computed(function () {
        return renderTNode(internalInstance, "closeBtn");
      });
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(visible, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        currentVisible = _useVModel2[0],
        setVisible = _useVModel2[1];
      var rootClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, name$A, true), _defineProperty$2(_ref, "".concat(name$A, "--").concat(props.theme), true), _defineProperty$2(_ref, "".concat(name$A, "-align--").concat(props.align), !!props.align), _ref;
      });
      var rootStyles = vue.computed(function () {
        return {
          zIndex: props.zIndex
        };
      });
      var onClose = function onClose() {
        emitEvent("close");
        setVisible(false);
      };
      vue.watch(function () {
        return currentVisible.value;
      }, function (val) {
        if (val === false) return;
        emitEvent("open");
        setVisible(true);
        if (props.duration > 0) {
          setTimeout(onClose, props.duration);
        }
      });
      return {
        name: vue.ref(name$A),
        root: root,
        currentVisible: currentVisible,
        rootClasses: rootClasses,
        rootStyles: rootStyles,
        closeBtnContent: closeBtnContent,
        onClose: onClose,
        afterEnter: function afterEnter() {
          return emitEvent("opened");
        },
        afterLeave: function afterLeave() {
          return emitEvent("closed");
        }
      };
    }
  });

  function render$E(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_check_circle_filled_icon = vue.resolveComponent("check-circle-filled-icon");
    var _component_error_circle_filled_icon = vue.resolveComponent("error-circle-filled-icon");
    var _component_close_icon = vue.resolveComponent("close-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      name: "message",
      onAfterLeave: _ctx.afterLeave,
      onAfterEnter: _ctx.afterEnter
    }, {
      default: vue.withCtx(function () {
        return [_ctx.currentVisible ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "root",
          class: vue.normalizeClass(_ctx.rootClasses),
          style: vue.normalizeStyle(_ctx.rootStyles)
        }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
          return [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
            return [_ctx.theme === "success" ? (vue.openBlock(), vue.createBlock(_component_check_circle_filled_icon, {
              key: 0
            })) : (vue.openBlock(), vue.createBlock(_component_error_circle_filled_icon, {
              key: 1
            }))];
          }), vue.createElementVNode("span", {
            class: vue.normalizeClass("".concat(_ctx.name, "--txt"))
          }, vue.toDisplayString(_ctx.content), 3), _ctx.closeBtn === true ? (vue.openBlock(), vue.createBlock(_component_close_icon, {
            key: 0,
            onClick: _ctx.onClose
          }, null, 8, ["onClick"])) : (vue.openBlock(), vue.createBlock(_component_t_node, {
            key: 1,
            content: _ctx.closeBtnContent
          }, null, 8, ["content"]))];
        })], 6)) : vue.createCommentVNode("", true)];
      }),
      _: 3
    }, 8, ["onAfterLeave", "onAfterEnter"]);
  }

  script$F.render = render$E;

  function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$r(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function create(props) {
    var visible = vue.ref(false);
    var root = document.createElement("div");
    document.body.appendChild(root);
    var component = vue.defineComponent({
      render: function render() {
        return vue.h(script$F, _objectSpread$r(_objectSpread$r({}, props), {}, {
          visible: visible.value,
          onClose: function onClose() {
            visible.value = false;
          },
          onClosed: function onClosed() {
            root.remove();
          }
        }));
      }
    });
    vue.createApp(component).mount(root);
    vue.nextTick(function () {
      visible.value = true;
    });
  }
  var defaultProps = {
    align: "left",
    closeBtn: "",
    content: "",
    duration: 3e3,
    theme: "info",
    visible: false,
    zIndex: 5e3,
    onClose: function onClose() {},
    onClosed: function onClosed() {},
    onOpen: function onOpen() {},
    onOpened: function onOpened() {},
    onChange: function onChange() {}
  };
  ["info", "success", "warning", "error"].forEach(function (theme) {
    script$F[theme] = function (options) {
      var props = _objectSpread$r(_objectSpread$r({}, defaultProps), {}, {
        theme: theme
      });
      if (typeof options === "string") {
        props.content = options;
      } else {
        props = _objectSpread$r(_objectSpread$r({}, props), options);
      }
      create(props);
    };
  });
  script$F.install = function (app) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    app.component(name || script$F.name, script$F);
    app.config.globalProperties.$message = script$F;
  };
  var MessagePlugin = script$F;

  var dayjs_min = {exports: {}};

  (function (module, exports) {
    !function (t, e) {
      module.exports = e() ;
    }(commonjsGlobal, function () {

      var t = 1e3,
        e = 6e4,
        n = 36e5,
        r = "millisecond",
        i = "second",
        s = "minute",
        u = "hour",
        a = "day",
        o = "week",
        f = "month",
        h = "quarter",
        c = "year",
        d = "date",
        $ = "Invalid Date",
        l = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        M = {
          name: "en",
          weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
          months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_")
        },
        m = function m(t, e, n) {
          var r = String(t);
          return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
        },
        g = {
          s: m,
          z: function z(t) {
            var e = -t.utcOffset(),
              n = Math.abs(e),
              r = Math.floor(n / 60),
              i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
          },
          m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
              i = e.clone().add(r, f),
              s = n - i < 0,
              u = e.clone().add(r + (s ? -1 : 1), f);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
          },
          a: function a(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
          },
          p: function p(t) {
            return {
              M: f,
              y: c,
              w: o,
              d: a,
              D: d,
              h: u,
              m: s,
              s: i,
              ms: r,
              Q: h
            }[t] || String(t || "").toLowerCase().replace(/s$/, "");
          },
          u: function u(t) {
            return void 0 === t;
          }
        },
        v = "en",
        D = {};
      D[v] = M;
      var p = function p(t) {
          return t instanceof _;
        },
        S = function t(e, n, r) {
          var i;
          if (!e) return v;
          if ("string" == typeof e) {
            var s = e.toLowerCase();
            D[s] && (i = s), n && (D[s] = n, i = s);
            var u = e.split("-");
            if (!i && u.length > 1) return t(u[0]);
          } else {
            var a = e.name;
            D[a] = e, i = a;
          }
          return !r && i && (v = i), i || !r && v;
        },
        w = function w(t, e) {
          if (p(t)) return t.clone();
          var n = "object" == _typeof$1(e) ? e : {};
          return n.date = t, n.args = arguments, new _(n);
        },
        O = g;
      O.l = S, O.i = p, O.w = function (t, e) {
        return w(t, {
          locale: e.$L,
          utc: e.$u,
          x: e.$x,
          $offset: e.$offset
        });
      };
      var _ = function () {
          function M(t) {
            this.$L = S(t.locale, null, !0), this.parse(t);
          }
          var m = M.prototype;
          return m.parse = function (t) {
            this.$d = function (t) {
              var e = t.date,
                n = t.utc;
              if (null === e) return new Date(NaN);
              if (O.u(e)) return new Date();
              if (e instanceof Date) return new Date(e);
              if ("string" == typeof e && !/Z$/i.test(e)) {
                var r = e.match(l);
                if (r) {
                  var i = r[2] - 1 || 0,
                    s = (r[7] || "0").substring(0, 3);
                  return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                }
              }
              return new Date(e);
            }(t), this.$x = t.x || {}, this.init();
          }, m.init = function () {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
          }, m.$utils = function () {
            return O;
          }, m.isValid = function () {
            return !(this.$d.toString() === $);
          }, m.isSame = function (t, e) {
            var n = w(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
          }, m.isAfter = function (t, e) {
            return w(t) < this.startOf(e);
          }, m.isBefore = function (t, e) {
            return this.endOf(e) < w(t);
          }, m.$g = function (t, e, n) {
            return O.u(t) ? this[e] : this.set(n, t);
          }, m.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }, m.valueOf = function () {
            return this.$d.getTime();
          }, m.startOf = function (t, e) {
            var n = this,
              r = !!O.u(e) || e,
              h = O.p(t),
              $ = function $(t, e) {
                var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a);
              },
              l = function l(t, e) {
                return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
              },
              y = this.$W,
              M = this.$M,
              m = this.$D,
              g = "set" + (this.$u ? "UTC" : "");
            switch (h) {
              case c:
                return r ? $(1, 0) : $(31, 11);
              case f:
                return r ? $(1, M) : $(0, M + 1);
              case o:
                var v = this.$locale().weekStart || 0,
                  D = (y < v ? y + 7 : y) - v;
                return $(r ? m - D : m + (6 - D), M);
              case a:
              case d:
                return l(g + "Hours", 0);
              case u:
                return l(g + "Minutes", 1);
              case s:
                return l(g + "Seconds", 2);
              case i:
                return l(g + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m.endOf = function (t) {
            return this.startOf(t, !1);
          }, m.$set = function (t, e) {
            var n,
              o = O.p(t),
              h = "set" + (this.$u ? "UTC" : ""),
              $ = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o],
              l = o === a ? this.$D + (e - this.$W) : e;
            if (o === f || o === c) {
              var y = this.clone().set(d, 1);
              y.$d[$](l), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
            } else $ && this.$d[$](l);
            return this.init(), this;
          }, m.set = function (t, e) {
            return this.clone().$set(t, e);
          }, m.get = function (t) {
            return this[O.p(t)]();
          }, m.add = function (r, h) {
            var d,
              $ = this;
            r = Number(r);
            var l = O.p(h),
              y = function y(t) {
                var e = w($);
                return O.w(e.date(e.date() + Math.round(t * r)), $);
              };
            if (l === f) return this.set(f, this.$M + r);
            if (l === c) return this.set(c, this.$y + r);
            if (l === a) return y(1);
            if (l === o) return y(7);
            var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[l] || 1,
              m = this.$d.getTime() + r * M;
            return O.w(m, this);
          }, m.subtract = function (t, e) {
            return this.add(-1 * t, e);
          }, m.format = function (t) {
            var e = this,
              n = this.$locale();
            if (!this.isValid()) return n.invalidDate || $;
            var r = t || "YYYY-MM-DDTHH:mm:ssZ",
              i = O.z(this),
              s = this.$H,
              u = this.$m,
              a = this.$M,
              o = n.weekdays,
              f = n.months,
              h = function h(t, n, i, s) {
                return t && (t[n] || t(e, r)) || i[n].slice(0, s);
              },
              c = function c(t) {
                return O.s(s % 12 || 12, t, "0");
              },
              d = n.meridiem || function (t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
              },
              l = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: a + 1,
                MM: O.s(a + 1, 2, "0"),
                MMM: h(n.monthsShort, a, f, 3),
                MMMM: h(f, a),
                D: this.$D,
                DD: O.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: h(n.weekdaysMin, this.$W, o, 2),
                ddd: h(n.weekdaysShort, this.$W, o, 3),
                dddd: o[this.$W],
                H: String(s),
                HH: O.s(s, 2, "0"),
                h: c(1),
                hh: c(2),
                a: d(s, u, !0),
                A: d(s, u, !1),
                m: String(u),
                mm: O.s(u, 2, "0"),
                s: String(this.$s),
                ss: O.s(this.$s, 2, "0"),
                SSS: O.s(this.$ms, 3, "0"),
                Z: i
              };
            return r.replace(y, function (t, e) {
              return e || l[t] || i.replace(":", "");
            });
          }, m.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m.diff = function (r, d, $) {
            var l,
              y = O.p(d),
              M = w(r),
              m = (M.utcOffset() - this.utcOffset()) * e,
              g = this - M,
              v = O.m(this, M);
            return v = (l = {}, l[c] = v / 12, l[f] = v, l[h] = v / 3, l[o] = (g - m) / 6048e5, l[a] = (g - m) / 864e5, l[u] = g / n, l[s] = g / e, l[i] = g / t, l)[y] || g, $ ? v : O.a(v);
          }, m.daysInMonth = function () {
            return this.endOf(f).$D;
          }, m.$locale = function () {
            return D[this.$L];
          }, m.locale = function (t, e) {
            if (!t) return this.$L;
            var n = this.clone(),
              r = S(t, e, !0);
            return r && (n.$L = r), n;
          }, m.clone = function () {
            return O.w(this.$d, this);
          }, m.toDate = function () {
            return new Date(this.valueOf());
          }, m.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }, m.toISOString = function () {
            return this.$d.toISOString();
          }, m.toString = function () {
            return this.$d.toUTCString();
          }, M;
        }(),
        T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function (t) {
        T[t[1]] = function (e) {
          return this.$g(e, t[0], t[1]);
        };
      }), w.extend = function (t, e) {
        return t.$i || (t(e, _, w), t.$i = !0), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function (t) {
        return w(1e3 * t);
      }, w.en = D[v], w.Ls = D, w.p = {}, w;
    });
  })(dayjs_min);
  var dayjs = dayjs_min.exports;

  var weekday$1 = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      module.exports = t() ;
    }(commonjsGlobal, function () {

      return function (e, t) {
        t.prototype.weekday = function (e) {
          var t = this.$locale().weekStart || 0,
            i = this.$W,
            n = (i < t ? i + 7 : i) - t;
          return this.$utils().u(e) ? n : this.subtract(n, "day").add(e, "day");
        };
      };
    });
  })(weekday$1);
  var weekday = weekday$1.exports;

  var customParseFormat$1 = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      module.exports = t() ;
    }(commonjsGlobal, function () {

      var e = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        n = /\d\d/,
        r = /\d\d?/,
        i = /\d*[^-_:/,()\s\d]+/,
        o = {},
        s = function s(e) {
          return (e = +e) + (e > 68 ? 1900 : 2e3);
        };
      var a = function a(e) {
          return function (t) {
            this[e] = +t;
          };
        },
        f = [/[+-]\d\d:?(\d\d)?|Z/, function (e) {
          (this.zone || (this.zone = {})).offset = function (e) {
            if (!e) return 0;
            if ("Z" === e) return 0;
            var t = e.match(/([+-]|\d\d)/g),
              n = 60 * t[1] + (+t[2] || 0);
            return 0 === n ? 0 : "+" === t[0] ? -n : n;
          }(e);
        }],
        h = function h(e) {
          var t = o[e];
          return t && (t.indexOf ? t : t.s.concat(t.f));
        },
        u = function u(e, t) {
          var n,
            r = o.meridiem;
          if (r) {
            for (var i = 1; i <= 24; i += 1) {
              if (e.indexOf(r(i, 0, t)) > -1) {
                n = i > 12;
                break;
              }
            }
          } else n = e === (t ? "pm" : "PM");
          return n;
        },
        d = {
          A: [i, function (e) {
            this.afternoon = u(e, !1);
          }],
          a: [i, function (e) {
            this.afternoon = u(e, !0);
          }],
          S: [/\d/, function (e) {
            this.milliseconds = 100 * +e;
          }],
          SS: [n, function (e) {
            this.milliseconds = 10 * +e;
          }],
          SSS: [/\d{3}/, function (e) {
            this.milliseconds = +e;
          }],
          s: [r, a("seconds")],
          ss: [r, a("seconds")],
          m: [r, a("minutes")],
          mm: [r, a("minutes")],
          H: [r, a("hours")],
          h: [r, a("hours")],
          HH: [r, a("hours")],
          hh: [r, a("hours")],
          D: [r, a("day")],
          DD: [n, a("day")],
          Do: [i, function (e) {
            var t = o.ordinal,
              n = e.match(/\d+/);
            if (this.day = n[0], t) for (var r = 1; r <= 31; r += 1) {
              t(r).replace(/\[|\]/g, "") === e && (this.day = r);
            }
          }],
          M: [r, a("month")],
          MM: [n, a("month")],
          MMM: [i, function (e) {
            var t = h("months"),
              n = (h("monthsShort") || t.map(function (e) {
                return e.slice(0, 3);
              })).indexOf(e) + 1;
            if (n < 1) throw new Error();
            this.month = n % 12 || n;
          }],
          MMMM: [i, function (e) {
            var t = h("months").indexOf(e) + 1;
            if (t < 1) throw new Error();
            this.month = t % 12 || t;
          }],
          Y: [/[+-]?\d+/, a("year")],
          YY: [n, function (e) {
            this.year = s(e);
          }],
          YYYY: [/\d{4}/, a("year")],
          Z: f,
          ZZ: f
        };
      function c(n) {
        var r, i;
        r = n, i = o && o.formats;
        for (var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (t, n, r) {
            var o = r && r.toUpperCase();
            return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e, t, n) {
              return t || n.slice(1);
            });
          })).match(t), a = s.length, f = 0; f < a; f += 1) {
          var h = s[f],
            u = d[h],
            c = u && u[0],
            l = u && u[1];
          s[f] = l ? {
            regex: c,
            parser: l
          } : h.replace(/^\[|\]$/g, "");
        }
        return function (e) {
          for (var t = {}, n = 0, r = 0; n < a; n += 1) {
            var i = s[n];
            if ("string" == typeof i) r += i.length;else {
              var o = i.regex,
                f = i.parser,
                h = e.slice(r),
                u = o.exec(h)[0];
              f.call(t, u), e = e.replace(u, "");
            }
          }
          return function (e) {
            var t = e.afternoon;
            if (void 0 !== t) {
              var n = e.hours;
              t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
            }
          }(t), t;
        };
      }
      return function (e, t, n) {
        n.p.customParseFormat = !0, e && e.parseTwoDigitYear && (s = e.parseTwoDigitYear);
        var r = t.prototype,
          i = r.parse;
        r.parse = function (e) {
          var t = e.date,
            r = e.utc,
            s = e.args;
          this.$u = r;
          var a = s[1];
          if ("string" == typeof a) {
            var f = !0 === s[2],
              h = !0 === s[3],
              u = f || h,
              d = s[2];
            h && (d = s[2]), o = this.$locale(), !f && d && (o = n.Ls[d]), this.$d = function (e, t, n) {
              try {
                if (["x", "X"].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
                var r = c(t)(e),
                  i = r.year,
                  o = r.month,
                  s = r.day,
                  a = r.hours,
                  f = r.minutes,
                  h = r.seconds,
                  u = r.milliseconds,
                  d = r.zone,
                  l = new Date(),
                  m = s || (i || o ? 1 : l.getDate()),
                  M = i || l.getFullYear(),
                  Y = 0;
                i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
                var p = a || 0,
                  v = f || 0,
                  D = h || 0,
                  g = u || 0;
                return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
              } catch (e) {
                return new Date("");
              }
            }(t, a, r), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), o = {};
          } else if (a instanceof Array) for (var l = a.length, m = 1; m <= l; m += 1) {
            s[1] = a[m - 1];
            var M = n.apply(this, s);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          } else i.call(this, e);
        };
      };
    });
  })(customParseFormat$1);
  var customParseFormat = customParseFormat$1.exports;

  var DateTimePickerProps = {
    cancelBtn: {
      type: String,
      default: "\u53D6\u6D88"
    },
    confirmBtn: {
      type: String,
      default: ""
    },
    end: {
      type: [String, Number]
    },
    format: {
      type: String,
      default: "YYYY-MM-DD HH:mm:ss"
    },
    mode: {
      type: [String, Array],
      default: "date"
    },
    renderLabel: {
      type: Function
    },
    showWeek: Boolean,
    start: {
      type: [String, Number]
    },
    title: {
      type: String,
      default: "\u9009\u62E9\u65F6\u95F4"
    },
    value: {
      type: [String, Number]
    },
    modelValue: {
      type: [String, Number]
    },
    defaultValue: {
      type: [String, Number]
    },
    onCancel: Function,
    onChange: Function,
    onConfirm: Function,
    onPick: Function
  };

  var PickerProps = {
    cancelBtn: {
      type: [String, Object],
      default: "\u53D6\u6D88"
    },
    columns: {
      type: [Array, Function],
      default: function _default() {
        return [];
      },
      required: true
    },
    confirmBtn: {
      type: [String, Object],
      default: "\u786E\u8BA4"
    },
    renderLabel: {
      type: [String, Function]
    },
    title: {
      type: String,
      default: ""
    },
    value: {
      type: Array
    },
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array
    },
    visible: Boolean,
    onCancel: Function,
    onChange: Function,
    onConfirm: Function,
    onPick: Function
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$q(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$C = config.prefix;
  var quartEaseOut = function quartEaseOut(t, b, c, d) {
    var tempT = t;
    return -c * ((tempT = tempT / d - 1) * tempT * tempT * tempT - 1) + b;
  };
  var DEFAULT_ITEM_HEIGHT = 40;
  var DEFAULT_HOLDER_HEIGHT = 200;
  var OFFSET_OF_BOUND = 60;
  var ANIMATION_TIME_LIMIT = 460;
  var ANIMATION_DURATION$1 = 150;
  var Picker$1 = /*#__PURE__*/function () {
    function Picker(options) {
      _classCallCheck(this, Picker);
      _defineProperty$2(this, "holder", void 0);
      _defineProperty$2(this, "options", void 0);
      _defineProperty$2(this, "list", null);
      _defineProperty$2(this, "elementItems", []);
      _defineProperty$2(this, "height", DEFAULT_HOLDER_HEIGHT);
      _defineProperty$2(this, "curIndex", 0);
      _defineProperty$2(this, "itemClassName", "");
      _defineProperty$2(this, "itemSelectedClassName", "");
      _defineProperty$2(this, "itemHeight", DEFAULT_ITEM_HEIGHT);
      _defineProperty$2(this, "lastMoveTime", 0);
      _defineProperty$2(this, "lastMoveStart", 0);
      _defineProperty$2(this, "stopInertiaMove", false);
      _defineProperty$2(this, "startY", 0);
      _defineProperty$2(this, "isPicking", false);
      _defineProperty$2(this, "offsetYOfStartBound", OFFSET_OF_BOUND);
      _defineProperty$2(this, "offsetYOfEndBound", -OFFSET_OF_BOUND);
      _defineProperty$2(this, "offsetY", 0);
      _defineProperty$2(this, "offsetYOfStart", 0);
      _defineProperty$2(this, "offsetYOfEnd", 0);
      _defineProperty$2(this, "onChange", void 0);
      if (!options.el) throw new Error("options el needed!");
      this.holder = options.el;
      this.options = options || {};
      this.onChange = options.onChange;
      this.init();
    }
    _createClass(Picker, [{
      key: "init",
      value: function init() {
        this.initScrollParams();
        this.setSelectedClassName();
        this.bindEvent();
      }
    }, {
      key: "updateItems",
      value: function updateItems() {
        this.elementItems = _toConsumableArray(this.holder.querySelectorAll("li"));
        var itemLen = this.elementItems.length;
        this.offsetYOfEnd = -this.itemHeight * (itemLen - 3);
        this.offsetYOfEndBound = -(this.itemHeight * (itemLen - 3) + OFFSET_OF_BOUND);
      }
    }, {
      key: "initScrollParams",
      value: function initScrollParams() {
        var _this$holder$querySel;
        this.list = this.holder.querySelector("ul");
        this.elementItems = _toConsumableArray(this.holder.querySelectorAll("li"));
        this.itemHeight = ((_this$holder$querySel = this.holder.querySelector("li")) === null || _this$holder$querySel === void 0 ? void 0 : _this$holder$querySel.offsetHeight) || DEFAULT_ITEM_HEIGHT;
        this.height = this.holder.offsetHeight || DEFAULT_HOLDER_HEIGHT;
        this.curIndex = this.options.defaultIndex || 0;
        this.itemClassName = "".concat(prefix$C, "-picker-item__item");
        this.itemSelectedClassName = "".concat(prefix$C, "-picker-item__item--selected");
        this.itemHeight = DEFAULT_ITEM_HEIGHT;
        this.startY = 0;
        this.isPicking = false;
        this.lastMoveTime = 0;
        this.lastMoveStart = 0;
        this.stopInertiaMove = false;
        var startOffsetY = (-this.curIndex + 2) * this.itemHeight;
        var itemLen = this.elementItems.length;
        this.setOffsetY(startOffsetY);
        this.offsetYOfStart = startOffsetY;
        this.offsetYOfEnd = -this.itemHeight * (itemLen - 3);
        this.offsetYOfStartBound = this.itemHeight * 2 + OFFSET_OF_BOUND;
        this.offsetYOfEndBound = -(this.itemHeight * (itemLen - 3) + OFFSET_OF_BOUND);
      }
    }, {
      key: "bindEvent",
      value: function bindEvent() {
        var _this = this;
        this.holder.addEventListener("touchstart", function (e) {
          return _this.touchStartHandler(e);
        }, false);
        this.holder.addEventListener("touchmove", function (e) {
          return _this.touchMoveHandler(e);
        }, false);
        this.holder.addEventListener("touchend", function (e) {
          return _this.touchEndHandler(e);
        }, false);
        this.holder.addEventListener("touchcancel", function (e) {
          return _this.touchEndHandler(e);
        }, false);
      }
    }, {
      key: "touchStartHandler",
      value: function touchStartHandler(event) {
        event.preventDefault();
        this.isPicking = true;
        if (!this.holder) return;
        if (this.list) this.list.style.transition = "";
        this.startY = event.changedTouches[0].pageY;
        this.updateInertiaParams(event, true);
      }
    }, {
      key: "touchMoveHandler",
      value: function touchMoveHandler(event) {
        event.preventDefault();
        if (!this.isPicking || !this.holder) return;
        var endY = event.changedTouches[0].pageY;
        var dragRange = endY - this.startY;
        this.updateInertiaParams(event, false);
        var moveOffsetY = (-this.curIndex + 2) * this.itemHeight + dragRange;
        this.setOffsetY(moveOffsetY);
      }
    }, {
      key: "touchEndHandler",
      value: function touchEndHandler(event) {
        event.preventDefault();
        this.isPicking = false;
        if (!this.holder) return;
        var point = event.changedTouches[0];
        var nowTime = event.timeStamp || Date.now();
        var moveTime = nowTime - this.lastMoveTime;
        if (moveTime > ANIMATION_TIME_LIMIT) {
          this.stopInertiaMove = false;
          this.endScroll();
          return;
        }
        var v = (point.pageY - this.lastMoveStart) / moveTime;
        var dir = v > 0 ? -1 : 1;
        var dampingCoefficient = 8e-4;
        var deceleration = -1 * dir * dampingCoefficient;
        var duration = Math.abs(v / deceleration);
        var endY = event.changedTouches[0].pageY;
        var dragRange = endY - this.startY;
        var dist = v * duration - Math.pow(duration, 2) * deceleration / 2 + dragRange;
        if (dist === 0) {
          this.stopInertiaMove = false;
          this.endScroll();
          return;
        }
        this.scrollDist(nowTime, this.offsetY, dist, duration);
      }
    }, {
      key: "updateInertiaParams",
      value: function updateInertiaParams(event, isStart) {
        var point = event.changedTouches[0];
        if (isStart) {
          this.lastMoveStart = point.pageY;
          this.lastMoveTime = event.timeStamp || Date.now();
        }
        this.stopInertiaMove = true;
      }
    }, {
      key: "scrollDist",
      value: function scrollDist(now, startOffsetY, dist, duration) {
        var _this2 = this;
        this.stopInertiaMove = false;
        var start = null;
        var inertiaMove = function inertiaMove(timestamp) {
          if (_this2.stopInertiaMove) {
            return;
          }
          if (!start) start = timestamp;
          var progress = timestamp - start;
          var newOffsetY = quartEaseOut(progress, startOffsetY, dist, duration);
          _this2.setOffsetY(newOffsetY);
          if (progress > duration || newOffsetY > _this2.offsetYOfStartBound || newOffsetY < _this2.offsetYOfEndBound) {
            _this2.endScroll();
          } else {
            window.requestAnimationFrame(inertiaMove);
          }
        };
        window.requestAnimationFrame(inertiaMove);
      }
    }, {
      key: "update",
      value: function update() {
        this.updateItems();
        var updateIndex = this.curIndex > this.elementItems.length - 1 ? 0 : this.curIndex;
        this.updateIndex(updateIndex);
      }
    }, {
      key: "updateIndex",
      value: function updateIndex(index, options) {
        var realOptions = _objectSpread$q({
          duration: 460,
          isChange: true
        }, options);
        this.curIndex = index;
        this.setSelectedClassName();
        var moveOffsetY = (-index + 2) * this.itemHeight;
        if (this.list) {
          this.list.style.transform = "translate(0,".concat(moveOffsetY, "px) translateZ(0)");
          this.list.style.transitionDuration = "".concat(realOptions.duration, "ms");
          this.list.style.transitionTimingFunction = "ease-out";
        }
        realOptions.isChange && this.onChange(index);
      }
    }, {
      key: "getCurIndex",
      value: function getCurIndex() {
        return this.curIndex;
      }
    }, {
      key: "fix3d",
      value: function fix3d(index) {
        for (var i = 0; i < this.elementItems.length; i++) {
          var deg = 25 * (-index + i);
          this.elementItems[i].style.transform = "rotateX(".concat(deg, "deg)");
          this.elementItems[i].style.webkitTransform = "rotateX(".concat(deg, "deg)");
        }
      }
    }, {
      key: "setSelectedClassName",
      value: function setSelectedClassName() {
        var _this3 = this;
        var regClass = new RegExp(this.itemClassName, "i");
        var regSelected = new RegExp(this.itemSelectedClassName, "i");
        this.elementItems.forEach(function (item, i) {
          var tempItem = item;
          var itemClass = tempItem.className;
          if (itemClass === "" || !itemClass) {
            tempItem.className = _this3.itemClassName;
          } else {
            if (!regClass.test(itemClass)) {
              tempItem.classList.add(_this3.itemClassName);
            }
            if (regSelected.test(itemClass)) {
              tempItem.classList.remove(_this3.itemSelectedClassName);
            }
          }
          if (_this3.curIndex === i) {
            tempItem.classList.add(_this3.itemSelectedClassName);
          }
        });
      }
    }, {
      key: "setOffsetY",
      value: function setOffsetY(offsetY) {
        this.offsetY = offsetY;
        if (this.list) {
          this.list.style.transform = "translate3d(0, ".concat(offsetY, "px, 0)");
        }
      }
    }, {
      key: "endScroll",
      value: function endScroll() {
        if (this.stopInertiaMove) return;
        var curIndex = 0;
        if (this.offsetY > this.offsetYOfStartBound) {
          curIndex = 0;
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
        } else if (this.offsetY < this.offsetYOfEndBound) {
          curIndex = this.elementItems.length - 1;
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
        } else {
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
          curIndex = 2 - Math.round(this.offsetY / this.itemHeight);
          if (curIndex < 0) curIndex = 0;
          if (curIndex > this.elementItems.length - 1) curIndex = this.elementItems.length - 1;
        }
        var offsetY = (-curIndex + 2) * this.itemHeight;
        this.setOffsetY(offsetY);
        if (curIndex !== this.curIndex) {
          this.curIndex = curIndex;
          this.setSelectedClassName();
          this.onChange(this.curIndex);
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        delete this.holder;
      }
    }]);
    return Picker;
  }();
  var Picker$2 = Picker$1;

  function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$p(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$B = config.prefix;
  var name$z = "".concat(prefix$B, "-picker-item");
  var script$E = vue.defineComponent({
    name: name$z,
    props: {
      options: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      defaultValue: {
        type: [String, Number],
        default: void 0
      },
      renderLabel: {
        type: Function,
        default: void 0
      }
    },
    emits: ["pick"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var picker = null;
      var el = document.createElement("div");
      var root = vue.ref(el);
      var getIndexByValue = function getIndexByValue(val) {
        var defaultIndex = 0;
        if (val !== void 0) {
          defaultIndex = props.options.findIndex(function (item) {
            return item.value === val;
          });
        }
        return defaultIndex < 0 ? 0 : defaultIndex;
      };
      var className = vue.computed(function () {
        return "".concat(name$z);
      });
      var wrapperClassName = vue.computed(function () {
        return ["".concat(name$z, "__wrapper")];
      });
      var itemClassName = vue.computed(function () {
        return ["".concat(name$z, "__item")];
      });
      var setIndex = function setIndex(index) {
        if (picker) {
          picker.updateItems();
          picker.updateIndex(index, {
            isChange: false
          });
        }
      };
      var setValue = function setValue(value) {
        if (picker) {
          picker.updateItems();
          picker.updateIndex(getIndexByValue(value), {
            isChange: false
          });
        }
      };
      var setOptions = function setOptions() {
        picker && picker.update();
      };
      var setUpdateItems = function setUpdateItems() {
        picker && picker.updateItems();
      };
      context.expose({
        setIndex: setIndex,
        setValue: setValue,
        setOptions: setOptions,
        setUpdateItems: setUpdateItems
      });
      vue.onMounted(function () {
        picker = new Picker$2({
          el: root.value,
          defaultIndex: getIndexByValue(props.defaultValue) || 0,
          onChange: function onChange(index) {
            var curItem = props.options[index];
            var changeValue = {
              value: curItem.value,
              index: index
            };
            emitEvent("pick", changeValue);
          }
        });
      });
      return _objectSpread$p({
        root: root,
        className: className,
        wrapperClassName: wrapperClassName,
        itemClassName: itemClassName
      }, vue.toRefs(props));
    }
  });

  function render$D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "root",
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createElementVNode("ul", {
      class: vue.normalizeClass(_ctx.wrapperClassName)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option, index) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: index,
        class: vue.normalizeClass(_ctx.itemClassName)
      }, vue.toDisplayString(_ctx.renderLabel ? _ctx.renderLabel(option) : option.label), 3);
    }), 128))], 2)], 2);
  }

  script$E.render = render$D;

  var prefix$A = config.prefix;
  var name$y = "".concat(prefix$A, "-picker");
  var getIndexFromColumns = function getIndexFromColumns(columns, value, column) {
    var _columns$column;
    var resultIndex;
    (_columns$column = columns[column]) === null || _columns$column === void 0 ? void 0 : _columns$column.forEach(function (item, index) {
      if (item.value === value) {
        resultIndex = index;
      }
    });
    return resultIndex;
  };
  var script$D = vue.defineComponent({
    name: name$y,
    components: {
      TButton: _Button,
      PickerItem: script$E
    },
    props: PickerProps,
    emits: ["change", "cancel", "pick", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        pickerValue = _useVModel2[0],
        setPickerValue = _useVModel2[1];
      var confirmButtonText = vue.computed(function () {
        return props.confirmBtn;
      });
      var cancelButtonText = vue.computed(function () {
        return props.cancelBtn;
      });
      var curValueArray = vue.ref(pickerValue.value.map(function (item) {
        return item;
      }));
      var realColumns = vue.computed(function () {
        if (typeof props.columns === "function") {
          var data = props.columns(curValueArray.value);
          return data;
        }
        return props.columns;
      });
      var lastTimeValueArray = _toConsumableArray(curValueArray.value);
      var curIndexArray = pickerValue.value.map(function (item, index) {
        return getIndexFromColumns(realColumns.value, item, index);
      });
      var lastTimeIndexArray = _toConsumableArray(curIndexArray);
      var pickerItemInstanceArray = vue.ref([]);
      vue.onMounted(function () {
        pickerItemInstanceArray.value = useChildSlots("t-picker-item").map(function (item) {
          return item.component;
        });
      });
      var handleConfirm = function handleConfirm(e) {
        lastTimeValueArray = _toConsumableArray(curValueArray.value);
        lastTimeIndexArray = _toConsumableArray(curIndexArray);
        setPickerValue(curValueArray.value);
        emitEvent("confirm", curValueArray.value, {
          index: curIndexArray
        });
      };
      var handleCancel = function handleCancel(e) {
        curValueArray.value = _toConsumableArray(lastTimeValueArray);
        curIndexArray = _toConsumableArray(lastTimeIndexArray);
        pickerItemInstanceArray.value.forEach(function (item, index) {
          var _item$exposed;
          (_item$exposed = item.exposed) === null || _item$exposed === void 0 ? void 0 : _item$exposed.setIndex(curIndexArray[index]);
        });
        emitEvent("cancel", {
          e: e
        });
      };
      var handlePick = function handlePick(context2, column) {
        if (curValueArray.value[column] !== context2.value) {
          curValueArray.value[column] = context2.value;
          curIndexArray[column] = context2.index;
          if (typeof props.columns === "function") {
            var result = props.columns(curValueArray.value);
            result.forEach(function (item, index) {
              if (!item.filter(function (ele) {
                return ele.value === curValueArray.value[index];
              }).length) {
                var _item$;
                curValueArray.value[index] = (_item$ = item[0]) === null || _item$ === void 0 ? void 0 : _item$.value;
                curIndexArray[index] = 0;
                vue.nextTick(function () {
                  var _pickerItemInstanceAr, _pickerItemInstanceAr2;
                  (_pickerItemInstanceAr = pickerItemInstanceArray.value[index]) === null || _pickerItemInstanceAr === void 0 ? void 0 : (_pickerItemInstanceAr2 = _pickerItemInstanceAr.exposed) === null || _pickerItemInstanceAr2 === void 0 ? void 0 : _pickerItemInstanceAr2.setIndex(0);
                });
              } else {
                vue.nextTick(function () {
                  var _pickerItemInstanceAr3, _pickerItemInstanceAr4;
                  (_pickerItemInstanceAr3 = pickerItemInstanceArray.value[index]) === null || _pickerItemInstanceAr3 === void 0 ? void 0 : (_pickerItemInstanceAr4 = _pickerItemInstanceAr3.exposed) === null || _pickerItemInstanceAr4 === void 0 ? void 0 : _pickerItemInstanceAr4.setUpdateItems();
                });
              }
            });
          }
          emitEvent("pick", curValueArray.value, {
            index: context2.index,
            column: column
          });
        }
      };
      var setValues = function setValues(values) {
        curValueArray.value = values;
        setPickerValue(values);
        vue.nextTick(function () {
          pickerItemInstanceArray.value.forEach(function (item, index) {
            var _item$exposed2;
            (_item$exposed2 = item.exposed) === null || _item$exposed2 === void 0 ? void 0 : _item$exposed2.setValue(values[index]);
          });
        });
      };
      useExpose({
        setValues: setValues
      });
      return {
        name: name$y,
        pickerValue: pickerValue,
        confirmButtonText: confirmButtonText,
        cancelButtonText: cancelButtonText,
        handleConfirm: handleConfirm,
        handleCancel: handleCancel,
        handlePick: handlePick,
        realColumns: realColumns
      };
    }
  });

  function render$C(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_button = vue.resolveComponent("t-button");
    var _component_picker_item = vue.resolveComponent("picker-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__toolbar"))
    }, [vue.createVNode(_component_t_button, {
      class: vue.normalizeClass("".concat(_ctx.name, "__cancel")),
      variant: "text",
      onClick: _ctx.handleCancel
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.cancelButtonText), 1)];
      }),
      _: 1
    }, 8, ["class", "onClick"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, vue.toDisplayString(_ctx.title), 3), vue.createVNode(_component_t_button, {
      class: vue.normalizeClass("".concat(_ctx.name, "__confirm")),
      variant: "text",
      onClick: _ctx.handleConfirm
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.confirmButtonText), 1)];
      }),
      _: 1
    }, 8, ["class", "onClick"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__main"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-item__group"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.realColumns, function (item, index) {
      return vue.openBlock(), vue.createBlock(_component_picker_item, {
        key: index,
        options: item,
        "default-value": _ctx.pickerValue[index],
        "render-label": _ctx.renderLabel,
        onPick: function onPick($event) {
          return _ctx.handlePick($event, index);
        }
      }, null, 8, ["options", "default-value", "render-label", "onPick"]);
    }), 128))], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__mask"))
    }, null, 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__indicator"))
    }, null, 2)], 2)], 2);
  }

  script$D.render = render$C;

  function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$o(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$z = config.prefix;
  var name$x = "".concat(prefix$z, "-cascade");
  var script$C = vue.defineComponent({
    name: name$x,
    components: {
      Picker: script$D
    },
    props: PickerProps,
    setup: function setup(props, context) {
      var pickerProps = vue.computed(function () {
        return _objectSpread$o({}, props);
      });
      var finalDepth = vue.ref(1);
      var finalSubOptionsRecord = vue.ref({});
      var generateCascadePickerColumns = function generateCascadePickerColumns(value, options, depth, subOptionsRecord) {
        var columns = [];
        columns.push(options.map(function (option) {
          return {
            label: option.label,
            value: option.value
          };
        }));
        for (var i = 0; i < depth - 1; i++) {
          var x = value[i];
          var subOptions = subOptionsRecord[x];
          if (!subOptions) {
            columns.push([]);
          } else {
            columns.push(subOptions.map(function (option) {
              return {
                label: option.label,
                value: option.value
              };
            }));
          }
        }
        return columns;
      };
      var initDepthAndRecord = function initDepthAndRecord(options) {
        var depth = 1;
        var subOptionsRecord = {};
        function traverse(option, currentDepth) {
          if (!option.children) {
            return;
          }
          subOptionsRecord[option.value] = option.children;
          var nextDepth = currentDepth + 1;
          if (nextDepth > depth) {
            depth = nextDepth;
          }
          option.children.forEach(function (option2) {
            traverse(option2, nextDepth);
          });
        }
        options.forEach(function (option) {
          traverse(option, 1);
        });
        finalDepth.value = depth;
        finalSubOptionsRecord.value = subOptionsRecord;
      };
      initDepthAndRecord(props.columns);
      return {
        name: name$x,
        finalDepth: finalDepth,
        finalSubOptionsRecord: finalSubOptionsRecord,
        pickerProps: pickerProps,
        generateCascadePickerColumns: generateCascadePickerColumns
      };
    }
  });

  function render$B(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_picker = vue.resolveComponent("picker");
    return vue.openBlock(), vue.createBlock(_component_picker, vue.mergeProps(_ctx.pickerProps, {
      columns: function columns(selected) {
        return _ctx.generateCascadePickerColumns(selected, _ctx.columns, _ctx.finalDepth, _ctx.finalSubOptionsRecord);
      }
    }), null, 16, ["columns"]);
  }

  script$C.render = render$B;

  var Picker = withInstall(script$D);
  var Cascade = withInstall(script$C);

  dayjs.extend(weekday);
  dayjs.extend(customParseFormat);
  var prefix$y = config.prefix;
  var name$w = "".concat(prefix$y, "-date-time-picker");
  var precisionRankRecord = {
    year: 0,
    month: 1,
    date: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  var script$B = vue.defineComponent({
    name: name$w,
    components: {
      TPicker: Picker
    },
    props: DateTimePickerProps,
    emits: ["change", "cancel", "confirm", "pick", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var pickeInstance = vue.ref(null);
      var isChanged = vue.ref(false);
      var realDateValue = vue.ref();
      var className = vue.computed(function () {
        return ["".concat(name$w)];
      });
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        dateTimePickerValue = _useVModel2[0],
        setDateTimePickerValue = _useVModel2[1];
      var title = vue.computed(function () {
        return props.title || "\u9009\u62E9\u65F6\u95F4";
      });
      var confirmButtonText = vue.computed(function () {
        return props.confirmBtn || "\u786E\u5B9A";
      });
      var cancelButtonText = vue.computed(function () {
        return props.cancelBtn || "\u53D6\u6D88";
      });
      var start = vue.computed(function () {
        return props.start ? dayjs(props.start) : dayjs().subtract(10, "year");
      });
      var end = vue.computed(function () {
        return props.end ? dayjs(props.end) : dayjs().add(10, "year");
      });
      var renderLabel = vue.computed(function () {
        return props.renderLabel;
      });
      var isPrecision = function isPrecision(type) {
        if (!props.mode) {
          return false;
        }
        switch (type) {
          case "year":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 0 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 0;
          case "month":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 1 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 1;
          case "date":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 2 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 2;
          case "hour":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 3 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 3;
          case "minute":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 4 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 4;
          case "second":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 5 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 5;
          default:
            return true;
        }
      };
      var getPickerValueByDateTimePickerValue = function getPickerValueByDateTimePickerValue(value2) {
        var currentDate = dayjs(value2);
        var ret = [];
        Object.keys(precisionRankRecord).forEach(function (item) {
          if (isPrecision(item)) {
            ret.push("".concat(currentDate[item]()));
          }
        });
        return ret;
      };
      var pickerValue = vue.ref(getPickerValueByDateTimePickerValue(dateTimePickerValue.value || start.value.valueOf()));
      var lastTimePicker = _toConsumableArray(pickerValue.value);
      var currentPicker = _toConsumableArray(pickerValue.value);
      var getDateTimePickerValueByPickerValue = function getDateTimePickerValueByPickerValue(value2) {
        var valueLength = 0;
        var date = dayjs();
        Object.keys(precisionRankRecord).forEach(function (item, index) {
          if (isPrecision(item)) {
            date = date[item](value2[valueLength]);
            valueLength++;
          }
        });
        return date;
      };
      var generateDatePickerColumns = function generateDatePickerColumns(selected, min, max, renderLabel2) {
        var ret = [];
        var minYear = min.year();
        var minMonth = min.month() + 1;
        var minDay = min.date();
        var minHour = min.hour();
        var minMinute = min.minute();
        var minSecond = min.second();
        var maxYear = max.year();
        var maxMonth = max.month() + 1;
        var maxDay = max.date();
        var maxHour = max.hour();
        var maxMinute = max.minute();
        var maxSecond = max.second();
        var selectedDate = {};
        var selectedLength = 0;
        Object.keys(precisionRankRecord).forEach(function (item) {
          var newKey = "selected".concat(item.substr(0, 1).toUpperCase()).concat(item.substr(1, item.length));
          if (isPrecision(item)) {
            selectedDate[newKey] = parseInt("".concat(selected[selectedLength]), 10);
            selectedLength++;
          } else {
            selectedDate[newKey] = void 0;
          }
        });
        var isInMinYear = selectedDate.selectedYear === minYear;
        var isInMaxYear = selectedDate.selectedYear === maxYear;
        var isInMinMonth = isInMinYear && selectedDate.selectedMonth + 1 === minMonth;
        var isInMaxMonth = isInMaxYear && selectedDate.selectedMonth + 1 === maxMonth;
        var isInMinDay = isInMinMonth && selectedDate.selectedDay === minDay;
        var isInMaxDay = isInMaxMonth && selectedDate.selectedDay === maxDay;
        var isInMinHour = isInMinDay && selectedDate.selectedHour === minHour;
        var isInMaxHour = isInMaxDay && selectedDate.selectedHour === maxHour;
        var isInMinMinute = isInMinHour && selectedDate.selectedMinute === minMinute;
        var isInMaxMinute = isInMaxHour && selectedDate.selectedMinute === maxMinute;
        var generateColumn = function generateColumn(start2, end2, type) {
          var arr = [];
          for (var i = start2; i <= end2; i++) {
            var value2 = i.toString();
            arr.push({
              label: renderLabel2 ? renderLabel2(type, i) : value2,
              value: type === "month" ? "".concat(+value2 - 1) : value2
            });
          }
          ret.push(arr);
        };
        if (isPrecision("year")) {
          generateColumn(minYear, maxYear, "year");
        }
        if (isPrecision("month")) {
          var lower = isInMinYear ? minMonth : 1;
          var upper = isInMaxYear ? maxMonth : 12;
          generateColumn(lower, upper, "month");
        }
        if (isPrecision("date")) {
          var _lower = isInMinMonth ? minDay : 1;
          var _upper = isInMaxMonth ? maxDay : dayjs("".concat(selected[0], "-").concat(+selected[1] + 1)).daysInMonth();
          generateColumn(_lower, _upper, "date");
        }
        if (isPrecision("hour")) {
          var _lower2 = isInMinDay ? minHour : 0;
          var _upper2 = isInMaxDay ? maxHour : 23;
          generateColumn(_lower2, _upper2, "hour");
        }
        if (isPrecision("minute")) {
          var _lower3 = isInMinHour ? minMinute : 0;
          var _upper3 = isInMaxHour ? maxMinute : 59;
          generateColumn(_lower3, _upper3, "minute");
        }
        if (isPrecision("second")) {
          var _lower4 = isInMinMinute ? minSecond : 0;
          var _upper4 = isInMaxMinute ? maxSecond : 59;
          generateColumn(_lower4, _upper4, "second");
        }
        return ret;
      };
      var onConfirm = function onConfirm(value2, context2) {
        lastTimePicker = _toConsumableArray(currentPicker);
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        emitEvent("confirm", dayjs(currentDate).format(props.format));
      };
      var onCancel = function onCancel(context2) {
        currentPicker = _toConsumableArray(lastTimePicker);
        emitEvent("cancel", {
          e: context2.e
        });
      };
      var onChange = function onChange(value2, context2) {
        lastTimePicker = _toConsumableArray(currentPicker);
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        realDateValue.value = dayjs(currentDate).format(props.format);
        isChanged.value = true;
      };
      var onPick = function onPick(value2, context2) {
        currentPicker = value2;
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        emitEvent("pick", dayjs(currentDate).format(props.format));
      };
      vue.watch(function () {
        return dateTimePickerValue;
      }, function (val) {
        vue.nextTick(function () {
          if (isChanged.value) {
            isChanged.value = false;
          } else {
            var _pickeInstance$value;
            (_pickeInstance$value = pickeInstance.value) === null || _pickeInstance$value === void 0 ? void 0 : _pickeInstance$value.setValues(getPickerValueByDateTimePickerValue(val.value || start.value.valueOf()));
            currentPicker = _toConsumableArray(vue.ref(getPickerValueByDateTimePickerValue(val.value || start.value.valueOf())).value);
            lastTimePicker = _toConsumableArray(currentPicker);
            isChanged.value = false;
          }
        });
      }, {
        immediate: true,
        deep: true
      });
      vue.watch(function () {
        return isChanged;
      }, function (val) {
        if (val.value) {
          setDateTimePickerValue(realDateValue.value);
        }
      }, {
        immediate: true,
        deep: true
      });
      return {
        pickeInstance: pickeInstance,
        className: className,
        confirmButtonText: confirmButtonText,
        cancelButtonText: cancelButtonText,
        title: title,
        start: start,
        end: end,
        renderLabel: renderLabel,
        pickerValue: pickerValue,
        currentPicker: currentPicker,
        realDateValue: realDateValue,
        isChanged: isChanged,
        generateDatePickerColumns: generateDatePickerColumns,
        onConfirm: onConfirm,
        onCancel: onCancel,
        onPick: onPick,
        onChange: onChange
      };
    }
  });

  function render$A(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_picker = vue.resolveComponent("t-picker");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createVNode(_component_t_picker, {
      ref: "pickeInstance",
      value: _ctx.currentPicker,
      title: _ctx.title,
      columns: function columns(selected) {
        return _ctx.generateDatePickerColumns(selected, _ctx.start, _ctx.end, _ctx.renderLabel);
      },
      onChange: _ctx.onChange,
      onConfirm: _ctx.onConfirm,
      onCancel: _ctx.onCancel,
      onPick: _ctx.onPick
    }, null, 8, ["value", "title", "columns", "onChange", "onConfirm", "onCancel", "onPick"])], 2);
  }

  script$B.render = render$A;

  var _DateTimePicker = withInstall(script$B);

  var ToastProps = {
    direction: {
      type: String,
      default: "row",
      validator: function validator(val) {
        if (!val) return true;
        return ["row", "column"].includes(val);
      }
    },
    duration: {
      type: Number,
      default: 2e3
    },
    icon: {
      type: [String, Function]
    },
    message: {
      type: [String, Function]
    },
    overlayProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    placement: {
      type: String,
      default: "middle",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "middle", "bottom"].includes(val);
      }
    },
    preventScrollThrough: Boolean,
    showOverlay: Boolean,
    theme: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["loading", "success", "fail"].includes(val);
      }
    }
  };

  function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$n(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$x = config.prefix;
  var name$v = "".concat(prefix$x, "-toast");
  var script$A = vue.defineComponent({
    name: name$v,
    components: {
      TOverlay: Overlay,
      TNode: TNodeComponent
    },
    props: ToastProps,
    setup: function setup(props) {
      var toastTypeIcon = {
        loading: loading,
        success: checkCircle,
        fail: errorCircle
      };
      var internalInstance = vue.getCurrentInstance();
      var messageContent = vue.computed(function () {
        return renderTNode(internalInstance, "message");
      });
      var iconContent = vue.computed(function () {
        var iconNode = renderTNode(internalInstance, "icon");
        if (iconNode === void 0 && props.theme) {
          iconNode = vue.h(toastTypeIcon[props.theme]);
        }
        return iconNode;
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$v), (_ref = {}, _defineProperty$2(_ref, "".concat(name$v, "--").concat(props.direction), props.direction), _defineProperty$2(_ref, "".concat(name$v, "--text"), !iconContent.value), _defineProperty$2(_ref, "".concat(name$v, "--icononly"), !messageContent.value && iconContent.value), _defineProperty$2(_ref, "".concat(name$v, "--top"), props.placement === "top"), _defineProperty$2(_ref, "".concat(name$v, "--middle"), props.placement === "middle"), _defineProperty$2(_ref, "".concat(name$v, "--bottom"), props.placement === "bottom"), _ref)];
      });
      var customOverlayProps = vue.computed(function () {
        var toastOverlayProps = {
          preventScrollThrough: props.preventScrollThrough,
          visible: props.showOverlay
        };
        return _objectSpread$n(_objectSpread$n({}, props.overlayProps), toastOverlayProps);
      });
      return _objectSpread$n({
        name: vue.ref(name$v),
        classes: classes,
        iconContent: iconContent,
        messageContent: messageContent,
        customOverlayProps: customOverlayProps
      }, vue.toRefs(props));
    }
  });

  function render$z(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_t_overlay, vue.normalizeProps(vue.guardReactiveProps(_ctx.customOverlayProps)), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"]), _ctx.messageContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.messageContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)]);
  }

  script$A.render = render$z;

  function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$m(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var instance = null;
  var app;
  function Toast(props) {
    var root = document.createElement("div");
    document.body.appendChild(root);
    var propsObject = _objectSpread$m({
      duration: 2e3
    }, parseOptions(props));
    if (instance) {
      instance.clear();
    }
    instance = script$A;
    instance.clear = function () {
      clearTimeout(instance.timer);
      app.unmount();
      root.remove();
    };
    if (propsObject.duration && propsObject.duration > 0) {
      instance.timer = setTimeout(instance.clear, propsObject.duration);
    }
    app = vue.createApp(instance, _objectSpread$m({}, propsObject));
    app.mount(root);
    return instance;
  }
  Toast.clear = function () {
    if (instance) {
      instance.clear();
    }
  };
  ["loading", "success", "fail"].forEach(function (type) {
    if (!type) {
      return;
    }
    Toast[type] = function (options) {
      var props = {
        message: "",
        theme: type
      };
      if (typeof options === "string") {
        props.message = options;
      } else {
        props = _objectSpread$m(_objectSpread$m({}, props), options);
      }
      return Toast(props);
    };
  });
  function parseOptions(message) {
    if (typeof message === "string") {
      return {
        message: message
      };
    }
    return message;
  }
  Toast.install = function (app2) {
    app2.config.globalProperties.$toast = Toast;
  };
  var ToastPlugin = Toast;

  var searchProps = {
    action: {
      type: [String, Function],
      default: ""
    },
    center: Boolean,
    clearable: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    focus: Boolean,
    label: {
      type: String,
      default: ""
    },
    leftIcon: {
      type: Function
    },
    placeholder: {
      type: String,
      default: ""
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        if (!val) return true;
        return ["square", "round"].includes(val);
      }
    },
    value: {
      type: String
    },
    modelValue: {
      type: String
    },
    defaultValue: {
      type: String
    },
    onActionClick: Function,
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onFocus: Function,
    onSubmit: Function
  };

  function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$l(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$w = config.prefix;
  var name$u = "".concat(prefix$w, "-search");
  var script$z = vue.defineComponent({
    name: name$u,
    components: {
      TIconSearch: search,
      TIconClear: closeCircleFilled,
      TButton: _Button,
      TInput: _Input
    },
    props: searchProps,
    setup: function setup(props, _ref) {
      var emit = _ref.emit;
      var classes = vue.computed(function () {
        var _ref2;
        return _ref2 = {}, _defineProperty$2(_ref2, "".concat(name$u), true), _defineProperty$2(_ref2, "".concat(prefix$w, "-is-focused"), !state.labelActive), _ref2;
      });
      var _useDefault = useDefault(props, emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        value = _useDefault2[0];
      var shapeStyle = vue.computed(function () {
        return {
          borderRadius: props.shape === "square" ? void 0 : "50px"
        };
      });
      var searchInput = vue.ref();
      var state = vue.reactive({
        labelActive: !value.value,
        inputVal: ""
      });
      var doFocus = function doFocus() {
        var _searchInput$value;
        (_searchInput$value = searchInput.value) === null || _searchInput$value === void 0 ? void 0 : _searchInput$value.focus();
      };
      var onBlur = function onBlur(value2, context) {
        var _props$onBlur;
        state.labelActive = !value2;
        (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props, value2, {
          e: context.e
        });
      };
      var onClick = function onClick() {
        state.labelActive = !state.labelActive;
        doFocus();
      };
      var onFocus = function onFocus(value2, context) {
        var _props$onFocus;
        state.labelActive = false;
        (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, value2, {
          e: context.e
        });
      };
      var onClear = function onClear(e) {
        var _props$onClear;
        searchInput.value.innerValue = "";
        (_props$onClear = props.onClear) === null || _props$onClear === void 0 ? void 0 : _props$onClear.call(props, {
          e: e
        });
      };
      var onCancel = function onCancel(e) {
        var _props$onActionClick;
        state.labelActive = !state.labelActive;
        (_props$onActionClick = props.onActionClick) === null || _props$onActionClick === void 0 ? void 0 : _props$onActionClick.call(props, {
          e: e
        });
      };
      var onChange = function onChange(value2, context) {
        var _props$onChange;
        (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, value2, {
          e: context === null || context === void 0 ? void 0 : context.e
        });
      };
      extendAPI({
        doFocus: doFocus,
        blur: blur
      });
      return _objectSpread$l(_objectSpread$l({}, vue.toRefs(props)), {}, {
        name: vue.ref(name$u),
        classes: classes,
        shapeStyle: shapeStyle,
        onClick: onClick,
        onCancel: onCancel,
        onBlur: onBlur,
        onFocus: onFocus,
        onClear: onClear,
        onChange: onChange,
        state: state,
        value: value,
        searchInput: searchInput
      });
    }
  });

  function render$y(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_icon_search = vue.resolveComponent("t-icon-search");
    var _component_t_input = vue.resolveComponent("t-input");
    var _component_t_icon_clear = vue.resolveComponent("t-icon-clear");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__form")),
      style: vue.normalizeStyle(_ctx.shapeStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__box"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-search"))
    }, [vue.renderSlot(_ctx.$slots, "leftIcon", {}, function () {
      return [vue.createVNode(_component_t_icon_search)];
    })], 2), vue.createVNode(_component_t_input, {
      ref: "searchInput",
      modelValue: _ctx.value,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
        return _ctx.value = $event;
      }),
      type: "search",
      class: vue.normalizeClass("".concat(_ctx.name, "__input")),
      autofocus: _ctx.focus,
      placeholder: _ctx.placeholder,
      onBlur: _ctx.onBlur,
      onFocus: _ctx.onFocus,
      onChange: _ctx.onChange
    }, null, 8, ["modelValue", "class", "autofocus", "placeholder", "onBlur", "onFocus", "onChange"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-close"))
    }, [vue.createVNode(_component_t_icon_clear, {
      onClick: _ctx.onClear
    }, null, 8, ["onClick"])], 2)], 2), vue.withDirectives(vue.createElementVNode("label", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label")),
      style: vue.normalizeStyle(_ctx.shapeStyle),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label-icon-search"))
    }, [vue.renderSlot(_ctx.$slots, "leftIcon", {}, function () {
      return [vue.createVNode(_component_t_icon_search)];
    })], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label-text"))
    }, vue.toDisplayString(_ctx.placeholder), 3)], 6), [[vue.vShow, _ctx.state.labelActive]])], 6), vue.renderSlot(_ctx.$slots, "action", {}, function () {
      return [_ctx.action ? vue.withDirectives((vue.openBlock(), vue.createBlock(_component_t_button, {
        key: 0,
        variant: "text",
        class: vue.normalizeClass("".concat(_ctx.name, "__cancel-button")),
        onClick: _ctx.onCancel
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(_ctx.action), 1)];
        }),
        _: 1
      }, 8, ["class", "onClick"])), [[vue.vShow, !_ctx.state.labelActive]]) : vue.createCommentVNode("", true)];
    })], 2);
  }

  script$z.render = render$y;

  var _Search = withInstall(script$z);

  var StepsProps = {
    current: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultCurrent: {
      type: [String, Number],
      default: 0
    },
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        return ["horizontal", "vertical"].includes(val);
      }
    },
    options: {
      type: Array
    },
    readonly: Boolean,
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "dot"].includes(val);
      }
    },
    onChange: Function
  };

  var StepItemProps = {
    content: {
      type: [String, Function],
      default: ""
    },
    icon: {
      type: [Boolean, Function],
      default: true
    },
    status: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "process", "finish", "error"].includes(val);
      }
    },
    title: {
      type: [String, Function],
      default: ""
    }
  };

  var prefix$v = config.prefix;
  var name$t = "".concat(prefix$v, "-step");
  var script$y = vue.defineComponent({
    name: name$t,
    components: {
      TNode: TNodeComponent
    },
    props: StepItemProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var proxy = internalInstance.proxy;
      var stepsProvide = vue.inject("stepsProvide", void 0);
      stepsProvide.relation(proxy);
      var index = vue.computed(function () {
        return stepsProvide.state.children.indexOf(proxy);
      });
      var theme = vue.computed(function () {
        return stepsProvide.theme;
      });
      var dot = vue.computed(function () {
        return theme.value === "dot" && stepsProvide.layout === "vertical";
      });
      var iconNode = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var iconContent = vue.computed(function () {
        if (dot.value) {
          return "";
        }
        if (props.status === "error") {
          return vue.h(close);
        }
        if (index.value < current.value && readonly.value) {
          return vue.h(check);
        }
        if (typeof iconNode.value === "boolean") {
          return iconNode.value ? index.value + 1 : "";
        }
        return iconNode.value;
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var extraContent = vue.computed(function () {
        return renderTNode(internalInstance, "extra");
      });
      var current = vue.computed(function () {
        return stepsProvide.current.value || stepsProvide.defaultCurrent || 0;
      });
      var stepsStatus = vue.computed(function () {
        return stepsProvide.status;
      });
      var readonly = vue.computed(function () {
        return stepsProvide.readonly;
      });
      var rootClassName = vue.computed(function () {
        return [name$t, _defineProperty$2({}, "".concat(name$t, "--default"), !readonly.value), _defineProperty$2({}, "".concat(name$t, "--").concat(currentStatus.value), currentStatus.value)];
      });
      var innerClassName = vue.computed(function () {
        if (typeof iconNode.value === "boolean") {
          return ["".concat(name$t, "__inner")];
        }
        return ["".concat(name$t, "__inner"), "".concat(name$t, "__inner__icon")];
      });
      var iconClassName = vue.computed(function () {
        return ["".concat(name$t, "-icon__number"), _defineProperty$2({}, "".concat(name$t, "-icon__dot"), dot.value)];
      });
      var currentStatus = vue.computed(function () {
        var status = props.status;
        if (status !== "default") return status;
        if (index.value < current.value) return "finish";
        if (index.value === current.value) return "process";
        return "";
      });
      var onClickIcon = function onClickIcon(e) {
        if (!readonly.value && !dot.value) {
          stepsProvide.onClickItem(index.value, current.value, e);
        }
      };
      return {
        dot: dot,
        name: name$t,
        theme: theme,
        index: index,
        current: current,
        readonly: readonly,
        iconNode: iconNode,
        stepsStatus: stepsStatus,
        descContent: descContent,
        iconContent: iconContent,
        onClickIcon: onClickIcon,
        titleContent: titleContent,
        extraContent: extraContent,
        rootClassName: rootClassName,
        currentStatus: currentStatus,
        iconClassName: iconClassName,
        innerClassName: innerClassName
      };
    }
  });

  function render$x(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClassName)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.innerClassName),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickIcon && _ctx.onClickIcon.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-icon"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClassName)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-content"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-extra"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.extraContent
    }, null, 8, ["content"])], 2)], 2)], 2)], 2);
  }

  script$y.render = render$x;

  function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$k(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$u = config.prefix;
  var name$s = "".concat(prefix$u, "-steps");
  var script$x = vue.defineComponent({
    name: name$s,
    components: {
      TStepItem: script$y
    },
    props: StepsProps,
    emits: ["update:current", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var baseClass = vue.computed(function () {
        return [name$s, "".concat(name$s, "--").concat(props.layout), _defineProperty$2({}, "".concat(name$s, "--readonly"), props.readonly), "".concat(name$s, "--").concat(props.theme, "-anchor")];
      });
      var _useDefault = useDefault(props, context.emit, "current", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        current = _useDefault2[0],
        setCurrent = _useDefault2[1];
      var state = vue.reactive({
        children: []
      });
      var relation = function relation(child) {
        child && state.children.push(child);
      };
      var onClickItem = function onClickItem(cur, prev, e) {
        setCurrent(cur, prev, {
          e: e
        });
      };
      vue.provide("stepsProvide", _objectSpread$k(_objectSpread$k({}, props), {}, {
        state: state,
        current: current,
        relation: relation,
        onClickItem: onClickItem
      }));
      return _objectSpread$k({
        baseClass: baseClass,
        onClickItem: onClickItem
      }, vue.toRefs(props));
    }
  });

  function render$w(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_step_item = vue.resolveComponent("t-step-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.baseClass)
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (item, index) {
        return vue.openBlock(), vue.createBlock(_component_t_step_item, {
          key: index,
          title: item.title,
          content: item.content,
          icon: item.icon,
          status: item.status
        }, null, 8, ["title", "content", "icon", "status"]);
      }), 128))];
    })], 2);
  }

  script$x.render = render$w;

  var Step = withInstall(script$y);
  var Steps = withInstall(script$x);

  var IndexesProps = {
    height: {
      type: Number
    },
    list: {
      type: Array,
      default: function _default() {
        return [];
      },
      required: true
    },
    sticky: {
      type: Boolean,
      default: true
    },
    onSelect: Function
  };

  var name$r = "".concat(config.prefix, "-indexes-anchor");
  var script$w = vue.defineComponent({
    name: name$r,
    components: {
      TNode: TNodeComponent
    },
    props: {
      anchorStyle: {
        type: String,
        default: ""
      }
    },
    setup: function setup(props, context) {
      var boxClasses = name$r;
      var stickyContent = vue.computed(function () {
        return renderContent(vue.getCurrentInstance(), "default", "");
      });
      templateRef("boxRef");
      var contentRef = templateRef("contentRef");
      var _useElementBounding = useElementBounding(contentRef),
        height = _useElementBounding.height;
      var boxStyles = vue.computed(function () {
        return "height:".concat(height.value, "px;");
      });
      return {
        boxClasses: boxClasses,
        boxStyles: boxStyles,
        stickyContent: stickyContent
      };
    }
  });

  function render$v(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "boxRef",
      class: vue.normalizeClass(_ctx.boxClasses),
      style: vue.normalizeStyle(_ctx.boxStyles)
    }, [vue.createElementVNode("div", {
      ref: "contentRef",
      class: "t-indexes__anchor",
      style: vue.normalizeStyle(_ctx.anchorStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.stickyContent
    }, null, 8, ["content"])], 4)], 6);
  }

  script$w.render = render$v;

  function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$j(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$t = config.prefix;
  var componentName$2 = "".concat(prefix$t, "-indexes");
  var script$v = vue.defineComponent({
    name: componentName$2,
    components: {
      indexesAnchor: script$w
    },
    props: IndexesProps,
    emits: ["select"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var timeOut;
      var indexesRoot = vue.ref(null);
      var state = vue.reactive({
        componentName: componentName$2,
        list: props.list,
        showSidebarTip: false,
        activeSidebar: "",
        activeIndex: -1
      });
      var anchorGroup = vue.ref([]);
      var setAnchorGroupRefs = function setAnchorGroupRefs(index) {
        return function (el) {
          anchorGroup.value[index] = el;
        };
      };
      var anchor = vue.ref([]);
      var anchorStyle = vue.reactive([]);
      var setAnchorRefs = function setAnchorRefs(index) {
        return function (el) {
          anchor.value[index] = el;
        };
      };
      var indexesRootStyle = vue.computed(function () {
        if (typeof props.height !== "number") {
          return {};
        }
        var height = Number(props.height);
        return {
          height: height === 0 ? 0 : "".concat(height, "px")
        };
      });
      var scrollToView = function scrollToView() {
        var _targets$;
        var children = anchorGroup.value;
        var targets = children.filter(function (ele) {
          var dataset = ele.dataset;
          return dataset && dataset.index === state.activeSidebar;
        });
        (_targets$ = targets[0]) === null || _targets$ === void 0 ? void 0 : _targets$.scrollIntoView();
      };
      var calcSticky = function calcSticky(indexesRootTop) {
        var children = anchorGroup.value;
        for (var i = 0; i < children.length; i++) {
          var _anchor$value, _anchor$value$$el$get;
          var _children$i$getBoundi = children[i].getBoundingClientRect(),
            childTop = _children$i$getBoundi.top,
            width = _children$i$getBoundi.width;
          anchorStyle[i] = "z-index: ".concat(i + 1, ";");
          if (childTop < indexesRootTop && i === state.activeIndex) {
            anchorStyle[i] += "position:fixed;top:".concat(indexesRootTop, "px;width: ").concat(width, "px;");
          } else {
            anchorStyle[i] += "";
          }
          var anchorHeight = (_anchor$value = anchor.value[i - 1]) === null || _anchor$value === void 0 ? void 0 : (_anchor$value$$el$get = _anchor$value.$el.getBoundingClientRect()) === null || _anchor$value$$el$get === void 0 ? void 0 : _anchor$value$$el$get.height;
          var diff = childTop - indexesRootTop - anchorHeight;
          if (i - 1 === state.activeIndex && diff < 0) {
            anchorStyle[i - 1] += "transform: translateY(".concat(diff, "px)");
          }
        }
      };
      var calcChildPosition = function calcChildPosition(scrollTop) {
        var _children$currentInde;
        var children = anchorGroup.value;
        var currentIndex = -1;
        for (var i = 0; i < children.length - 1; i++) {
          if (scrollTop < children[i + 1].offsetTop) {
            currentIndex = i;
            break;
          }
        }
        if (scrollTop >= children[children.length - 1].offsetTop) {
          currentIndex = children.length - 1;
        }
        state.activeIndex = currentIndex;
        state.activeSidebar = (_children$currentInde = children[currentIndex].dataset.index) !== null && _children$currentInde !== void 0 ? _children$currentInde : "";
      };
      var setActiveSidebarAndTip = function setActiveSidebarAndTip(index) {
        state.activeSidebar = index;
        state.showSidebarTip = true;
      };
      vue.watchEffect(function () {
        if (state.showSidebarTip) {
          clearSidebarTip();
        }
      });
      var handleSidebarItemClick = function handleSidebarItemClick(index) {
        setActiveSidebarAndTip(index);
        scrollToView();
      };
      var handleSidebarTouchstart = function handleSidebarTouchstart(event) {
        event.stopPropagation();
        var touches = event.touches;
        touches[0].clientX;
        touches[0].clientX;
      };
      var handleSidebarTouchmove = function handleSidebarTouchmove(event) {
        event.preventDefault();
        var touches = event.touches;
        var _touches$ = touches[0],
          clientX = _touches$.clientX,
          clientY = _touches$.clientY;
        var target = document.elementFromPoint(clientX, clientY);
        if (target && target.className === "".concat(componentName$2, "__sidebar-item") && target instanceof HTMLElement) {
          var index = target.dataset.index;
          if (index !== void 0 && state.activeSidebar !== index) {
            setActiveSidebarAndTip(index);
            scrollToView();
          }
        }
      };
      var handleRootScroll = function handleRootScroll(event) {
        if (indexesRoot.value) {
          calcChildPosition(indexesRoot.value.scrollTop);
          if (props.sticky) {
            var _indexesRoot$value$ge, _indexesRoot$value, _indexesRoot$value$ge2;
            var indexesRootTop = (_indexesRoot$value$ge = (_indexesRoot$value = indexesRoot.value) === null || _indexesRoot$value === void 0 ? void 0 : (_indexesRoot$value$ge2 = _indexesRoot$value.getBoundingClientRect()) === null || _indexesRoot$value$ge2 === void 0 ? void 0 : _indexesRoot$value$ge2.top) !== null && _indexesRoot$value$ge !== void 0 ? _indexesRoot$value$ge : 0;
            calcSticky(indexesRootTop);
          }
        }
      };
      var clearSidebarTip = function clearSidebarTip() {
        if (state.showSidebarTip && state.activeSidebar) {
          timeOut && clearTimeout(timeOut);
          timeOut = window.setTimeout(function () {
            state.showSidebarTip = false;
          }, 1e3);
        }
      };
      var handleCellClick = function handleCellClick(indexes) {
        emitEvent("select", indexes);
      };
      vue.onMounted(function () {
        var children = anchorGroup.value;
        if (children.length > 0) {
          var index = children[0].dataset.index;
          if (index !== void 0) {
            state.activeSidebar = index;
          }
        }
      });
      vue.onBeforeUnmount(function () {
        timeOut && clearTimeout(timeOut);
      });
      return _objectSpread$j(_objectSpread$j({}, vue.toRefs(state)), {}, {
        indexesRoot: indexesRoot,
        indexesRootStyle: indexesRootStyle,
        anchorGroup: anchorGroup,
        anchorStyle: anchorStyle,
        setAnchorGroupRefs: setAnchorGroupRefs,
        setAnchorRefs: setAnchorRefs,
        handleSidebarItemClick: handleSidebarItemClick,
        handleSidebarTouchmove: handleSidebarTouchmove,
        handleSidebarTouchstart: handleSidebarTouchstart,
        handleRootScroll: handleRootScroll,
        handleCellClick: handleCellClick
      });
    }
  });

  var _hoisted_1$c = ["data-index", "onClick"];
  var _hoisted_2$5 = ["data-index"];
  function render$u(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_indexes_anchor = vue.resolveComponent("indexes-anchor");
    var _component_t_indexes_cell = vue.resolveComponent("t-indexes-cell");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "indexesRoot",
      style: vue.normalizeStyle(_ctx.indexesRootStyle),
      class: vue.normalizeClass(_ctx.componentName),
      onScroll: _cache[2] || (_cache[2] = function () {
        return _ctx.handleRootScroll && _ctx.handleRootScroll.apply(_ctx, arguments);
      })
    }, [_ctx.list.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar")),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.handleSidebarTouchstart && _ctx.handleSidebarTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.handleSidebarTouchmove && _ctx.handleSidebarTouchmove.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.list, function (item) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: item.index,
        class: vue.normalizeClass(["".concat(_ctx.componentName, "__sidebar-item"), _ctx.activeSidebar === item.index ? "".concat(_ctx.componentName, "__sidebar-item--active") : ""]),
        "data-index": item.index,
        onClick: vue.withModifiers(function ($event) {
          return _ctx.handleSidebarItemClick(item.index);
        }, ["prevent"])
      }, [vue.createTextVNode(vue.toDisplayString(item.index) + " ", 1), _ctx.showSidebarTip && _ctx.activeSidebar === item.index ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar-tip"))
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar-tip-text"))
      }, vue.toDisplayString(_ctx.activeSidebar), 3)], 2)) : vue.createCommentVNode("", true)], 10, _hoisted_1$c);
    }), 128))], 34)) : vue.createCommentVNode("", true), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.list, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        ref_for: true,
        ref: _ctx.setAnchorGroupRefs(index),
        key: item.index,
        "data-index": item.index
      }, [vue.createVNode(_component_indexes_anchor, {
        ref_for: true,
        ref: _ctx.setAnchorRefs(index),
        "anchor-style": _ctx.anchorStyle[index]
      }, {
        default: vue.withCtx(function () {
          var _item$title;
          return [vue.createTextVNode(vue.toDisplayString((_item$title = item.title) !== null && _item$title !== void 0 ? _item$title : item.index), 1)];
        }),
        _: 2
      }, 1032, ["anchor-style"]), vue.createElementVNode("div", {
        class: vue.normalizeClass(["".concat(_ctx.componentName, "__group")])
      }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.children, function (child, childrenIndex) {
        return vue.openBlock(), vue.createBlock(_component_t_indexes_cell, {
          key: child.title,
          value: String(child.title),
          title: child.title,
          link: true,
          bordered: false,
          onClick: function onClick($event) {
            return _ctx.handleCellClick({
              groupIndex: item.index,
              childrenIndex: childrenIndex
            });
          }
        }, null, 8, ["value", "title", "onClick"]);
      }), 128))], 2)], 8, _hoisted_2$5);
    }), 128))], 38);
  }

  script$v.render = render$u;

  var prefix$s = config.prefix;
  var componentName$1 = "".concat(prefix$s, "-indexes-cell");
  var script$u = vue.defineComponent({
    name: componentName$1,
    components: {
      TCell: _Cell
    },
    props: {
      title: {
        type: String,
        default: ""
      },
      key: {
        type: String,
        default: ""
      },
      value: {
        type: String,
        default: ""
      },
      link: {
        type: Boolean,
        default: false
      }
    },
    setup: function setup(props, context) {
      var currentSidebar = "";
      var state = vue.reactive({
        title: props.title,
        value: props.value,
        link: props.link,
        key: props.key,
        componentName: componentName$1
      });
      return {
        state: state,
        currentSidebar: currentSidebar
      };
    }
  });

  function render$t(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_cell = vue.resolveComponent("t-cell");
    return vue.openBlock(), vue.createBlock(_component_t_cell, {
      class: vue.normalizeClass(_ctx.state.componentName),
      "data-key": _ctx.state.key,
      title: _ctx.state.title,
      value: _ctx.state.value,
      link: _ctx.state.link
    }, null, 8, ["class", "data-key", "title", "value", "link"]);
  }

  script$u.render = render$t;

  var Indexes = withInstall(script$v);
  var IndexesCell = withInstall(script$u);

  var TagProps = {
    closable: Boolean,
    content: {
      type: [String, Number, Function]
    },
    disabled: Boolean,
    icon: {
      type: Function,
      default: void 0
    },
    maxWidth: {
      type: [String, Number]
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        return ["square", "round", "mark"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        return ["small", "medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "primary", "warning", "danger", "success"].includes(val);
      }
    },
    variant: {
      type: String,
      default: "dark",
      validator: function validator(val) {
        return ["dark", "light", "outline", "light-outline"].includes(val);
      }
    },
    onClick: Function,
    onClose: Function
  };

  var prefix$r = config.prefix;
  var name$q = "".concat(prefix$r, "-tag");
  var Tag$1 = vue.defineComponent({
    name: name$q,
    components: {
      CloseIcon: close,
      TNode: TNodeComponent
    },
    props: TagProps,
    emits: ["close", "click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var tagContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var baseClass = name$q;
      var tagStyle = vue.computed(function () {
        return props.maxWidth ? {
          maxWidth: typeof props.maxWidth === "number" ? "".concat(props.maxWidth, "px") : props.maxWidth
        } : {};
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(baseClass), "".concat(baseClass, "--theme-").concat(props.theme), "".concat(baseClass, "--shape-").concat(props.shape), "".concat(baseClass, "--variant-").concat(props.variant), "".concat(baseClass, "--size-").concat(props.size), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$r, "-is-closable ").concat(baseClass, "--closable"), props.closable), _defineProperty$2(_ref, "".concat(prefix$r, "-is-disabled ").concat(baseClass, "--disabled"), props.disabled), _ref)];
      });
      var onClickClose = function onClickClose(e) {
        if (!props.disabled) {
          emitEvent("close", {
            e: e
          });
        }
      };
      var handleClick = function handleClick(e) {
        if (!props.disabled) {
          emitEvent("click", {
            e: e
          });
        }
      };
      return {
        baseClass: baseClass,
        classes: classes,
        tagStyle: tagStyle,
        onClickClose: onClickClose,
        handleClick: handleClick,
        iconContent: iconContent,
        tagContent: tagContent
      };
    }
  });
  var script$t = Tag$1;

  var _hoisted_1$b = ["aria-disabled"];
  function render$s(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes),
      style: vue.normalizeStyle(_ctx.tagStyle),
      "aria-disabled": _ctx.disabled,
      role: "button",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.tagContent
    }, null, 8, ["content"])], 2), _ctx.closable && !_ctx.disabled ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon-close")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickClose && _ctx.onClickClose.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_close_icon)], 2)) : vue.createCommentVNode("", true)], 14, _hoisted_1$b);
  }

  script$t.render = render$s;

  var CheckTagProps = {
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    closable: Boolean,
    content: {
      type: [String, Number, Function]
    },
    disabled: Boolean,
    icon: {
      type: Function
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        return ["square", "round", "mark"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        return ["small", "medium", "large"].includes(val);
      }
    },
    onChange: Function,
    onClick: Function
  };

  var prefix$q = config.prefix;
  var name$p = "".concat(prefix$q, "-check-tag");
  var CheckTag$1 = vue.defineComponent({
    name: name$p,
    components: {
      CloseIcon: close,
      TNode: TNodeComponent
    },
    props: CheckTagProps,
    emits: ["change", "click", "update:checked", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var tagContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var baseClass = "".concat(prefix$q, "-tag");
      var _toRefs = vue.toRefs(props),
        checked = _toRefs.checked,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(checked, modelValue, props.defaultChecked, props.onChange, "checked"),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerChecked = _useVModel2[0],
        setInnerChecked = _useVModel2[1];
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(baseClass), "".concat(baseClass, "--checkable"), "".concat(baseClass, "--shape-").concat(props.shape), "".concat(baseClass, "--size-").concat(props.size), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$q, "-is-closable ").concat(baseClass, "--closable"), props.closable), _defineProperty$2(_ref, "".concat(prefix$q, "-is-disabled ").concat(baseClass, "--disabled"), props.disabled), _defineProperty$2(_ref, "".concat(prefix$q, "-is-checked ").concat(baseClass, "--checked"), !props.disabled && innerChecked.value), _ref)];
      });
      var onClickClose = function onClickClose(e) {
        if (!props.disabled) {
          emitEvent("close", {
            e: e
          });
        }
      };
      var handleClick = function handleClick(e) {
        if (!props.disabled) {
          emitEvent("click", {
            e: e
          });
          setInnerChecked(!innerChecked.value);
        }
      };
      return {
        baseClass: baseClass,
        classes: classes,
        onClickClose: onClickClose,
        handleClick: handleClick,
        iconContent: iconContent,
        tagContent: tagContent,
        innerChecked: innerChecked
      };
    }
  });
  var script$s = CheckTag$1;

  var _hoisted_1$a = ["aria-disabled"];
  function render$r(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes),
      "aria-disabled": _ctx.disabled,
      role: "button",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.tagContent
    }, null, 8, ["content"])], 2), _ctx.closable && !_ctx.disabled ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon-close")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickClose && _ctx.onClickClose.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_close_icon)], 2)) : vue.createCommentVNode("", true)], 10, _hoisted_1$a);
  }

  script$s.render = render$r;

  var Tag = withInstall(script$t);
  var CheckTag = withInstall(script$s);

  var TabBarProps = {
    bordered: {
      type: Boolean,
      default: true
    },
    fixed: {
      type: Boolean,
      default: true
    },
    value: {
      type: [String, Number, Array],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Array],
      default: void 0
    },
    onChange: Function
  };

  var prefix$p = config.prefix;
  var name$o = "".concat(prefix$p, "-tab-bar");
  var script$r = vue.defineComponent({
    name: name$o,
    props: TabBarProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        activeValue = _useDefault2[0];
      var defaultIndex = vue.ref(-1);
      var updateChild = function updateChild(currentValue) {
        activeValue.value = currentValue;
      };
      var tabbarClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$o), (_ref = {}, _defineProperty$2(_ref, "".concat(name$o, "--bordered"), props.bordered), _defineProperty$2(_ref, "".concat(name$o, "--fixed"), props.fixed), _ref)];
      });
      vue.provide("tab-bar", {
        defaultIndex: defaultIndex,
        activeValue: activeValue,
        updateChild: updateChild
      });
      return {
        tabbarClass: tabbarClass
      };
    }
  });

  function render$q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.tabbarClass),
      role: "tablist"
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$r.render = render$q;

  var initName = function initName(defaultIndex) {
    var _instance$props;
    var index = defaultIndex;
    var instance = vue.getCurrentInstance();
    if (typeof (instance === null || instance === void 0 ? void 0 : (_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.value) !== "undefined") {
      var _instance$props2;
      return instance === null || instance === void 0 ? void 0 : (_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.value;
    }
    index.value += 1;
    return index.value;
  };

  var TabBarItemProps = {
    badgeProps: {
      type: Object
    },
    icon: {
      type: Function
    },
    subTabBar: {
      type: Array
    },
    value: {
      type: [String, Number]
    }
  };

  function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$i(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$o = config.prefix;
  var componentName = "".concat(prefix$o, "-tab-bar-item");
  var script$q = vue.defineComponent({
    name: componentName,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge
    },
    props: TabBarItemProps,
    setup: function setup(props) {
      var _inject = vue.inject("tab-bar"),
        defaultIndex = _inject.defaultIndex,
        activeValue = _inject.activeValue,
        updateChild = _inject.updateChild;
      var currentName = initName(defaultIndex);
      var hasSubTabBar = !!props.subTabBar;
      var isSpread = vue.ref(false);
      var isChecked = vue.computed(function () {
        if (hasSubTabBar && Array.isArray(activeValue.value)) {
          return activeValue.value.includes(currentName);
        }
        return currentName === activeValue.value;
      });
      vue.watch(isChecked, function (newValue) {
        if (!newValue) {
          isSpread.value = false;
        }
      });
      var isToggleCurrent = vue.computed(function () {
        return Array.isArray(activeValue.value) && activeValue.value[0] === currentName;
      });
      var toggle = function toggle() {
        if (hasSubTabBar) {
          isSpread.value = !isSpread.value;
          if (!isToggleCurrent.value) {
            updateChild([currentName]);
            return;
          }
        }
        updateChild(currentName);
      };
      var selectChild = function selectChild(childName) {
        if (!(Array.isArray(activeValue.value) && activeValue.value[1] === childName)) {
          updateChild([currentName, childName]);
        }
        isSpread.value = false;
      };
      var internalInstance = vue.getCurrentInstance();
      var itemContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      return _objectSpread$i(_objectSpread$i({}, vue.toRefs(props)), {}, {
        prefix: prefix$o,
        componentName: componentName,
        isChecked: isChecked,
        toggle: toggle,
        isSpread: isSpread,
        selectChild: selectChild,
        itemContent: itemContent,
        iconContent: iconContent
      });
    }
  });

  var _hoisted_1$9 = ["aria-selected", "aria-haspopup"];
  var _hoisted_2$4 = ["aria-label", "onClick"];
  function render$p(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "tab",
      "aria-label": "TabBar",
      "aria-selected": _ctx.isChecked,
      "aria-haspopup": _ctx.subTabBar && _ctx.subTabBar.length > 0,
      class: vue.normalizeClass([_ctx.componentName, _ctx.iconContent && "".concat(_ctx.prefix, "-no-border")])
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.componentName, "__content"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.prefix, "-is-checked"), _ctx.isChecked), _defineProperty$2(_normalizeClass2, "".concat(_ctx.componentName, "--onlytext"), !_ctx.iconContent), _normalizeClass2)),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.toggle && _ctx.toggle.apply(_ctx, arguments);
      })
    }, [_ctx.iconContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__icon"))
    }, [_ctx.badgeProps && (_ctx.badgeProps.dot || _ctx.badgeProps.count) ? (vue.openBlock(), vue.createBlock(_component_t_badge, {
      key: 0,
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount || 99,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset || [0, 5]
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.iconContent
        }, null, 8, ["content"])];
      }),
      _: 1
    }, 8, ["count", "max-count", "dot", "content", "size", "offset"])) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.iconContent
    }, null, 8, ["content"]))], 2)) : vue.createCommentVNode("", true), _ctx.itemContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__text"))
    }, [_ctx.subTabBar && _ctx.subTabBar.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__icon-menu"))
    }, null, 2)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.itemContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2), vue.createVNode(vue.Transition, {
      name: "spread"
    }, {
      default: vue.withCtx(function () {
        return [_ctx.subTabBar && _ctx.subTabBar.length > 0 && _ctx.isSpread ? (vue.openBlock(), vue.createElementBlock("ul", {
          key: 0,
          role: "menu",
          class: vue.normalizeClass("".concat(_ctx.componentName, "__spread"))
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.subTabBar, function (child, index) {
          return vue.openBlock(), vue.createElementBlock("li", {
            key: child.value || index,
            role: "menuitem",
            "aria-label": child.label,
            class: vue.normalizeClass("".concat(_ctx.componentName, "__spread-item")),
            onClick: function onClick($event) {
              return _ctx.selectChild(child.value || index);
            }
          }, vue.toDisplayString(child.label), 11, _hoisted_2$4);
        }), 128))], 2)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    })], 10, _hoisted_1$9);
  }

  script$q.render = render$p;

  var TabBar = withInstall(script$r);
  var TabBarItem = withInstall(script$q);

  var DropdownMenuExpandState = /* @__PURE__ */function (DropdownMenuExpandState2) {
    DropdownMenuExpandState2["expanded"] = "expanded";
    DropdownMenuExpandState2["collapsed"] = "collapsed";
    return DropdownMenuExpandState2;
  }(DropdownMenuExpandState || {});
  var oldOverflow = null;
  var context = {
    expandedMenuControl: null,
    recordMenuExpanded: function recordMenuExpanded(container, menuControl, action) {
      var containerDom = container;
      if (action === "expanded" /* expanded */) {
        var expandedMenuControl = this.expandedMenuControl;
        if (expandedMenuControl && expandedMenuControl !== menuControl) {
          expandedMenuControl.collapseMenu();
        }
        this.expandedMenuControl = menuControl;
        if (oldOverflow === null) {
          oldOverflow = container.style.overflow;
          containerDom.style.overflow = "hidden";
        }
      } else if (action === "collapsed" /* collapsed */) {
        if (this.expandedMenuControl === menuControl) {
          this.expandedMenuControl = null;
        }
        if (!this.expandedMenuControl && oldOverflow !== null) {
          containerDom.style.overflow = oldOverflow;
          oldOverflow = null;
        }
      }
    }
  };

  var TransAniControl = /*#__PURE__*/function () {
    function TransAniControl() {
      _classCallCheck(this, TransAniControl);
      _defineProperty$2(this, "timeout", void 0);
      _defineProperty$2(this, "finallyDo", void 0);
      this.timeout = null;
      this.finallyDo = NOOP;
    }
    _createClass(TransAniControl, [{
      key: "setTo",
      value: function setTo(duration, nowDo, nextTickDo, finallyDo) {
        var _this = this;
        if (this.timeout) {
          window.clearTimeout(this.timeout);
          this.finallyDo();
        }
        nowDo();
        vue.nextTick(function () {
          return window.setTimeout(nextTickDo, 0);
        });
        this.finallyDo = finallyDo;
        this.timeout = window.setTimeout(function () {
          _this.finallyDo();
          _this.finallyDo = NOOP;
          _this.timeout = 0;
        }, duration);
      }
    }]);
    return TransAniControl;
  }();

  var findRelativeContainer = function findRelativeContainer(dom) {
    var node = dom;
    while (node && node !== document.body) {
      var _getComputedStyle = getComputedStyle(node),
        transform = _getComputedStyle.transform;
      if (!/matrix\([\d,\s]+\)/.test(transform)) {
        node = node.parentNode;
        continue;
      }
      return node;
    }
    return null;
  };
  var findRelativeRect = function findRelativeRect(dom) {
    var container = findRelativeContainer(dom);
    var containerRect = container ? container.getBoundingClientRect() : {
      top: 0,
      left: 0
    };
    var _dom$getBoundingClien = dom.getBoundingClientRect(),
      top = _dom$getBoundingClien.top,
      left = _dom$getBoundingClien.left,
      bottom = _dom$getBoundingClien.bottom,
      right = _dom$getBoundingClien.right,
      width = _dom$getBoundingClien.width,
      height = _dom$getBoundingClien.height;
    return {
      top: top - containerRect.top,
      bottom: bottom - containerRect.top,
      left: left - containerRect.left,
      right: right - containerRect.left,
      width: width,
      height: height
    };
  };

  var DropdownMenuProps = {
    activeColor: {
      type: String,
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [String, Number],
      default: 200
    },
    overlay: {
      type: Boolean,
      default: true
    },
    zIndex: {
      type: Number
    }
  };

  function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$h(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$n = config.prefix;
  var name$n = "".concat(prefix$n, "-dropdown-menu");
  var script$p = vue.defineComponent({
    name: name$n,
    components: {
      CaretDownSmallIcon: caretDownSmall
    },
    props: DropdownMenuProps,
    setup: function setup(props, _ref) {
      var slots = _ref.slots,
        expose = _ref.expose;
      var state = vue.reactive({
        activeId: null,
        barRect: {},
        childCount: 0
      });
      var menuItems = vue.ref([]);
      var updateItems = function updateItems() {
        if (slots.default) {
          var itemName = "".concat(prefix$n, "-dropdown-item");
          var children = slots.default();
          menuItems.value = children.filter(function (child) {
            var _child$type;
            var childTypeName = child === null || child === void 0 ? void 0 : (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name;
            return (childTypeName === null || childTypeName === void 0 ? void 0 : childTypeName.includes) && childTypeName.includes(itemName);
          });
        }
      };
      vue.watch(function () {
        var _slots$default;
        return slots === null || slots === void 0 ? void 0 : (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }, updateItems, {
        deep: true,
        immediate: true
      });
      var menuTitles = vue.computed(function () {
        return menuItems.value.map(function (item) {
          var _item$props = item.props,
            label = _item$props.label,
            disabled = _item$props.disabled;
          return {
            label: label,
            disabled: disabled !== void 0 && disabled !== false
          };
        });
      });
      var aniControl = new TransAniControl();
      vue.provide("dropdownMenuProps", props);
      vue.provide("dropdownMenuState", state);
      vue.provide("dropdownAniControl", aniControl);
      var classes = vue.computed(function () {
        return ["".concat(name$n)];
      });
      var refBar = vue.ref(null);
      var styleBar = vue.computed(function () {
        return ["".concat(name$n, "__bar"), _defineProperty$2({}, "".concat(name$n, "__bar ").concat(name$n, "__bar--open"), state.activeId)];
      });
      var styleBarItem = vue.computed(function () {
        return function (item, idx) {
          var _ref3;
          return ["".concat(name$n, "__item"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(prefix$n, "-is-disabled"), item.disabled), _defineProperty$2(_ref3, "".concat(prefix$n, "-is-active"), idx === state.activeId), _ref3)];
        };
      });
      var expandMenu = function expandMenu(item, idx) {
        var disabled = item.disabled;
        if (disabled) return;
        if (state.activeId === idx) {
          collapseMenu();
          return;
        }
        state.activeId = idx;
        var bar = refBar.value;
        var barRect = findRelativeRect(bar);
        state.barRect = barRect;
        var container = findRelativeContainer(bar) || document.body;
        context.recordMenuExpanded(container, control, DropdownMenuExpandState.expanded);
      };
      var collapseMenu = function collapseMenu() {
        state.activeId = null;
        var bar = refBar.value;
        var container = findRelativeContainer(bar) || document.body;
        context.recordMenuExpanded(container, control, DropdownMenuExpandState.collapsed);
      };
      var control = {
        expandMenu: expandMenu,
        collapseMenu: collapseMenu
      };
      vue.provide("dropdownMenuControl", control);
      expose({
        toggle: function toggle(idx) {
          if (idx != null) {
            var item = menuTitles.value[idx];
            expandMenu(item, idx);
          } else {
            collapseMenu();
          }
        }
      });
      return _objectSpread$h(_objectSpread$h({
        name: vue.ref(name$n),
        classes: classes
      }, vue.toRefs(props)), {}, {
        refBar: refBar,
        state: state,
        styleBar: styleBar,
        styleBarItem: styleBarItem,
        menuItems: menuItems,
        menuTitles: menuTitles,
        expandMenu: expandMenu
      });
    }
  });

  var _hoisted_1$8 = ["onClick"];
  function render$o(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_caret_down_small_icon = vue.resolveComponent("caret-down-small-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      ref: "refBar",
      class: vue.normalizeClass(_ctx.styleBar)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.menuTitles, function (item, idx) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: idx,
        class: vue.normalizeClass(_ctx.styleBarItem(item, idx)),
        onClick: function onClick($event) {
          return _ctx.expandMenu(item, idx);
        }
      }, [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.name, "__title"))
      }, vue.toDisplayString(item.label), 3), vue.createVNode(_component_caret_down_small_icon, {
        class: vue.normalizeClass("".concat(_ctx.name, "__arrow")),
        size: "24"
      }, null, 8, ["class"])], 10, _hoisted_1$8);
    }), 128))], 2), vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$p.render = render$o;

  var DropdownItemProps = {
    disabled: Boolean,
    label: {
      type: String,
      default: ""
    },
    multiple: Boolean,
    options: {
      type: Array
    },
    optionsColumns: {
      type: [String, Number]
    },
    optionsLayout: {
      type: String,
      default: "columns",
      validator: function validator(val) {
        return ["columns", "tree"].includes(val);
      }
    },
    value: {
      type: [String, Number, Array],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Array],
      default: void 0
    },
    onChange: Function
  };

  function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$g(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$m = config.prefix;
  var name$m = "".concat(prefix$m, "-dropdown-item");
  var script$o = vue.defineComponent({
    name: name$m,
    components: {
      TRadio: _Radio,
      TButton: _Button,
      TCheckbox: CheckBox,
      TRadioGroup: _RadioGroup,
      TCheckboxGroup: CheckboxGroup
    },
    props: DropdownItemProps,
    emits: ["change", "open", "opened", "close", "closed", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        passInValue = _useVModel2[0],
        setValue = _useVModel2[1];
      var menuProps = vue.inject("dropdownMenuProps");
      var menuState = vue.inject("dropdownMenuState");
      var _inject = vue.inject("dropdownMenuControl"),
        expandMenu = _inject.expandMenu,
        collapseMenu = _inject.collapseMenu;
      var menuAniControl = vue.inject("dropdownAniControl");
      var classes = vue.computed(function () {
        return ["".concat(name$m), _defineProperty$2({}, "".concat(prefix$m, "-is-expanded"), state.isExpanded)];
      });
      var itemId = vue.ref(0);
      vue.onBeforeMount(function () {
        itemId.value = menuState.childCount;
        menuState.childCount += 1;
      });
      var state = vue.reactive({
        showOverlay: vue.computed(function () {
          return menuProps.overlay;
        }),
        isShowItems: false,
        isExpanded: false,
        expandStyle: {},
        transitionStyle: vue.computed(function () {
          return {
            transition: "transform ".concat(menuProps.duration, "ms ease"),
            "-webkit-transition": "transform ".concat(menuProps.duration, "ms ease")
          };
        }),
        multiple: vue.computed(function () {
          return props.multiple;
        }),
        optionsLayout: vue.computed(function () {
          return props.optionsLayout;
        }),
        options: vue.computed(function () {
          return props.options;
        })
      });
      var isCheckedRadio = function isCheckedRadio(value2) {
        return value2 === radioSelect.value;
      };
      var styleDropRadio = function styleDropRadio(value2) {
        var _ref2;
        return ["".concat(name$m, "__radio"), (_ref2 = {}, _defineProperty$2(_ref2, "".concat(prefix$m, "-is-tick"), !props.multiple), _defineProperty$2(_ref2, "".concat(prefix$m, "-is-checked"), isCheckedRadio(value2)), _ref2)];
      };
      var styleContent = vue.computed(function () {
        var _props$optionsColumns, _ref3;
        var optionsLayout = props.optionsLayout;
        var layoutCol = +((_props$optionsColumns = props.optionsColumns) !== null && _props$optionsColumns !== void 0 ? _props$optionsColumns : 0);
        var isTree = optionsLayout === "tree";
        var treeCol = isTree ? treeState.leafLevel + 1 : 0;
        return ["".concat(name$m, "__content"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(prefix$m, "-is-tree"), isTree), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-single"), !isTree && !props.multiple), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-multi"), !isTree && props.multiple), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col1"), layoutCol === 1 || treeCol === 1), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col2"), layoutCol === 2 || treeCol === 2), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col3"), layoutCol === 3 || treeCol === 3), _ref3)];
      });
      var setExpand = function setExpand(val) {
        var bottom = menuState.barRect.bottom;
        state.expandStyle = {
          zIndex: menuProps.zIndex,
          top: "".concat(bottom, "px")
        };
        var duration = menuProps.duration;
        menuAniControl.setTo(+(duration !== null && duration !== void 0 ? duration : 200), function () {
          emitEvent(val ? "open" : "close");
          if (val) {
            state.isShowItems = val;
          }
          state.isExpanded = !val;
        }, function () {
          state.isExpanded = val;
        }, function () {
          if (!val) {
            state.isShowItems = val;
          }
          emitEvent(val ? "opened" : "closed");
        });
      };
      vue.watch(function () {
        return menuState.activeId === itemId.value;
      }, function (val) {
        return setExpand(val);
      });
      var radioSelect = vue.ref();
      var checkSelect = vue.ref([]);
      var treeState = vue.reactive({
        leafLevel: 0,
        selectList: []
      });
      var styleTreeRadio = vue.computed(function () {
        return function (value2, level) {
          var _ref4;
          return ["".concat(name$m, "__radio"), (_ref4 = {}, _defineProperty$2(_ref4, "".concat(prefix$m, "-is-tick"), level === treeState.leafLevel), _defineProperty$2(_ref4, "".concat(prefix$m, "-is-checked"), value2 === treeState.selectList[level]), _ref4)];
        };
      });
      var selectTreeNode = function selectTreeNode(level, value2) {
        var rebuildTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var tempValue = treeState.selectList.slice(0, level);
        tempValue[level] = value2;
        treeState.selectList = tempValue;
        if (rebuildTree) {
          buildTreeOptions();
        }
      };
      var treeOptions = vue.ref([]);
      var buildTreeOptions = function buildTreeOptions() {
        var options = props.options;
        var selectList = treeState.selectList;
        var newTreeOptions = [];
        var level = -1;
        var node = {
          title: "",
          value: "",
          disabled: false,
          options: options
        };
        var _loop = function _loop() {
          var list = node.options;
          newTreeOptions.push(_toConsumableArray(list));
          level += 1;
          var thisValue = selectList[level];
          if (thisValue === void 0) {
            var firstChild = list[0];
            if (firstChild.options) {
              selectTreeNode(level, firstChild.value, false);
              node = firstChild;
            } else {
              selectTreeNode(level, props.multiple ? [] : void 0, false);
              return "break";
            }
          } else if (!Array.isArray(thisValue)) {
            var child = list.find(function (child2) {
              return child2.value === thisValue;
            });
            node = child;
          } else {
            node = void 0;
          }
        };
        while ((_node = node) !== null && _node !== void 0 && _node.options) {
          var _node;
          var _ret = _loop();
          if (_ret === "break") break;
        }
        treeState.leafLevel = Math.max(0, level);
        treeOptions.value = newTreeOptions;
      };
      if (props.optionsLayout === "tree") {
        vue.watch(function () {
          return JSON.stringify({
            options: props.options
          });
        }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return vue.nextTick();
                case 2:
                  buildTreeOptions();
                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })));
        buildTreeOptions();
      }
      var updateSelectValue = function updateSelectValue(val) {
        var layout = props.optionsLayout;
        if (layout === "tree") {
          treeState.selectList = val !== null && val !== void 0 ? val : [];
          buildTreeOptions();
        } else if (layout === "columns") {
          if (!props.multiple) {
            var _ref6;
            var list = props.options;
            var firstChild = list === null || list === void 0 ? void 0 : list[0];
            var newValue = (_ref6 = val !== null && val !== void 0 ? val : firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _ref6 !== void 0 ? _ref6 : null;
            radioSelect.value = newValue;
          } else if (props.multiple) {
            if (props.optionsLayout === "columns") {
              checkSelect.value = val !== null && val !== void 0 ? val : [];
            }
          }
        }
      };
      updateSelectValue(passInValue.value || null);
      vue.watch(function () {
        return passInValue.value;
      }, function (val) {
        if (!val) return;
        updateSelectValue(val);
      });
      var isBtnDisabled = vue.computed(function () {
        switch (props.optionsLayout) {
          case "columns":
            return checkSelect.value.length <= 0;
          case "tree":
            if (!props.multiple) {
              return treeState.selectList[treeState.leafLevel] === void 0;
            }
            if (props.multiple) {
              var selectList = treeState.selectList[treeState.leafLevel];
              return selectList && selectList.length <= 0;
            }
        }
        return true;
      });
      var resetSelect = function resetSelect() {
        switch (props.optionsLayout) {
          case "columns":
            checkSelect.value = [];
            break;
          case "tree":
            treeState.selectList = [];
            break;
        }
      };
      var confirmSelect = function confirmSelect() {
        var values;
        switch (props.optionsLayout) {
          case "columns":
            values = checkSelect.value;
            break;
          case "tree":
            values = treeState.selectList;
            break;
        }
        values = JSON.parse(JSON.stringify(values));
        setValue(values);
        collapseMenu();
      };
      vue.watch(radioSelect, function (val) {
        if (props.multiple || props.optionsLayout === "tree") return;
        if (!state.isShowItems) return;
        var value2 = passInValue.value || [];
        if (value2[0] === val) return;
        if (val) {
          setValue(val);
        }
        collapseMenu();
      });
      var onClickOverlay = function onClickOverlay() {
        if (menuProps.closeOnClickOverlay) {
          collapseMenu();
        }
      };
      var TiconCheckIcon = vue.h(check);
      var convertTreeRadioType = function convertTreeRadioType(value2) {
        return value2;
      };
      var convertTreeCheckType = function convertTreeCheckType(value2) {
        return value2;
      };
      return _objectSpread$g(_objectSpread$g(_objectSpread$g({
        name: vue.ref(name$m)
      }, vue.toRefs(props)), vue.toRefs(state)), {}, {
        classes: classes,
        styleContent: styleContent,
        isBtnDisabled: isBtnDisabled,
        radioSelect: radioSelect,
        checkSelect: checkSelect,
        treeOptions: treeOptions,
        treeState: treeState,
        styleTreeRadio: styleTreeRadio,
        isCheckedRadio: isCheckedRadio,
        selectTreeNode: selectTreeNode,
        styleDropRadio: styleDropRadio,
        expandMenu: expandMenu,
        collapseMenu: collapseMenu,
        resetSelect: resetSelect,
        confirmSelect: confirmSelect,
        onClickOverlay: onClickOverlay,
        renderCheckIcon: [TiconCheckIcon],
        convertTreeRadioType: convertTreeRadioType,
        convertTreeCheckType: convertTreeCheckType
      });
    }
  });

  function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function render$n(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_radio = vue.resolveComponent("t-radio");
    var _component_t_radio_group = vue.resolveComponent("t-radio-group");
    var _component_t_checkbox = vue.resolveComponent("t-checkbox");
    var _component_t_checkbox_group = vue.resolveComponent("t-checkbox-group");
    var _component_t_button = vue.resolveComponent("t-button");
    return _ctx.isShowItems ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.classes),
      style: vue.normalizeStyle(_objectSpread$f({}, _ctx.expandStyle))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.styleContent),
      style: vue.normalizeStyle(_objectSpread$f({}, _ctx.transitionStyle))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bd"))
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [_ctx.optionsLayout === "columns" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: 0
      }, [!_ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
        key: 0,
        modelValue: _ctx.radioSelect,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
          return _ctx.radioSelect = $event;
        })
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option) {
            return vue.openBlock(), vue.createBlock(_component_t_radio, {
              key: option.value,
              value: option.value,
              label: option.title,
              disabled: option.disabled,
              class: vue.normalizeClass(_ctx.styleDropRadio(option.value)),
              align: "right",
              checked: _ctx.isCheckedRadio(option.value),
              icon: _ctx.renderCheckIcon
            }, null, 8, ["value", "label", "disabled", "class", "checked", "icon"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["modelValue"])) : (vue.openBlock(), vue.createBlock(_component_t_checkbox_group, {
        key: 1,
        modelValue: _ctx.checkSelect,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
          return _ctx.checkSelect = $event;
        })
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option) {
            return vue.openBlock(), vue.createBlock(_component_t_checkbox, {
              key: option.value,
              borderless: "",
              value: option.value,
              label: option.title,
              disabled: option.disabled
            }, null, 8, ["value", "label", "disabled"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["modelValue"]))], 64)) : _ctx.optionsLayout === "tree" ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
        key: 1
      }, vue.renderList(_ctx.treeOptions, function (_, level) {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: level,
          class: vue.normalizeClass("".concat(_ctx.name, "__tree-group"))
        }, [level < _ctx.treeState.leafLevel ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
          key: 0,
          "model-value": _ctx.convertTreeRadioType(_ctx.treeState.selectList[level]),
          "onUpdate:modelValue": function onUpdateModelValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_radio, {
                key: option.value,
                class: vue.normalizeClass(_ctx.styleTreeRadio(option.value, level)),
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                align: "right",
                icon: [],
                borderless: ""
              }, null, 8, ["class", "value", "label", "disabled"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["model-value", "onUpdate:modelValue"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 1
        }, [!_ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
          key: 0,
          value: _ctx.convertTreeRadioType(_ctx.treeState.selectList[level]),
          "onUpdate:value": function onUpdateValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_radio, {
                key: option.value,
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                class: vue.normalizeClass(_ctx.styleTreeRadio(option.value, level)),
                align: "right",
                borderless: ""
              }, null, 8, ["value", "label", "disabled", "class"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["value", "onUpdate:value"])) : (vue.openBlock(), vue.createBlock(_component_t_checkbox_group, {
          key: 1,
          value: _ctx.convertTreeCheckType(_ctx.treeState.selectList[level]),
          "onUpdate:value": function onUpdateValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_checkbox, {
                key: option.value,
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                align: "right",
                borderless: ""
              }, null, 8, ["value", "label", "disabled"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["value", "onUpdate:value"]))], 64))], 2);
      }), 128)) : vue.createCommentVNode("", true)];
    })], 2), _ctx.multiple || _ctx.optionsLayout === "tree" ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__ft"))
    }, [vue.createVNode(_component_t_button, {
      variant: "outline",
      disabled: _ctx.isBtnDisabled,
      onClick: _ctx.resetSelect
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode("\u91CD\u7F6E")];
      }),
      _: 1
    }, 8, ["disabled", "onClick"]), vue.createVNode(_component_t_button, {
      theme: "primary",
      disabled: _ctx.isBtnDisabled,
      onClick: _ctx.confirmSelect
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode("\u786E\u5B9A")];
      }),
      _: 1
    }, 8, ["disabled", "onClick"])], 2)) : vue.createCommentVNode("", true)], 6)], 6)) : vue.createCommentVNode("", true);
  }

  script$o.render = render$n;

  var DropdownMenu = withInstall(script$p);
  var DropdownItem = withInstall(script$o);

  var props$3 = {
    defaultExpandAll: Boolean,
    disabled: Boolean,
    expandIcon: {
      type: [Boolean, Function],
      default: true
    },
    expandMutex: Boolean,
    value: {
      type: Array
    },
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: []
    },
    onChange: Function
  };

  var prefix$l = config.prefix;
  var name$l = "".concat(prefix$l, "-collapse");
  var script$n = vue.defineComponent({
    name: name$l,
    props: props$3,
    emits: ["update:value", "change"],
    setup: function setup(props2) {
      var _toRefs = vue.toRefs(props2),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        activeValue = _useVModel2[0],
        setActiveValue = _useVModel2[1];
      var calcActiveValues = function calcActiveValues(activeValues, panelValue, expandMutex) {
        var hit = activeValues.indexOf(panelValue);
        if (hit > -1) {
          return activeValues.filter(function (item) {
            return item !== panelValue;
          });
        }
        return expandMutex ? [panelValue] : activeValues.concat(panelValue);
      };
      var onPanelChange = function onPanelChange(value2) {
        if (Array.isArray(activeValue.value)) {
          var val = calcActiveValues(activeValue.value, value2, props2.expandMutex);
          setActiveValue(val);
        }
      };
      var disabled = vue.computed(function () {
        return props2.disabled;
      });
      var expandIcon = vue.computed(function () {
        return props2.expandIcon;
      });
      vue.provide("collapse", {
        activeValue: activeValue,
        disabled: disabled,
        expandIcon: expandIcon,
        onPanelChange: onPanelChange,
        defaultExpandAll: props2.defaultExpandAll
      });
      return {
        prefix: prefix$l,
        classPrefix: name$l,
        activeValue: activeValue
      };
    }
  });

  function render$m(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classPrefix)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$n.render = render$m;

  var props$2 = {
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    destroyOnCollapse: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    },
    expandIcon: {
      type: [Boolean, Function],
      default: void 0
    },
    header: {
      type: [String, Function]
    },
    headerRightContent: {
      type: [String, Function]
    },
    value: {
      type: [String, Number],
      required: true
    }
  };

  function findIndex$1(v, set) {
    var reg = new RegExp("^".concat(!v && v !== 0 ? "" : v, "$"));
    var arr = toArray(set);
    return arr.findIndex(function (s) {
      return reg.test(s);
    });
  }
  function isFalsy(v) {
    return !v && v !== 0;
  }
  function toArray(v) {
    if (isFalsy(v)) return [];
    if (_typeof$1(v) === "object") return Array.from(v);
    return [v];
  }

  var prefix$k = config.prefix;
  var name$k = "".concat(prefix$k, "-collapse-panel");
  var script$m = vue.defineComponent({
    name: name$k,
    components: {
      ChevronDownIcon: chevronDown,
      ChevronUpIcon: chevronUp,
      TNode: TNodeComponent
    },
    props: props$2,
    setup: function setup(props2, context) {
      var internalInstance = vue.getCurrentInstance();
      var parent = vue.inject("collapse");
      var isTrue = function isTrue(val) {
        return typeof val === "boolean" && val;
      };
      var rightIcon = vue.computed(function () {
        if (props2.expandIcon === false) return;
        if (isTrue(props2.expandIcon) || isTrue(parent === null || parent === void 0 ? void 0 : parent.expandIcon.value)) {
          console.log(isTrue(parent === null || parent === void 0 ? void 0 : parent.expandIcon.value));
          return isActive.value ? chevronDown : chevronUp;
        }
        return renderTNode(internalInstance, "expand-icon")[0];
      });
      var disabled = vue.computed(function () {
        return (parent === null || parent === void 0 ? void 0 : parent.disabled.value) || props2.disabled;
      });
      var className = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$k), true), _defineProperty$2(_ref, "".concat(name$k, "--active"), isActive.value), _defineProperty$2(_ref, "".concat(name$k, "--disabled"), disabled.value), _ref;
      });
      var isActive = vue.computed(function () {
        return findIndex$1(props2.value, parent === null || parent === void 0 ? void 0 : parent.activeValue.value) > -1;
      });
      var updatePanelValue = function updatePanelValue() {
        if (props2.value != null) {
          parent === null || parent === void 0 ? void 0 : parent.onPanelChange(props2.value);
        }
      };
      var handleClick = function handleClick(e) {
        e === null || e === void 0 ? void 0 : e.stopPropagation();
        if (disabled.value) {
          return;
        }
        updatePanelValue();
      };
      var panelContent = renderContent(internalInstance, "default", "content");
      var $body = vue.ref();
      var $wrap = vue.ref();
      var $head = vue.ref();
      var updatePanelState = function updatePanelState() {
        if (!$wrap.value) {
          return;
        }
        var _$head$value$getBound = $head.value.getBoundingClientRect(),
          headHeight = _$head$value$getBound.height;
        if (!isActive.value) {
          $wrap.value.style.height = "".concat(headHeight, "px");
          return;
        }
        var _$body$value$getBound = $body.value.getBoundingClientRect(),
          bodyHeight = _$body$value$getBound.height;
        var height = headHeight + bodyHeight;
        $wrap.value.style.height = "".concat(height, "px");
      };
      vue.watch(isActive, function () {
        vue.nextTick(function () {
          updatePanelState();
        });
      });
      vue.onMounted(function () {
        if (parent !== null && parent !== void 0 && parent.defaultExpandAll) {
          updatePanelValue();
        }
        updatePanelState();
      });
      return {
        classPrefix: name$k,
        rightIcon: rightIcon,
        $head: $head,
        $body: $body,
        $wrap: $wrap,
        className: className,
        handleClick: handleClick,
        panelContent: panelContent
      };
    }
  });

  function render$l(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "$wrap",
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createElementVNode("div", {
      ref: "$head",
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__title"))
    }, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.header), 1)];
    })], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-right"))
    }, [_ctx.headerRightContent || _ctx.$slots.headerRightContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-extra"))
    }, [vue.renderSlot(_ctx.$slots, "headerRightContent", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.headerRightContent), 1)];
    })], 2)) : vue.createCommentVNode("", true), (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.rightIcon), {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-icon"))
    }, null, 8, ["class"]))], 2)], 2), vue.createElementVNode("div", {
      ref: "$body",
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__body"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.panelContent
    }, null, 8, ["content"])], 2)], 2);
  }

  script$m.render = render$l;

  var Collapse = withInstall(script$n);
  var CollapsePanel = withInstall(script$m);

  var TabsProps = {
    animation: {
      type: Object
    },
    list: {
      type: Array
    },
    placement: {
      type: String,
      default: "top",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "top"].includes(val);
      }
    },
    showBottomLine: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["medium", "large"].includes(val);
      }
    },
    stickyProps: {
      type: Object
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number]
    },
    onChange: Function
  };

  var TabPanelProps = {
    destroyOnHide: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    label: {
      type: [String, Function]
    },
    panel: {
      type: [String, Function]
    },
    value: {
      type: [String, Number]
    }
  };

  var prefix$j = config.prefix;
  var script$l = vue.defineComponent({
    name: "".concat(prefix$j, "-tab-nav"),
    components: {
      TNode: TNodeComponent
    },
    props: {
      label: TabPanelProps.label
    },
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "label");
      });
      return {
        labelContent: labelContent
      };
    }
  });

  function render$k(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])]);
  }

  script$l.render = render$k;

  var props$1 = {
    container: {
      type: Object
    },
    disabled: Boolean,
    offsetTop: {
      type: [String, Number],
      default: 0
    },
    zIndex: {
      type: Number,
      default: 99
    },
    onScroll: Function
  };

  var name$j = "".concat(config.prefix, "-sticky");
  var script$k = vue.defineComponent({
    name: name$j,
    components: {
      TNode: TNodeComponent
    },
    props: props$1,
    setup: function setup(props2, context) {
      var boxClasses = name$j;
      var stickyContent = vue.computed(function () {
        return renderContent(vue.getCurrentInstance(), "default", "");
      });
      var emitEvent = useEmitEvent(props2, context.emit);
      var boxRef = templateRef("boxRef");
      var _useElementBounding = useElementBounding(boxRef),
        boxTop = _useElementBounding.top;
      var contentRef = templateRef("contentRef");
      var _useElementBounding2 = useElementBounding(contentRef),
        contentTop = _useElementBounding2.top,
        height = _useElementBounding2.height;
      var boxStyles = vue.computed(function () {
        return "height:".concat(height.value, "px;");
      });
      var container;
      var containerHeight = vue.ref(0);
      var containerTop = vue.ref(0);
      vue.watch(boxTop, function () {
        if (props2.container) {
          container = document.querySelector(props2.container);
          var _container$getBoundin = container.getBoundingClientRect(),
            top = _container$getBoundin.top,
            height2 = _container$getBoundin.height;
          containerHeight.value = height2;
          containerTop.value = top;
        }
      });
      var contentStyles = vue.computed(function () {
        var styleStr = "z-index:".concat(props2.zIndex, ";");
        var isFixed = false;
        if (props2.disabled) return styleStr;
        var offsetTop = Number(props2.offsetTop);
        if (container) {
          if (containerHeight.value + containerTop.value < offsetTop + height.value) {
            styleStr += "transform:translate3d(0, ".concat(containerHeight.value - height.value, "px, 0);");
          } else if (boxTop.value <= offsetTop) {
            styleStr += "position:fixed;top:".concat(offsetTop, "px;");
            isFixed = true;
          }
        } else if (boxTop.value <= offsetTop) {
          styleStr += "position:fixed;top:".concat(offsetTop, "px;");
          isFixed = true;
        }
        emitEvent("scroll", {
          scrollTop: contentTop.value,
          isFixed: isFixed
        });
        return styleStr;
      });
      return {
        boxClasses: boxClasses,
        boxStyles: boxStyles,
        contentStyles: contentStyles,
        stickyContent: stickyContent
      };
    }
  });

  function render$j(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "boxRef",
      class: vue.normalizeClass(_ctx.boxClasses),
      style: vue.normalizeStyle(_ctx.boxStyles)
    }, [vue.createElementVNode("div", {
      ref: "contentRef",
      class: vue.normalizeClass("".concat(_ctx.boxClasses, "__content")),
      style: vue.normalizeStyle(_ctx.contentStyles)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.stickyContent
    }, null, 8, ["content"])], 6)], 6);
  }

  script$k.render = render$j;

  var _Sticky = withInstall(script$k);

  function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$i = config.prefix;
  var name$i = "".concat(prefix$i, "-tabs");
  var script$j = vue.defineComponent({
    name: name$i,
    components: {
      TabNavItem: script$l,
      TSticky: _Sticky
    },
    props: TabsProps,
    emits: ["update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var placement = vue.computed(function () {
        return props.placement;
      });
      var showBottomLine = vue.computed(function () {
        return props.showBottomLine;
      });
      var stickyProps = vue.computed(function () {
        return _objectSpread$e({
          disabled: true
        }, props.stickyProps);
      });
      var activeClass = ClASSNAMES.STATUS.active;
      var disabledClass = ClASSNAMES.STATUS.disabled;
      var classes = vue.computed(function () {
        return ["".concat(name$i), "".concat(prefix$i, "-is-").concat(placement.value), props.size ? ClASSNAMES.SIZE[props.size] : ""];
      });
      var navClasses = vue.ref(["".concat(name$i, "__nav")]);
      var isScroll = vue.ref(false);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        currentValue = _useVModel2[0],
        setCurrentValue = _useVModel2[1];
      var itemProps = vue.computed(function () {
        if (props.list) {
          return props.list;
        }
        var children = context.slots.default ? context.slots.default() : [];
        var res = [];
        var _label = [];
        children.forEach(function (child) {
          var _child$children;
          if (child.type === vue.Fragment) {
            res.push.apply(res, _toConsumableArray(child.children));
          } else {
            res.push(child);
          }
          if ((_child$children = child.children) !== null && _child$children !== void 0 && _child$children.label) {
            _label.push(child.children.label()[0] || null);
          }
        });
        children = res.filter(function (child) {
          return child.type.name === "".concat(prefix$i, "-tab-panel");
        });
        return children.map(function (item, index) {
          return _objectSpread$e(_objectSpread$e({}, item.props), {}, {
            label: function label() {
              return _label[index] || item.props.label;
            }
          });
        });
      });
      var navScroll = vue.ref(null);
      var navWrap = vue.ref(null);
      var navLine = vue.ref(null);
      var lineStyle = vue.ref("");
      var moveToActiveTab = function moveToActiveTab() {
        if (navWrap.value && navLine.value && showBottomLine.value) {
          var tab = navWrap.value.querySelector(".".concat(activeClass));
          if (!tab) return;
          var line = navLine.value;
          if (placement.value === "left") {
            lineStyle.value = "transform: translateY(".concat(tab.offsetTop, "px);").concat(props.animation ? "transition-duration:".concat(props.animation.duration, "ms") : "");
          } else {
            lineStyle.value = "transform: translateX(".concat(Number(tab.offsetLeft) + Number(tab.offsetWidth) / 2 - line.offsetWidth / 2, "px);").concat(props.animation ? "transition-duration:".concat(props.animation.duration, "ms") : "");
          }
        }
      };
      vue.onMounted(function () {
        var _navWrap$value, _navScroll$value;
        isScroll.value = (((_navWrap$value = navWrap.value) === null || _navWrap$value === void 0 ? void 0 : _navWrap$value.offsetWidth) || 0) > (((_navScroll$value = navScroll.value) === null || _navScroll$value === void 0 ? void 0 : _navScroll$value.offsetWidth) || 0);
        isScroll.value && navClasses.value.push("".concat(prefix$i, "-is-scrollable"));
        window.addEventListener("resize", moveToActiveTab, false);
        setTimeout(function () {
          moveToActiveTab();
        }, 300);
      });
      vue.onBeforeUnmount(function () {
        window.removeEventListener("resize", moveToActiveTab);
      });
      var tabClick = function tabClick(event, item) {
        var value2 = item.value,
          disabled = item.disabled;
        if (disabled || currentValue.value === value2) {
          return false;
        }
        setCurrentValue(value2);
        vue.nextTick(function () {
          moveToActiveTab();
        });
      };
      vue.provide("currentValue", vue.readonly(currentValue));
      return {
        name: name$i,
        prefix: prefix$i,
        classes: classes,
        navClasses: navClasses,
        activeClass: activeClass,
        disabledClass: disabledClass,
        currentValue: currentValue,
        tabClick: tabClick,
        showBottomLine: showBottomLine,
        itemProps: itemProps,
        navScroll: navScroll,
        navWrap: navWrap,
        navLine: navLine,
        lineStyle: lineStyle,
        moveToActiveTab: moveToActiveTab,
        stickyProps: stickyProps
      };
    }
  });

  function render$i(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_tab_nav_item = vue.resolveComponent("tab-nav-item");
    var _component_t_sticky = vue.resolveComponent("t-sticky");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createVNode(_component_t_sticky, vue.normalizeProps(vue.guardReactiveProps(_ctx.stickyProps)), {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.navClasses)
        }, [vue.createElementVNode("div", {
          ref: "navScroll",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-container"))
        }, [vue.createElementVNode("div", {
          ref: "navWrap",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-wrap"))
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.itemProps, function (item) {
          var _normalizeClass2;
          return vue.openBlock(), vue.createBlock(_component_tab_nav_item, {
            key: item.value,
            label: item.label,
            class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__nav-item"), true), _defineProperty$2(_normalizeClass2, _ctx.activeClass, item.value === _ctx.currentValue), _defineProperty$2(_normalizeClass2, _ctx.disabledClass, item.disabled), _normalizeClass2)),
            onClick: function onClick(e) {
              return _ctx.tabClick(e, item);
            }
          }, null, 8, ["label", "class", "onClick"]);
        }), 128)), _ctx.showBottomLine ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "navLine",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-line")),
          style: vue.normalizeStyle(_ctx.lineStyle)
        }, null, 6)) : vue.createCommentVNode("", true)], 2)], 2)], 2)];
      }),
      _: 1
    }, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__content"))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2)], 2);
  }

  script$j.render = render$i;

  function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$h = config.prefix;
  var name$h = "".concat(prefix$h, "-tab-panel");
  var script$i = vue.defineComponent({
    name: name$h,
    components: {
      TNode: TNodeComponent
    },
    props: TabPanelProps,
    setup: function setup(props) {
      var currentValue = vue.inject("currentValue", "");
      var isActive = vue.computed(function () {
        return currentValue.value === props.value;
      });
      var internalInstance = vue.getCurrentInstance();
      var panelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "panel");
      });
      var tabPanelClass = vue.computed(function () {
        return ["".concat(name$h), "".concat(prefix$h, "-tabs__panel")];
      });
      return _objectSpread$d({
        prefix: prefix$h,
        name: name$h,
        isActive: isActive,
        panelContent: panelContent,
        tabPanelClass: tabPanelClass
      }, vue.toRefs(props));
    }
  });

  var _hoisted_1$7 = ["value"];
  function render$h(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return _ctx.destroyOnHide || _ctx.isActive ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.tabPanelClass),
      value: _ctx.value
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [vue.createVNode(_component_t_node, {
        content: _ctx.panelContent
      }, null, 8, ["content"])];
    })], 10, _hoisted_1$7)), [[vue.vShow, _ctx.isActive]]) : vue.createCommentVNode("", true);
  }

  script$i.render = render$h;

  var Tabs = withInstall(script$j);
  var TabPanel = withInstall(script$i);

  var CountDownProps = {
    autoStart: {
      type: Boolean,
      default: true
    },
    content: {
      type: [String, Function],
      default: "default"
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    millisecond: Boolean,
    time: {
      type: Number,
      required: true
    },
    size: {
      type: String,
      default: "small"
    },
    theme: {
      type: String,
      default: "default"
    },
    onChange: Function,
    onFinish: Function
  };

  function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$g = config.prefix;
  var name$g = "".concat(prefix$g, "-countdown");
  var script$h = vue.defineComponent({
    name: name$g,
    components: {
      TNode: TNodeComponent
    },
    props: _objectSpread$c({}, CountDownProps),
    setup: function setup(props) {
      var _ref, _ref$test;
      var _useCountDown = useCountDown(props),
        time = _useCountDown.time,
        showTimes = _useCountDown.showTimes;
      var internalInstance = vue.getCurrentInstance();
      var hasChinese = (_ref = /.*[\u4e00-\u9fa5]+.*$/) === null || _ref === void 0 ? void 0 : (_ref$test = _ref.test) === null || _ref$test === void 0 ? void 0 : _ref$test.call(_ref, props === null || props === void 0 ? void 0 : props.format);
      var contentLayout = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      return {
        name: name$g,
        time: time,
        showTimes: showTimes,
        hasChinese: hasChinese,
        contentLayout: contentLayout
      };
    }
  });

  function render$g(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [!_ctx.time ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.contentLayout
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, " ").concat(_ctx.name, "--").concat(_ctx.theme, " ").concat(_ctx.name, "--").concat(_ctx.size, " ").concat(!_ctx.hasChinese ? "" : "".concat(_ctx.name, "--split-with-unit")))
    }, [_ctx.time ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.showTimes, function (item) {
      return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: item.mark
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "__digit"))
      }, vue.toDisplayString(item.value), 3), item.mark ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.name, "__unit"))
      }, vue.toDisplayString(item.mark), 3)) : vue.createCommentVNode("", true)], 64);
    }), 128)) : vue.createCommentVNode("", true)], 2)], 64);
  }

  script$h.render = render$g;

  var Countdown = withInstall(script$h);

  var AvatarProps = {
    ImageProps: {
      type: Object
    },
    alt: {
      type: String,
      default: ""
    },
    badgeProps: {
      type: Object
    },
    hideOnLoadFailed: Boolean,
    icon: {
      type: Function
    },
    image: {
      type: String,
      default: ""
    },
    shape: {
      type: String,
      default: "circle",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round"].includes(val);
      }
    },
    size: {
      type: String,
      default: ""
    },
    onError: Function
  };

  function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$f = config.prefix;
  var name$f = "".concat(prefix$f, "-avatar");
  var script$g = vue.defineComponent({
    name: name$f,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge
    },
    props: AvatarProps,
    emits: ["error"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var avatarGroupProps = vue.inject("avatarGroup", {});
      var avatarContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var sizeValue = vue.ref(props.size || avatarGroupProps && avatarGroupProps.size);
      var avatarClass = vue.computed(function () {
        return ["".concat(name$f), sizeValue.value ? ClASSNAMES.SIZE[sizeValue.value] : "", _defineProperty$2({}, "".concat(name$f, "--").concat(props.shape), props.shape)];
      });
      var isCustomSize = vue.computed(function () {
        return sizeValue.value && !ClASSNAMES.SIZE[sizeValue.value];
      });
      var customSize = vue.computed(function () {
        return isCustomSize.value ? {
          height: sizeValue.value,
          width: sizeValue.value
        } : {};
      });
      var handleImgLoadError = function handleImgLoadError(e) {
        emitEvent("error", e);
      };
      return _objectSpread$b(_objectSpread$b({
        name: name$f
      }, vue.toRefs(props)), {}, {
        avatarContent: avatarContent,
        iconContent: iconContent,
        avatarClass: avatarClass,
        customSize: customSize,
        handleImgLoadError: handleImgLoadError
      });
    }
  });

  var _hoisted_1$6 = ["src", "alt"];
  var _hoisted_2$3 = {
    key: 2
  };
  function render$f(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.avatarClass),
      style: vue.normalizeStyle(_ctx.customSize)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [_ctx.image && !_ctx.hideOnLoadFailed ? (vue.openBlock(), vue.createElementBlock("img", {
      key: 0,
      src: _ctx.image,
      alt: _ctx.alt,
      style: vue.normalizeStyle(_ctx.customSize),
      onError: _cache[0] || (_cache[0] = function () {
        return _ctx.handleImgLoadError && _ctx.handleImgLoadError.apply(_ctx, arguments);
      })
    }, null, 44, _hoisted_1$6)) : _ctx.iconContent !== void 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$3, [vue.createVNode(_component_t_node, {
      content: _ctx.avatarContent
    }, null, 8, ["content"])]))], 2), _ctx.badgeProps ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__badge"))
    }, [vue.createVNode(_component_t_badge, {
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset
    }, null, 8, ["count", "max-count", "dot", "content", "size", "offset"])], 2)) : vue.createCommentVNode("", true)], 6);
  }

  script$g.render = render$f;

  var AvatarGroupProps = {
    cascading: {
      type: String,
      default: "right-up",
      validator: function validator(val) {
        if (!val) return true;
        return ["left-up", "right-up"].includes(val);
      }
    },
    collapseAvatar: {
      type: [String, Function]
    },
    max: {
      type: Number
    },
    size: {
      type: String,
      default: "medium"
    }
  };

  function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$e = config.prefix;
  var name$e = "".concat(prefix$e, "-avatar-group");
  var script$f = vue.defineComponent({
    name: name$e,
    components: {
      Avatar: script$g,
      TNode: TNodeComponent
    },
    props: AvatarGroupProps,
    setup: function setup(props, _ref) {
      var slots = _ref.slots;
      vue.provide("avatarGroup", _objectSpread$a({}, props));
      var internalInstance = vue.getCurrentInstance();
      var classes = vue.computed(function () {
        var _ref2;
        return ["".concat(name$e), (_ref2 = {}, _defineProperty$2(_ref2, "".concat(prefix$e, "-avatar--offset-right"), props.cascading === "right-up"), _defineProperty$2(_ref2, "".concat(prefix$e, "-avatar--offset-left"), props.cascading === "left-up"), _ref2)];
      });
      var isShowEllipsisContent = vue.ref(false);
      var ellipsisContent = vue.ref(null);
      var size = vue.ref(props.size);
      var collapseAvatar = vue.computed(function () {
        return renderTNode(internalInstance, "collapseAvatar");
      });
      var avatarItems = function avatarItems() {
        var childContent = slots.default ? slots.default() : [];
        var children = [];
        childContent.forEach(function (child) {
          if (child.type === vue.Fragment) {
            children.push.apply(children, _toConsumableArray(child.children));
          } else {
            children.push(child);
          }
        });
        var childrenShow = [];
        var max = props.max || 0;
        if (max && max < children.length) {
          childrenShow = children.slice(0, max);
          isShowEllipsisContent.value = true;
          ellipsisContent.value = collapseAvatar.value || "+".concat(children.length - max);
        } else {
          childrenShow = children;
        }
        size.value = childrenShow[0].size || props.size;
        return childrenShow;
      };
      return {
        classes: classes,
        size: size,
        isShowEllipsisContent: isShowEllipsisContent,
        ellipsisContent: ellipsisContent,
        avatarItems: avatarItems
      };
    }
  });

  function render$e(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_avatar = vue.resolveComponent("avatar");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.avatarItems))), _ctx.isShowEllipsisContent ? (vue.openBlock(), vue.createBlock(_component_avatar, {
      key: 0,
      size: _ctx.size
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.ellipsisContent
        }, null, 8, ["content"])];
      }),
      _: 1
    }, 8, ["size"])) : vue.createCommentVNode("", true)], 2);
  }

  script$f.render = render$e;

  var Avatar = withInstall(script$g);
  var AvatarGroup = withInstall(script$f);

  var ImageProps = {
    alt: {
      type: String,
      default: ""
    },
    error: {
      type: Function
    },
    fit: {
      type: String,
      default: "fill",
      validator: function validator(val) {
        if (!val) return true;
        return ["contain", "cover", "fill", "none", "scale-down"].includes(val);
      }
    },
    lazy: Boolean,
    loading: {
      type: Function
    },
    position: {
      type: String,
      default: "center"
    },
    shape: {
      type: String,
      default: "round",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round", "square"].includes(val);
      }
    },
    src: {
      type: String,
      default: ""
    },
    onError: Function,
    onLoad: Function
  };

  var prefix$d = config.prefix;
  var name$d = "".concat(prefix$d, "-image");
  var script$e = vue.defineComponent({
    name: name$d,
    components: {
      TNode: TNodeComponent
    },
    props: ImageProps,
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var statusContent = vue.computed(function () {
        var _context$slots, _context$slots2, _context$slots3, _context$slots4;
        if ((_context$slots = context.slots) !== null && _context$slots !== void 0 && _context$slots.loading && loadingValue.value) {
          return renderTNode(internalInstance, "loading");
        }
        if (!((_context$slots2 = context.slots) !== null && _context$slots2 !== void 0 && _context$slots2.loading) && loadingValue.value) {
          return vue.h(ellipsis);
        }
        if ((_context$slots3 = context.slots) !== null && _context$slots3 !== void 0 && _context$slots3.error && errorValue.value) {
          return renderTNode(internalInstance, "error");
        }
        if (!((_context$slots4 = context.slots) !== null && _context$slots4 !== void 0 && _context$slots4.error) && errorValue.value) {
          return vue.h(close);
        }
        return "";
      });
      var loadingValue = vue.ref(true);
      var errorValue = vue.ref(false);
      var imageStyles = vue.computed(function () {
        return {
          objectFit: props.fit,
          objectPosition: props.position
        };
      });
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$d), true), _defineProperty$2(_ref, "".concat(name$d, "--").concat(props.shape), true), _ref;
      });
      var imageDOM = vue.ref();
      var realSrc = vue.ref("");
      vue.watchEffect(function () {
        realSrc.value = props.lazy ? "" : props.src;
      });
      var _useIntersectionObser = useIntersectionObserver(imageDOM, function (_ref2, observerElement) {
          var _ref3 = _slicedToArray(_ref2, 1),
            isIntersecting = _ref3[0].isIntersecting;
          if (isIntersecting && props.lazy) {
            stop();
            realSrc.value = props.src;
          }
        }),
        stop = _useIntersectionObser.stop;
      var handleImgLoadCompleted = function handleImgLoadCompleted(e) {
        emitEvent("load", e);
        loadingValue.value = false;
      };
      var handleImgLoadError = function handleImgLoadError(e) {
        if (realSrc.value === "") {
          return;
        }
        emitEvent("error", e);
        loadingValue.value = false;
        errorValue.value = true;
      };
      return {
        imageDOM: imageDOM,
        statusContent: statusContent,
        name: name$d,
        classes: classes,
        imageStyles: imageStyles,
        loadingValue: loadingValue,
        realSrc: realSrc,
        errorValue: errorValue,
        handleImgLoadCompleted: handleImgLoadCompleted,
        handleImgLoadError: handleImgLoadError
      };
    }
  });

  var _hoisted_1$5 = ["src", "alt"];
  function render$d(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.loadingValue || _ctx.errorValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__status"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.statusContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("img", {
      ref: "imageDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__img")),
      style: vue.normalizeStyle(_ctx.imageStyles),
      src: _ctx.realSrc,
      alt: _ctx.alt,
      onLoad: _cache[0] || (_cache[0] = function () {
        return _ctx.handleImgLoadCompleted && _ctx.handleImgLoadCompleted.apply(_ctx, arguments);
      }),
      onError: _cache[1] || (_cache[1] = function () {
        return _ctx.handleImgLoadError && _ctx.handleImgLoadError.apply(_ctx, arguments);
      })
    }, null, 46, _hoisted_1$5)], 2);
  }

  script$e.render = render$d;

  var _Image = withInstall(script$e);

  var props = {
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    disabled: Boolean,
    expanded: {
      type: String,
      validator: function validator(val) {
        return ["left", "right"].includes(val);
      }
    },
    left: {
      type: [Array, Function]
    },
    right: {
      type: [Array, Function]
    },
    onChange: Function,
    onClick: Function
  };

  function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$c = config.prefix;
  var name$c = "".concat(prefix$c, "-swipe-cell");
  var script$d = vue.defineComponent({
    name: name$c,
    components: {
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: props,
    emits: ["click", "change"],
    setup: function setup(props2, context) {
      var emitEvent = useEmitEvent(props2, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var swipeContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var swipeLeftMenu = vue.computed(function () {
        return renderTNode(internalInstance, "left");
      });
      var swipeRightMenu = vue.computed(function () {
        return renderTNode(internalInstance, "right");
      });
      var leftRef = vue.ref();
      var rightRef = vue.ref();
      var swipeCell = vue.ref();
      var _useSwipe = useSwipe(swipeCell, {
          threshold: 0,
          onSwipeStart: function onSwipeStart(e) {
            initData.moving = true;
            initData.pos = 0;
          },
          onSwipe: function onSwipe(e) {
            if (props2.disabled) {
              return;
            }
            if (initData.moving && initData.status === "close") {
              initData.moving = false;
            }
            var pos = 0;
            if (lengthX.value < 0) {
              if (initData.leftWidth === 0) {
                initData.moving = false;
                return;
              }
              pos = Math.min(Math.abs(lengthX.value), initData.leftWidth > 0 ? initData.leftWidth + spring : 0);
            } else {
              if (initData.rightWidth === 0) {
                initData.moving = false;
                return;
              }
              pos = Math.max(-lengthX.value, -(initData.rightWidth > 0 ? initData.rightWidth + spring : 0));
            }
            if (initData.status === "close") {
              initData.pos = pos;
            }
          },
          onSwipeEnd: function onSwipeEnd(e) {
            end();
          }
        }),
        lengthX = _useSwipe.lengthX;
      var distance = 0;
      var threshold = 0.5;
      var spring = 0;
      var initData = vue.reactive({
        moving: false,
        leftWidth: 0,
        rightWidth: 0,
        pos: 0,
        status: "close"
      });
      var classes = vue.computed(function () {
        return ["".concat(name$c)];
      });
      vue.onMounted(function () {
        var _leftRef$value, _rightRef$value;
        var leftWidth = (_leftRef$value = leftRef.value) === null || _leftRef$value === void 0 ? void 0 : _leftRef$value.clientWidth;
        var rightWidth = (_rightRef$value = rightRef.value) === null || _rightRef$value === void 0 ? void 0 : _rightRef$value.clientWidth;
        initData.leftWidth = leftWidth > 0 ? leftWidth + distance : 0;
        initData.rightWidth = rightWidth > 0 ? rightWidth + distance : 0;
        renderMenuStatus();
      });
      vue.watch(function () {
        return props2.expanded;
      }, function () {
        return renderMenuStatus();
      });
      onClickOutside(swipeCell, function (event) {
        close();
      });
      var renderMenuStatus = function renderMenuStatus() {
        if (props2.expanded && props2.expanded === "left") {
          if (initData.leftWidth) {
            open("toRight");
          }
        }
        if (props2.expanded && props2.expanded === "right") {
          if (initData.rightWidth) {
            open("toLeft");
          }
        }
      };
      var end = function end() {
        if (props2.disabled) {
          return;
        }
        if (lengthX.value < 0 && initData.pos > initData.leftWidth * threshold) {
          open("toRight");
        } else if (lengthX.value > 0 && -initData.pos > initData.rightWidth * threshold) {
          open("toLeft");
        } else {
          close("force");
        }
      };
      var open = function open(direction) {
        if (initData.status === "open") {
          return;
        }
        initData.moving = true;
        initData.status = "open";
        if (direction === "toLeft") {
          initData.pos = -initData.rightWidth;
          if (initData.rightWidth) {
            emitEvent("change", "right");
          }
        } else {
          initData.pos = initData.leftWidth;
          if (initData.leftWidth) {
            emitEvent("change", "left");
          }
        }
      };
      var close = function close(type) {
        if (initData.status === "close" && type !== "force") {
          return;
        }
        initData.moving = true;
        initData.status = "close";
        initData.pos = 0;
        emitEvent("change", void 0);
      };
      var handleClickBtn = function handleClickBtn(_ref) {
        var action = _ref.action,
          source = _ref.source;
        {
          close();
        }
        if (action.onClick) {
          action.onClick();
          return;
        }
        emitEvent("click", {
          action: action,
          source: source
        });
      };
      return _objectSpread$9(_objectSpread$9({}, vue.toRefs(props2)), {}, {
        swipeContent: swipeContent,
        swipeLeftMenu: swipeLeftMenu,
        swipeRightMenu: swipeRightMenu,
        initData: initData,
        classes: classes,
        swipeCell: swipeCell,
        leftRef: leftRef,
        rightRef: rightRef,
        handleClickBtn: handleClickBtn,
        end: end
      });
    }
  });

  function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function render$c(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes),
      onTouchend: _cache[2] || (_cache[2] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      }),
      onTouchcancel: _cache[3] || (_cache[3] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      }),
      onMouseup: _cache[4] || (_cache[4] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, _ctx.classes + "__wrapper", true), _defineProperty$2(_normalizeClass2, "moving", _ctx.initData.moving), _normalizeClass2)),
      style: vue.normalizeStyle({
        transform: "translate3d(".concat(_ctx.initData.pos, "px,0,0)")
      })
    }, [vue.createElementVNode("div", {
      ref: "leftRef",
      class: vue.normalizeClass(_ctx.classes + "__left"),
      style: vue.normalizeStyle({
        width: _ctx.initData.leftWidth ? "".concat(_ctx.initData.leftWidth, "px") : "auto"
      }),
      onTouchstartPassive: _cache[0] || (_cache[0] = vue.withModifiers(function () {}, ["stop"]))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeLeftMenu
    }, null, 8, ["content"]), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.left, function (btn, index) {
      return vue.openBlock(), vue.createBlock(_component_t_button, {
        key: index,
        class: vue.normalizeClass(btn.className || ""),
        style: vue.normalizeStyle(btn.style || "height: 100%"),
        onClick: function onClick($event) {
          return _ctx.handleClickBtn({
            action: _objectSpread$8({}, btn),
            source: "left"
          });
        }
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(btn.text), 1)];
        }),
        _: 2
      }, 1032, ["class", "style", "onClick"]);
    }), 128))], 38), vue.createElementVNode("div", {
      ref: "swipeCell",
      class: vue.normalizeClass(_ctx.classes + "__content")
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      ref: "rightRef",
      class: vue.normalizeClass(_ctx.classes + "__right"),
      style: vue.normalizeStyle({
        width: _ctx.initData.rightWidth ? "".concat(_ctx.initData.rightWidth, "px") : "auto"
      }),
      onTouchstartPassive: _cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["stop"]))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeRightMenu
    }, null, 8, ["content"]), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.right, function (btn, index) {
      return vue.openBlock(), vue.createBlock(_component_t_button, {
        key: index,
        class: vue.normalizeClass(btn.className || ""),
        style: vue.normalizeStyle(btn.style || "height: 100%"),
        onClick: function onClick($event) {
          return _ctx.handleClickBtn({
            action: _objectSpread$8({}, btn),
            source: "right"
          });
        }
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(btn.text), 1)];
        }),
        _: 2
      }, 1032, ["class", "style", "onClick"]);
    }), 128))], 38)], 6)], 34);
  }

  script$d.render = render$c;

  var SwipeCell = withInstall(script$d);

  var SkeletonProps = {
    animation: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["gradient", "flashed"].includes(val);
      }
    },
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    delay: {
      type: Number,
      default: 0
    },
    loading: {
      type: Boolean,
      default: true
    },
    rowCol: {
      type: Array
    },
    theme: {
      type: String,
      default: "text",
      validator: function validator(val) {
        if (!val) return true;
        return ["text", "avatar", "paragraph", "image"].includes(val);
      }
    }
  };

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$b = config.prefix;
  var name$b = "".concat(prefix$b, "-skeleton");
  var ThemeMap = {
    avatar: [{
      type: "circle",
      height: "64px",
      width: "64px"
    }],
    image: [{
      type: "rect",
      height: "64px",
      width: "64px"
    }],
    text: [1, [{
      width: "24%",
      height: "16px",
      marginRight: "16px"
    }, {
      width: "76%",
      height: "16px"
    }]],
    paragraph: [1, 1, 1, {
      width: "55%"
    }]
  };
  var script$c = vue.defineComponent({
    name: name$b,
    components: {
      TNode: TNodeComponent
    },
    props: SkeletonProps,
    setup: function setup(props) {
      var _toRefs = vue.toRefs(props),
        loading = _toRefs.loading,
        animation = _toRefs.animation;
      var showContent = vue.computed(function () {
        return !loading.value;
      });
      var internalInstance = vue.getCurrentInstance();
      var skeletonContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var baseClass = name$b;
      var rootClasses = vue.computed(function () {
        return ["".concat(name$b)];
      });
      var rowCols = vue.ref([]);
      vue.watchEffect(function () {
        var _props$rowCol;
        if ((_props$rowCol = props.rowCol) !== null && _props$rowCol !== void 0 && _props$rowCol.length) {
          rowCols.value = _toConsumableArray(props.rowCol);
        } else {
          rowCols.value = _toConsumableArray(ThemeMap[props.theme || "text"]);
        }
      });
      var getColItemClass = function getColItemClass(obj) {
        return ["".concat(name$b, "__col"), "".concat(name$b, "--type-").concat(obj.type || "text"), _defineProperty$2({}, "".concat(name$b, "--animation-").concat(animation.value), animation.value)];
      };
      var getColItemStyle = function getColItemStyle(obj) {
        var styleName = ["width", "height", "marginRight", "marginLeft", "margin", "size", "background", "backgroundColor", "borderRadius"];
        var style = {};
        styleName.forEach(function (name2) {
          if (name2 in obj) {
            var px = isNumber(obj[name2]) ? "".concat(obj[name2], "px") : obj[name2];
            if (name2 === "size") {
              var _ref2 = [px, px];
              style.width = _ref2[0];
              style.height = _ref2[1];
            } else {
              style[name2] = px;
            }
          }
        });
        return style;
      };
      var parsedRowcols = vue.computed(function () {
        return rowCols.value.map(function (item) {
          if (isNumber(item)) {
            return [{
              class: getColItemClass({
                type: "text"
              }),
              style: {}
            }];
          }
          if (Array.isArray(item)) {
            return item.map(function (col) {
              return _objectSpread$7(_objectSpread$7({}, col), {}, {
                class: getColItemClass(col),
                style: getColItemStyle(col)
              });
            });
          }
          var nItem = item;
          return [_objectSpread$7(_objectSpread$7({}, nItem), {}, {
            class: getColItemClass(nItem),
            style: getColItemStyle(nItem)
          })];
        });
      });
      return {
        baseClass: baseClass,
        rootClasses: rootClasses,
        parsedRowcols: parsedRowcols,
        showContent: showContent,
        skeletonContent: skeletonContent
      };
    }
  });

  function render$b(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [_ctx.showContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.skeletonContent
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.parsedRowcols.length ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__content"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.parsedRowcols, function (row, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: "row-".concat(index),
        class: vue.normalizeClass("".concat(_ctx.baseClass, "__row"))
      }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(row, function (col, idx) {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: "col-".concat(idx),
          class: vue.normalizeClass(col.class),
          style: vue.normalizeStyle(col.style)
        }, null, 6);
      }), 128))], 2);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 64))], 2);
  }

  script$c.render = render$b;

  var _Skeleton = withInstall(script$c);

  function setStyle(el, styles) {
    var keys = Object.keys(styles);
    keys.forEach(function (key) {
      el.style[key] = styles[key];
    });
  }

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function circleAdapter(circleElem) {
    var _window, _window$getComputedSt2, _window2, _window2$navigator;
    var basicStyle = {};
    if (!circleElem) {
      return;
    }
    var _window$getComputedSt = (_window = window) === null || _window === void 0 ? void 0 : (_window$getComputedSt2 = _window.getComputedStyle) === null || _window$getComputedSt2 === void 0 ? void 0 : _window$getComputedSt2.call(_window, circleElem),
      color = _window$getComputedSt.color,
      fontSize = _window$getComputedSt.fontSize;
    var ua = (_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$navigator = _window2.navigator) === null || _window2$navigator === void 0 ? void 0 : _window2$navigator.userAgent;
    var isSafari = /Safari/.test(ua) && !/Chrome/.test(ua);
    var isIosWechat = /(?=.*iPhone)[?=.*MicroMessenger]/.test(ua) && !/Chrome/.test(ua);
    if (isSafari || isIosWechat) {
      basicStyle = {
        transformOrigin: "-1px -1px",
        transform: "scale(".concat(parseInt(fontSize, 10) / 14, ")")
      };
    }
    if (color && getIEVersion() > 11) {
      var matched = color.match(/[\d.]+/g);
      var endColor = matched ? "rgba(".concat(matched[0], ", ").concat(matched[1], ", ").concat(matched[2], ", 0)") : "";
      setStyle(circleElem, _objectSpread$6(_objectSpread$6({}, basicStyle), {}, {
        background: "conic-gradient(from 90deg at 50% 50%,".concat(endColor, " 0deg, ").concat(color, " 360deg)")
      }));
    } else {
      setStyle(circleElem, _objectSpread$6(_objectSpread$6({}, basicStyle), {}, {
        background: ""
      }));
    }
  }

  var prefix$a = config.prefix;
  var name$a = "".concat(prefix$a, "-loading__gradient");
  var classname = "".concat(prefix$a, "-icon-loading");
  var script$b = vue.defineComponent({
    name: name$a,
    props: {
      style: [Object, String]
    },
    setup: function setup() {
      var classes = [name$a, classname];
      return {
        name: name$a,
        classes: classes
      };
    },
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function () {
        _this.updateColor();
      });
    },
    updated: function updated() {
      this.updateColor();
    },
    methods: {
      updateColor: function updateColor() {
        var circleElem = this.$refs.circle;
        circleAdapter(circleElem);
      }
    }
  });

  var _hoisted_1$4 = {
    x: "1",
    y: "1",
    width: "12",
    height: "12"
  };
  function render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      style: vue.normalizeStyle(_ctx.style),
      class: vue.normalizeClass(_ctx.classes),
      viewBox: "0 0 14 14",
      version: "1.1",
      width: "1em",
      height: "1em",
      xmlns: "http://www.w3.org/2000/svg"
    }, [(vue.openBlock(), vue.createElementBlock("foreignObject", _hoisted_1$4, [vue.createElementVNode("div", {
      ref: "circle",
      class: vue.normalizeClass("".concat(_ctx.name, "-conic"))
    }, null, 2)]))], 6);
  }

  script$b.render = render$a;

  var prefix$9 = config.prefix;
  var name$9 = "".concat(prefix$9, "-loading__spinner");
  var script$a = vue.defineComponent({
    name: name$9,
    props: {
      style: [Object, String]
    },
    setup: function setup() {
      return {
        name: name$9
      };
    }
  });

  function render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.name),
      style: vue.normalizeStyle(_ctx.style)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(new Array(12), function (item, index) {
      return vue.openBlock(), vue.createElementBlock("i", {
        key: index,
        class: vue.normalizeClass(["".concat(_ctx.name, "--line"), "".concat(_ctx.name, "--line-").concat(index + 1)])
      }, null, 2);
    }), 128))], 6);
  }

  script$a.render = render$9;

  var LoadingProps = {
    default: {
      type: [String, Function]
    },
    content: {
      type: [String, Function]
    },
    delay: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 800
    },
    indicator: {
      type: Boolean,
      default: true
    },
    inheritColor: Boolean,
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    loading: {
      type: Boolean,
      default: true
    },
    pause: Boolean,
    progress: {
      type: Number
    },
    reverse: Boolean,
    size: {
      type: String,
      default: "40rpx"
    },
    text: {
      type: String
    },
    theme: {
      type: String,
      default: "circular",
      validator: function validator(val) {
        if (!val) return true;
        return ["circular", "spinner", "bar", "error", "dots"].includes(val);
      }
    }
  };

  var prefix$8 = config.prefix;
  var name$8 = "".concat(prefix$8, "-loading");
  var toBarPerc = function toBarPerc(n) {
    if (!n || n <= 0) return -100;
    if (n > 1) return 0;
    return (-1 + n) * 100;
  };
  var script$9 = vue.defineComponent({
    name: name$8,
    components: {
      GradientIcon: script$b,
      SpinnerIcon: script$a,
      TNode: TNodeComponent
    },
    props: LoadingProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var delayShowLoading = vue.ref(false);
      var _toRefs = vue.toRefs(props),
        pause = _toRefs.pause;
      var countDelay = function countDelay() {
        delayShowLoading.value = false;
        var timer = setTimeout(function () {
          delayShowLoading.value = true;
          clearTimeout(timer);
        }, props.delay);
      };
      var realLoading = vue.computed(function () {
        return (!props.delay || delayShowLoading.value) && props.loading;
      });
      vue.watch(function () {
        return props.loading;
      }, function (value) {
        if (value) {
          props.delay && countDelay();
        }
      }, {
        immediate: true
      });
      var rootClass = vue.computed(function () {
        return [name$8, _defineProperty$2({}, "".concat(name$8, "--vertical"), props.layout === "vertical"), _defineProperty$2({}, "".concat(name$8, "--bar"), props.theme === "bar"), props.size ? ClASSNAMES.SIZE[props.size] : ""];
      });
      var textClass = vue.computed(function () {
        return ["".concat(name$8, "__text"), _defineProperty$2({}, "".concat(name$8, "__text--error"), props.theme === "error"), _defineProperty$2({}, "".concat(name$8, "__text--only"), !props.indicator || props.theme === "error")];
      });
      var textContent = vue.computed(function () {
        if (props.theme === "error") {
          return "\u52A0\u8F7D\u5931\u8D25";
        }
        return renderTNode(internalInstance, "text");
      });
      var defaultContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var rootStyle = vue.computed(function () {
        if (props.inheritColor) {
          return "color: inherit";
        }
        return "";
      });
      var barStyle = vue.computed(function () {
        return {
          transform: "translate3d(".concat(toBarPerc(props.progress), "%, 0px, 0px)")
        };
      });
      var animationStyle = vue.computed(function () {
        var ans = {};
        if (props.pause) {
          ans["animation-play-state"] = "paused";
        }
        if (props.reverse) {
          ans["animation-direction"] = "reverse";
        }
        if (props.duration) {
          ans["animation-duration"] = "".concat(props.duration, "ms");
        }
        return ans;
      });
      return {
        name: name$8,
        pause: pause,
        rootClass: rootClass,
        textClass: textClass,
        textContent: textContent,
        defaultContent: defaultContent,
        rootStyle: rootStyle,
        barStyle: barStyle,
        animationStyle: animationStyle,
        realLoading: realLoading
      };
    }
  });

  function render$8(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_gradient_icon = vue.resolveComponent("gradient-icon");
    var _component_spinner_icon = vue.resolveComponent("spinner-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClass),
      style: vue.normalizeStyle(_ctx.rootStyle)
    }, [_ctx.theme === "bar" && _ctx.progress && ![0, 1].includes(_ctx.progress) ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__bar")),
      style: vue.normalizeStyle(_ctx.barStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__shadow"))
    }, null, 2)], 6)) : _ctx.theme !== "bar" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.indicator && _ctx.realLoading ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [_ctx.theme === "circular" ? (vue.openBlock(), vue.createBlock(_component_gradient_icon, {
      key: 0,
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 8, ["style"])) : _ctx.theme === "spinner" ? (vue.openBlock(), vue.createBlock(_component_spinner_icon, {
      key: 1,
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 8, ["style"])) : _ctx.theme === "dots" ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__dots")),
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 6)) : vue.createCommentVNode("", true)], 64)) : vue.createCommentVNode("", true), _ctx.textContent && _ctx.realLoading ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass(_ctx.textClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.textContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.defaultContent
    }, null, 8, ["content"])], 64)) : vue.createCommentVNode("", true)], 6);
  }

  script$9.render = render$8;

  var _Loading = withInstall(script$9);

  var ListProps = {
    asyncLoading: {
      type: [String, Function]
    },
    footer: {
      type: [String, Function]
    },
    header: {
      type: [String, Function]
    },
    onLoadMore: Function,
    onScroll: Function
  };

  var prefix$7 = config.prefix;
  var name$7 = "".concat(prefix$7, "-list");
  var LOADING_TEXT_MAP = {
    loading: "\u52A0\u8F7D\u4E2D...",
    "load-more": "\u70B9\u51FB\u52A0\u8F7D\u66F4\u591A"
  };
  var script$8 = vue.defineComponent({
    name: name$7,
    components: {
      TLoading: _Loading,
      TNode: TNodeComponent
    },
    props: ListProps,
    emits: ["load-more", "scroll"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var root = vue.ref();
      var empty = vue.ref();
      var scrollParent = useScrollParent(root);
      var _useWindowSize = useWindowSize(),
        height = _useWindowSize.height;
      var internalInstance = vue.getCurrentInstance();
      var headerContent = vue.computed(function () {
        return renderTNode(internalInstance, "header");
      });
      var footerContent = vue.computed(function () {
        return renderTNode(internalInstance, "footer");
      });
      var onLoadMore = function onLoadMore(e) {
        if (props.asyncLoading === "load-more") {
          emitEvent("load-more");
        }
      };
      var handleScroll = function handleScroll(e) {
        var _useElementBounding = useElementBounding(root),
          bottom = _useElementBounding.bottom;
        emitEvent("scroll", bottom.value - height.value);
      };
      useEventListener(scrollParent, "scroll", handleScroll);
      return {
        name: name$7,
        root: root,
        empty: empty,
        onLoadMore: onLoadMore,
        handleScroll: handleScroll,
        headerContent: headerContent,
        footerContent: footerContent,
        LOADING_TEXT_MAP: LOADING_TEXT_MAP
      };
    }
  });

  function render$7(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_loading = vue.resolveComponent("t-loading");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "root",
      class: vue.normalizeClass(_ctx.name),
      onScroll: _cache[1] || (_cache[1] = function () {
        return _ctx.handleScroll && _ctx.handleScroll.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.headerContent
    }, null, 8, ["content"]), vue.renderSlot(_ctx.$slots, "default"), vue.createElementVNode("div", {
      onClick: _cache[0] || (_cache[0] = vue.withModifiers(function () {
        return _ctx.onLoadMore && _ctx.onLoadMore.apply(_ctx, arguments);
      }, ["stop"]))
    }, [typeof _ctx.asyncLoading === "string" && ["loading", "load-more"].includes(_ctx.asyncLoading) ? (vue.openBlock(), vue.createBlock(_component_t_loading, {
      key: 0,
      loading: _ctx.asyncLoading === "loading",
      text: typeof _ctx.asyncLoading === "string" ? _ctx.LOADING_TEXT_MAP[_ctx.asyncLoading] : "",
      class: vue.normalizeClass("".concat(_ctx.name, "__loading"))
    }, null, 8, ["loading", "text", "class"])) : vue.createCommentVNode("", true)]), vue.createVNode(_component_t_node, {
      content: _ctx.footerContent
    }, null, 8, ["content"])], 34);
  }

  script$8.render = render$7;

  var _List = withInstall(script$8);

  var BackTopProps = {
    fixed: {
      type: Boolean,
      default: true
    },
    icon: {
      type: Function,
      default: "backtop"
    },
    target: {
      type: Function
    },
    text: {
      type: String,
      default: ""
    },
    theme: {
      type: String,
      default: "round",
      validator: function validator(val) {
        if (!val) return true;
        return ["round", "half-round", "round-dark", "half-round-dark"].includes(val);
      }
    },
    onToTop: Function
  };

  var prefix$6 = config.prefix;
  var name$6 = "".concat(prefix$6, "-back-top");
  var script$7 = vue.defineComponent({
    name: name$6,
    components: {
      TNode: TNodeComponent,
      TIconBackTop: backtop
    },
    props: BackTopProps,
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var el = vue.computed(function () {
        return props.target ? props.target() : window.document.documentElement;
      });
      var _useElementBounding = useElementBounding(el),
        top = _useElementBounding.top;
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$6), true), _defineProperty$2(_ref, "".concat(prefix$6, "-is-fixed"), props.fixed), _defineProperty$2(_ref, "".concat(name$6, "--").concat(props.theme), true), _ref;
      });
      var internalInstance = vue.getCurrentInstance();
      var iconTNode = vue.computed(function () {
        var _context$slots;
        if ((_context$slots = context.slots) !== null && _context$slots !== void 0 && _context$slots.icon || typeof props.icon === "function") {
          return renderTNode(internalInstance, "icon");
        }
        return false;
      });
      var clickBackBtn = function clickBackBtn() {
        window.document.documentElement.scrollTop += top.value;
        emitEvent("to-top");
      };
      return {
        name: name$6,
        classes: classes,
        iconTNode: iconTNode,
        el: el,
        top: top,
        clickBackBtn: clickBackBtn
      };
    }
  });

  function render$6(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_icon_back_top = vue.resolveComponent("t-icon-back-top");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.clickBackBtn && _ctx.clickBackBtn.apply(_ctx, arguments);
      })
    }, [_ctx.iconTNode ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.iconTNode
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_t_icon_back_top, {
      key: 1
    })), _ctx.text ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, vue.toDisplayString(_ctx.text), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$7.render = render$6;

  var _BackTop = withInstall(script$7);

  var PullDownRefreshProps = {
    loadingBarHeight: {
      type: [String, Number],
      default: 50
    },
    loadingProps: {
      type: Object
    },
    loadingTexts: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    maxBarHeight: {
      type: [String, Number],
      default: 80
    },
    refreshTimeout: {
      type: Number,
      default: 3e3
    },
    value: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultValue: Boolean,
    onChange: Function,
    onRefresh: Function,
    onTimeout: Function
  };

  var isElement = function isElement(node) {
    var ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  };
  function useTouch() {
    var startY = vue.ref(0);
    var deltaY = vue.ref(0);
    var start = function start(event) {
      startY.value = event.touches[0].clientY;
      deltaY.value = 0;
    };
    var move = function move(event) {
      var touch = event.touches[0];
      deltaY.value = touch.clientY - startY.value;
    };
    return {
      startY: startY,
      deltaY: deltaY,
      start: start,
      move: move
    };
  }
  var easeDistance = function easeDistance(distance, pullDistance) {
    if (distance > pullDistance) {
      if (distance < pullDistance * 2) {
        distance = pullDistance + (distance - pullDistance) / 2;
      } else {
        distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
      }
    }
    return Math.round(distance);
  };
  var getScrollParent = function getScrollParent(node) {
    var res = node;
    while (res && isElement(res)) {
      if (/auto|scroll/i.test(window.getComputedStyle(res).overflowY)) {
        return res;
      }
      res = res.parentNode;
    }
  };
  var isReachTop = function isReachTop(e) {
    var scrollParent = getScrollParent(e.target);
    return !scrollParent || !scrollParent.scrollTop;
  };

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$5 = config.prefix;
  var name$5 = "".concat(prefix$5, "-pull-down-refresh");
  var ANIMATION_DURATION = 300;
  var statusName = ["pulling", "loosing", "loading", "success", "initial"];
  var script$6 = vue.defineComponent({
    name: name$5,
    components: {
      TLoading: _Loading
    },
    props: PullDownRefreshProps,
    emits: ["refresh", "timeout", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var _props$loadingTexts;
      var emitEvent = useEmitEvent(props, context.emit);
      var trackStyle = vue.computed(function () {
        return {
          transitionDuration: "".concat(ANIMATION_DURATION, "ms"),
          transform: "translate3d(0, ".concat(distance.value, "px, 0)")
        };
      });
      var loadingBarStyles = vue.computed(function () {
        return {
          height: typeof props.loadingBarHeight === "number" ? "".concat(props.loadingBarHeight, "px") : props.loadingBarHeight
        };
      });
      var maxBarStyles = vue.computed(function () {
        return {
          height: typeof props.maxBarHeight === "number" ? "".concat(props.maxBarHeight, "px") : props.maxBarHeight
        };
      });
      var loadingIconProps = vue.computed(function () {
        return _objectSpread$5({}, props.loadingProps);
      });
      var isLoading = vue.ref(false);
      var distance = vue.ref(0);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        statusValue = _useVModel2[0],
        setStatusValue = _useVModel2[1];
      var status = vue.computed(function () {
        if (!statusValue.value && isLoading.value) {
          return "success";
        }
        if (!statusValue.value || distance.value === 0) {
          return "initial";
        }
        if (distance.value < loadingBarHeight.value) {
          return "pulling";
        }
        if (isLoading.value) {
          return "loading";
        }
        return "loosing";
      });
      vue.watch(status, function (newVal) {
        if (newVal === "success" || newVal === "initial") {
          setTimeout(function () {
            distance.value = 0;
            isLoading.value = false;
          }, 300);
        }
      });
      var loadingTexts = vue.ref((_props$loadingTexts = props.loadingTexts) !== null && _props$loadingTexts !== void 0 && _props$loadingTexts.length ? props.loadingTexts : ["\u4E0B\u62C9\u5237\u65B0", "\u677E\u624B\u5237\u65B0", "\u6B63\u5728\u5237\u65B0", "\u5237\u65B0\u5B8C\u6210"]);
      var loadingText = vue.computed(function () {
        var index = statusName.indexOf(status.value);
        return index >= 0 ? loadingTexts.value[index] : "";
      });
      var touch = useTouch();
      var loadingBar = vue.ref(null);
      var maxBar = vue.ref(null);
      var _useElementSize = useElementSize(loadingBar),
        loadingBarHeight = _useElementSize.height;
      var _useElementSize2 = useElementSize(maxBar),
        maxBarHeight = _useElementSize2.height;
      var onTouchStart = function onTouchStart(e) {
        if (!isReachTop(e) || isLoading.value) return;
        setStatusValue(true);
        distance.value = 0;
        touch.start(e);
      };
      var onTouchMove = function onTouchMove(e) {
        if (!isReachTop(e) || isLoading.value) return;
        var deltaY = touch.deltaY;
        var nextDistance = easeDistance(deltaY.value, loadingBarHeight.value);
        if (deltaY.value > 0) {
          e.preventDefault();
        }
        if (nextDistance >= 0 && nextDistance < maxBarHeight.value) {
          distance.value = nextDistance;
        }
        touch.move(e);
      };
      var timer = null;
      var onTouchEnd = function onTouchEnd(e) {
        if (!isReachTop(e) || isLoading.value) return;
        if (status.value === "loosing") {
          distance.value = loadingBarHeight.value;
          isLoading.value = true;
          emitEvent("refresh");
          timer = setTimeout(function () {
            if (isLoading.value) {
              emitEvent("timeout");
              setStatusValue(false);
            }
          }, props.refreshTimeout);
        } else {
          setStatusValue(false);
        }
      };
      vue.onUnmounted(function () {
        clearTimeout(timer);
      });
      return {
        name: name$5,
        status: status,
        trackStyle: trackStyle,
        loadingText: loadingText,
        maxBarStyles: maxBarStyles,
        loadingBarStyles: loadingBarStyles,
        loadingIconProps: loadingIconProps,
        loadingBar: loadingBar,
        maxBar: maxBar,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd
      };
    }
  });

  var _hoisted_1$3 = {
    key: 0
  };
  var _hoisted_2$2 = {
    key: 1
  };
  function render$5(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_loading = vue.resolveComponent("t-loading");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__track")),
      style: vue.normalizeStyle(_ctx.trackStyle),
      onTouchstart: _cache[0] || (_cache[0] = vue.withModifiers(function () {
        return _ctx.onTouchStart && _ctx.onTouchStart.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchmove: _cache[1] || (_cache[1] = vue.withModifiers(function () {
        return _ctx.onTouchMove && _ctx.onTouchMove.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchend: _cache[2] || (_cache[2] = vue.withModifiers(function () {
        return _ctx.onTouchEnd && _ctx.onTouchEnd.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchcancel: _cache[3] || (_cache[3] = vue.withModifiers(function () {
        return _ctx.onTouchEnd && _ctx.onTouchEnd.apply(_ctx, arguments);
      }, ["stop"]))
    }, [vue.createElementVNode("div", {
      ref: "maxBar",
      class: vue.normalizeClass("".concat(_ctx.name, "__max")),
      style: vue.normalizeStyle(_ctx.maxBarStyles)
    }, [vue.createElementVNode("div", {
      ref: "loadingBar",
      class: vue.normalizeClass("".concat(_ctx.name, "__loading")),
      style: vue.normalizeStyle(_ctx.loadingBarStyles)
    }, [_ctx.status === "loading" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [vue.createVNode(_component_t_loading, vue.mergeProps({
      text: _ctx.loadingText,
      class: "".concat(_ctx.name, "__loading-icon")
    }, _ctx.loadingIconProps), null, 16, ["text", "class"])])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$2, vue.toDisplayString(_ctx.loadingText), 1))], 6)], 6), vue.renderSlot(_ctx.$slots, "default")], 38)], 2);
  }

  script$6.render = render$5;

  var _PullDownRefresh = withInstall(script$6);

  var ListCache$2 = _ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear$1() {
    this.__data__ = new ListCache$2();
    this.size = 0;
  }
  var _stackClear = stackClear$1;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete$1(key) {
    var data = this.__data__,
      result = data['delete'](key);
    this.size = data.size;
    return result;
  }
  var _stackDelete = stackDelete$1;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet$1(key) {
    return this.__data__.get(key);
  }
  var _stackGet = stackGet$1;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas$1(key) {
    return this.__data__.has(key);
  }
  var _stackHas = stackHas$1;

  var ListCache$1 = _ListCache,
    Map$1 = _Map,
    MapCache$1 = _MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet$1(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$1) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache$1(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  var _stackSet = stackSet$1;

  var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack$2(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack$2.prototype.clear = stackClear;
  Stack$2.prototype['delete'] = stackDelete;
  Stack$2.prototype.get = stackGet;
  Stack$2.prototype.has = stackHas;
  Stack$2.prototype.set = stackSet;
  var _Stack = Stack$2;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  var _arraySome = arraySome$1;

  var SetCache = _SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
        othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }
  var _equalArrays = equalArrays$2;

  var root$4 = _root;

  /** Built-in value references. */
  var Uint8Array$1 = root$4.Uint8Array;
  var _Uint8Array = Uint8Array$1;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray$1(map) {
    var index = -1,
      result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  var _mapToArray = mapToArray$1;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray$1(set) {
    var index = -1,
      result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  var _setToArray = setToArray$1;

  var _Symbol = _Symbol$4,
    Uint8Array = _Uint8Array,
    eq = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray = _setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);
      case errorTag$1:
        return object.name == other.name && object.message == other.message;
      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';
      case mapTag$2:
        var convert = mapToArray;
      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var _equalByTag = equalByTag$1;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush$1(array, values) {
    var index = -1,
      length = values.length,
      offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var _arrayPush = arrayPush$1;

  var arrayPush = _arrayPush,
    isArray$6 = isArray_1;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$6(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  var _baseGetAllKeys = baseGetAllKeys$1;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var _arrayFilter = arrayFilter$1;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray$1() {
    return [];
  }
  var stubArray_1 = stubArray$1;

  var arrayFilter = _arrayFilter,
    stubArray = stubArray_1;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols$1 = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols$1;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes$1(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var _baseTimes = baseTimes$1;

  var baseGetTag$2 = _baseGetTag,
    isObjectLike$3 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$1(value) {
    return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
  }
  var _baseIsArguments = baseIsArguments$1;

  var baseIsArguments = _baseIsArguments,
    isObjectLike$2 = isObjectLike_1;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$2 = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike$2(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments$2;

  var isBuffer$2 = {exports: {}};

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }
  var stubFalse_1 = stubFalse;

  (function (module, exports) {
    var root = _root,
      stubFalse = stubFalse_1;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  })(isBuffer$2, isBuffer$2.exports);

  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$2(value, length) {
    var type = _typeof$1(value);
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  var _isIndex = isIndex$2;

  var baseGetTag$1 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$1 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    weakMapTag$1 = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$1(value) {
    return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
  }
  var _baseIsTypedArray = baseIsTypedArray$1;

  var _nodeUtil = {exports: {}};

  (function (module, exports) {
    var freeGlobal = _freeGlobal;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);

  var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var isTypedArray_1 = isTypedArray$2;

  var baseTimes = _baseTimes,
    isArguments$1 = isArguments_1,
    isArray$5 = isArray_1,
    isBuffer$1 = isBuffer$2.exports,
    isIndex$1 = _isIndex,
    isTypedArray$1 = isTypedArray_1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$1(value, inherited) {
    var isArr = isArray$5(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (
      // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' ||
      // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') ||
      // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
      // Skip index properties.
      isIndex$1(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var _arrayLikeKeys = arrayLikeKeys$1;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$1(value) {
    var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$3;
    return value === proto;
  }
  var _isPrototype = isPrototype$1;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg$1(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  var _overArg = overArg$1;

  var overArg = _overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys$1 = overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys$1;

  var isPrototype = _isPrototype,
    nativeKeys = _nativeKeys;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys$1(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }
  var _baseKeys = baseKeys$1;

  var arrayLikeKeys = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike = isArrayLike_1;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var keys_1 = keys$2;

  var baseGetAllKeys = _baseGetAllKeys,
    getSymbols = _getSymbols,
    keys$1 = keys_1;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys$1(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }
  var _getAllKeys = getAllKeys$1;

  var getAllKeys = _getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
        othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
        othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }
  var _equalObjects = equalObjects$1;

  var getNative$3 = _getNative,
    root$3 = _root;

  /* Built-in method references that are verified to be native. */
  var DataView$1 = getNative$3(root$3, 'DataView');
  var _DataView = DataView$1;

  var getNative$2 = _getNative,
    root$2 = _root;

  /* Built-in method references that are verified to be native. */
  var Promise$2 = getNative$2(root$2, 'Promise');
  var _Promise = Promise$2;

  var getNative$1 = _getNative,
    root$1 = _root;

  /* Built-in method references that are verified to be native. */
  var Set$2 = getNative$1(root$1, 'Set');
  var _Set = Set$2;

  var getNative = _getNative,
    root = _root;

  /* Built-in method references that are verified to be native. */
  var WeakMap$1 = getNative(root, 'WeakMap');
  var _WeakMap = WeakMap$1;

  var DataView = _DataView,
    Map = _Map,
    Promise$1 = _Promise,
    Set$1 = _Set,
    WeakMap = _WeakMap,
    baseGetTag = _baseGetTag,
    toSource = _toSource;

  /** `Object#toString` result references. */
  var mapTag = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag$1 = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag$1(new Map()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
    getTag$1 = function getTag(value) {
      var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var _getTag = getTag$1;

  var Stack$1 = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag = _getTag,
    isArray$4 = isArray_1,
    isBuffer = isBuffer$2.exports,
    isTypedArray = isTypedArray_1;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$4(object),
      othIsArr = isArray$4(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack$1());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack$1());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack$1());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  var _baseIsEqualDeep = baseIsEqualDeep$1;

  var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike = isObjectLike_1;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual$2(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
  }
  var _baseIsEqual = baseIsEqual$2;

  var Stack = _Stack,
    baseIsEqual$1 = _baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch$1(object, source, matchData, customizer) {
    var index = matchData.length,
      length = index,
      noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
        objValue = object[key],
        srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var _baseIsMatch = baseIsMatch$1;

  var isObject$1 = isObject_1;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable$2(value) {
    return value === value && !isObject$1(value);
  }
  var _isStrictComparable = isStrictComparable$2;

  var isStrictComparable$1 = _isStrictComparable,
    keys = keys_1;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData$1(object) {
    var result = keys(object),
      length = result.length;
    while (length--) {
      var key = result[length],
        value = object[key];
      result[length] = [key, value, isStrictComparable$1(value)];
    }
    return result;
  }
  var _getMatchData = getMatchData$1;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable$2(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }
  var _matchesStrictComparable = matchesStrictComparable$2;

  var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches$1(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  var _baseMatches = baseMatches$1;

  var isArray$3 = isArray_1,
    isSymbol$2 = isSymbol_1;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey$3(value, object) {
    if (isArray$3(value)) {
      return false;
    }
    var type = _typeof$1(value);
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var _isKey = isKey$3;

  var MapCache = _MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function memoized() {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache;
  var memoize_1 = memoize$1;

  var memoize = memoize_1;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped$1(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var _memoizeCapped = memoizeCapped$1;

  var memoizeCapped = _memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath$1 = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  var _stringToPath = stringToPath$1;

  var isArray$2 = isArray_1,
    isKey$2 = _isKey,
    stringToPath = _stringToPath,
    toString = toString_1;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath$2(value, object) {
    if (isArray$2(value)) {
      return value;
    }
    return isKey$2(value, object) ? [value] : stringToPath(toString(value));
  }
  var _castPath = castPath$2;

  var isSymbol$1 = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey$4(value) {
    if (typeof value == 'string' || isSymbol$1(value)) {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }
  var _toKey = toKey$4;

  var castPath$1 = _castPath,
    toKey$3 = _toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet$2(object, path) {
    path = castPath$1(path, object);
    var index = 0,
      length = path.length;
    while (object != null && index < length) {
      object = object[toKey$3(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  var _baseGet = baseGet$2;

  var baseGet$1 = _baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get$1(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet$1(object, path);
    return result === undefined ? defaultValue : result;
  }
  var get_1 = get$1;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn$1(object, key) {
    return object != null && key in Object(object);
  }
  var _baseHasIn = baseHasIn$1;

  var castPath = _castPath,
    isArguments = isArguments_1,
    isArray$1 = isArray_1,
    isIndex = _isIndex,
    isLength = isLength_1,
    toKey$2 = _toKey;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath$1(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
      length = path.length,
      result = false;
    while (++index < length) {
      var key = toKey$2(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray$1(object) || isArguments(object));
  }
  var _hasPath = hasPath$1;

  var baseHasIn = _baseHasIn,
    hasPath = _hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn$1(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var hasIn_1 = hasIn$1;

  var baseIsEqual = _baseIsEqual,
    get = get_1,
    hasIn = hasIn_1,
    isKey$1 = _isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$1 = _toKey;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty$1(path, srcValue) {
    if (isKey$1(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey$1(path), srcValue);
    }
    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  var _baseMatchesProperty = baseMatchesProperty$1;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty$1(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }
  var _baseProperty = baseProperty$1;

  var baseGet = _baseGet;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep$1(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }
  var _basePropertyDeep = basePropertyDeep$1;

  var baseProperty = _baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _isKey,
    toKey = _toKey;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property$1(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  var property_1 = property$1;

  var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity = identity_1,
    isArray = isArray_1,
    property = property_1;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee$1(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (_typeof$1(value) == 'object') {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  var _baseIteratee = baseIteratee$1;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex$1(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }
  var _trimmedEndIndex = trimmedEndIndex$1;

  var trimmedEndIndex = _trimmedEndIndex;

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim$1(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
  }
  var _baseTrim = baseTrim$1;

  var baseTrim = _baseTrim,
    isObject = isObject_1,
    isSymbol = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_1 = toNumber$1;

  var toNumber = toNumber_1;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite$1(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  var toFinite_1 = toFinite$1;

  var toFinite = toFinite_1;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger$1(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toInteger_1 = toInteger$1;

  var baseFindIndex = _baseFindIndex,
    baseIteratee = _baseIteratee,
    toInteger = toInteger_1;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index);
  }
  var findIndex_1 = findIndex;

  function getCurrentDate() {
    var needTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var d = new Date();
    var month = d.getMonth() + 1;
    month = month < 10 ? "0".concat(month) : month;
    var date = "".concat(d.getFullYear(), "-").concat(month, "-").concat(d.getDate());
    var time = "".concat(d.getHours(), ":").concat(d.getMinutes(), ":").concat(d.getSeconds());
    if (needTime) return [date, time].join(" ");
    return date;
  }

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function xhr(_ref) {
    var _files$;
    var _ref$method = _ref.method,
      method = _ref$method === void 0 ? "POST" : _ref$method,
      action = _ref.action,
      _ref$withCredentials = _ref.withCredentials,
      withCredentials = _ref$withCredentials === void 0 ? false : _ref$withCredentials,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      _ref$data = _ref.data,
      data = _ref$data === void 0 ? {} : _ref$data,
      file = _ref.file,
      _ref$files = _ref.files,
      files = _ref$files === void 0 ? [] : _ref$files,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? "file" : _ref$name,
      _ref$useMockProgress = _ref.useMockProgress,
      useMockProgress = _ref$useMockProgress === void 0 ? true : _ref$useMockProgress,
      formatRequest = _ref.formatRequest,
      onError = _ref.onError,
      onProgress = _ref.onProgress,
      onSuccess = _ref.onSuccess;
    var innerFiles = files || [];
    var percent = 0;
    var xhr2 = new XMLHttpRequest();
    if (withCredentials) {
      xhr2.withCredentials = true;
    }
    var timer1;
    var timer2;
    if (useMockProgress && ((_files$ = files[0]) === null || _files$ === void 0 ? void 0 : _files$.status) === "progress") {
      var timer22 = setTimeout(function () {
        timer1 = setInterval(function () {
          if (percent + 10 < 100) {
            percent = Math.max(percent + 10, percent);
            if (files[0] && percent !== files[0].percent) {
              files[0].percent = percent;
              onProgress({
                percent: percent,
                file: file || innerFiles[0],
                files: innerFiles.map(function (file2) {
                  return _objectSpread$4(_objectSpread$4({}, file2), {}, {
                    percent: percent
                  });
                }),
                type: "mock"
              });
            }
          } else {
            clearInterval(timer1);
          }
        }, 300);
        clearTimeout(timer22);
      }, 300);
    }
    var requestData = {};
    if (data) {
      var extraData = typeof data === "function" ? data(file) : data;
      Object.assign(requestData, extraData);
    }
    innerFiles.forEach(function (file2, index) {
      var fileField = innerFiles.length > 1 ? "".concat(name, "[").concat(index, "]") : name;
      requestData[fileField] = file2.raw;
      requestData[name] = file2.raw;
    });
    if (formatRequest) {
      requestData = formatRequest(requestData);
    }
    var formData = new FormData();
    Object.keys(requestData).forEach(function (key) {
      formData.append(key, requestData[key]);
    });
    xhr2.open(method, action, true);
    Object.keys(headers).forEach(function (key) {
      xhr2.setRequestHeader(key, headers[key]);
    });
    xhr2.onerror = function (event) {
      onError({
        event: event,
        file: file,
        files: innerFiles
      });
      clearInterval(timer1);
      clearTimeout(timer2);
    };
    if (xhr2.upload) {
      xhr2.upload.onprogress = function (event) {
        var _innerFiles$;
        var realPercent = 0;
        if (event.total > 0) {
          realPercent = Math.round(event.loaded / event.total * 100);
        }
        percent = Math.max(realPercent, percent);
        if (percent !== realPercent && ((_innerFiles$ = innerFiles[0]) === null || _innerFiles$ === void 0 ? void 0 : _innerFiles$.percent) !== percent) {
          var progressFiles = innerFiles.map(function (item) {
            return _objectSpread$4(_objectSpread$4({}, item), {}, {
              percent: percent
            });
          });
          onProgress({
            event: event,
            percent: percent,
            file: file || progressFiles[0],
            files: progressFiles,
            type: "real"
          });
        }
      };
    }
    xhr2.onload = function (event) {
      var response = {};
      var isFail = xhr2.status < 200 || xhr2.status >= 300;
      if (isFail) {
        return onError({
          event: event,
          file: file,
          files: innerFiles,
          response: response
        });
      }
      var text = xhr2.responseText || xhr2.response;
      try {
        response = JSON.parse(text);
      } catch (e) {
        response = text;
      }
      clearInterval(timer1);
      clearTimeout(timer2);
      innerFiles.forEach(function (file2) {
        var _response;
        file2.percent = 100;
        file2.status = "success";
        file2.uploadTime = ((_response = response) === null || _response === void 0 ? void 0 : _response.uploadTime) || getCurrentDate();
      });
      onSuccess({
        event: event,
        file: file || innerFiles[0],
        files: _toConsumableArray(innerFiles),
        response: response
      });
    };
    xhr2.send(formData);
    return xhr2;
  }

  var UploadProps = {
    accept: {
      type: String,
      default: ""
    },
    action: {
      type: String,
      default: ""
    },
    allowUploadDuplicateFile: Boolean,
    autoUpload: {
      type: Boolean,
      default: true
    },
    beforeUpload: {
      type: Function
    },
    data: {
      type: Object
    },
    deleteBtn: {
      type: [String, Function]
    },
    disabled: Boolean,
    fileListDisplay: {
      type: Function
    },
    files: {
      type: Array
    },
    defaultFiles: {
      type: Array
    },
    format: {
      type: Function
    },
    formatResponse: {
      type: Function
    },
    gridConfig: {
      type: Object
    },
    headers: {
      type: Object
    },
    imageProps: {
      type: Object
    },
    max: {
      type: Number,
      default: 0
    },
    method: {
      type: String,
      default: "POST",
      validator: function validator(val) {
        if (!val) return true;
        return ["POST", "GET", "PUT", "OPTION", "PATCH", "post", "get", "put", "option", "patch"].includes(val);
      }
    },
    multiple: Boolean,
    requestMethod: {
      type: Function
    },
    sizeLimit: {
      type: [Number, Object]
    },
    trigger: {
      type: [String, Function]
    },
    useMockProgress: {
      type: Boolean,
      default: true
    },
    withCredentials: Boolean,
    onCancelUpload: Function,
    onChange: Function,
    onFail: Function,
    onPreview: Function,
    onProgress: Function,
    onRemove: Function,
    onSelectChange: Function,
    onSuccess: Function
  };

  var SIZE_MAP = {
    B: 1024,
    KB: 1,
    MB: 1048576,
    GB: 1073741824
  };
  function isOverSizeLimit(fileSize, sizeLimit, unit) {
    var units = ["B", "KB", "MB", "GB"];
    var KB_INDEX = 1;
    var index = units.indexOf(unit);
    if (index === -1) {
      console.warn("TDesign Upload Warn: `sizeLimit.unit` can only be one of ".concat(units.join()));
      index = KB_INDEX;
    }
    var num = SIZE_MAP[unit];
    var limit = index < KB_INDEX ? sizeLimit / num : sizeLimit * num;
    return fileSize <= limit;
  }

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$4 = config.prefix;
  var name$4 = "".concat(prefix$4, "-upload");
  var script$5 = vue.defineComponent({
    name: name$4,
    components: {
      AddIcon: add,
      TNode: TNodeComponent,
      CloseIcon: close,
      RefreshIcon: refresh,
      TImageViewer: _ImageViewer
    },
    props: UploadProps,
    emits: ["update:files", "update:modelValue", "change", "fail", "preview", "progress", "remove", "success", "select-change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "files", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerFiles = _useDefault2[0],
        setInnerFiles = _useDefault2[1];
      var internalInstance = vue.getCurrentInstance();
      var defaultContent = vue.computed(function () {
        return renderTNode(internalInstance, "default");
      });
      var deleteBtnContent = vue.computed(function () {
        return renderTNode(internalInstance, "deleteBtn");
      });
      var images = vue.ref([]);
      var showViewer = vue.ref(false);
      var initialIndex = vue.ref(0);
      var UPLOAD_NAME = name$4;
      var xhrReq = vue.ref(null);
      var toUploadFiles = vue.ref([]);
      var uploadedFiles = vue.computed(function () {
        if (innerFiles.value && isArray$a(innerFiles.value)) {
          return innerFiles.value.filter(function (file) {
            return file.status === "success" || file.status === "fail";
          });
        }
        return [];
      });
      var errorMsg = vue.ref("");
      var inputRef = vue.ref(null);
      var itemStyle = vue.computed(function () {
        var _toRefs = vue.toRefs(props),
          gridConfig = _toRefs.gridConfig;
        var column = 4;
        if (isObject$5(gridConfig.value)) {
          column = gridConfig.value.column;
        }
        return {
          flexBasis: "".concat(100 / +column, "%")
        };
      });
      var itemContentStyle = vue.computed(function () {
        var width = 80;
        var height = 80;
        var _toRefs2 = vue.toRefs(props),
          gridConfig = _toRefs2.gridConfig;
        if (isObject$5(gridConfig.value)) {
          var _gridConfig$value = gridConfig.value;
          width = _gridConfig$value.width;
          height = _gridConfig$value.height;
        }
        return {
          height: "".concat(height, "px"),
          width: "".concat(width, "px")
        };
      });
      var triggerUpload = function triggerUpload() {
        var input = inputRef.value;
        if (props.disabled) return;
        input.click();
      };
      var handlePreview = function handlePreview(e, file) {
        showViewer.value = true;
        emitEvent("preview", {
          e: e,
          file: file
        });
      };
      var handleReload = function handleReload(file) {
        uploadFiles([file.fileRaw]);
      };
      var handleChange = function handleChange() {
        var input = inputRef.value;
        if (props.disabled || !input || !input.files) return;
        var formatFiles = formatFileToUploadFile(input.files);
        emitEvent("select-change", _toConsumableArray(formatFiles));
        uploadFiles(formatFiles);
        input.value = "";
      };
      var formatFileToUploadFile = function formatFileToUploadFile(files) {
        var format = props.format;
        if (!format || !isFunction$3(format)) {
          var res = [];
          for (var i = 0; i < files.length; i++) {
            res.push(files[i]);
          }
          return res;
        }
        var NewFiles = _toConsumableArray(files);
        NewFiles.forEach(function (item) {
          item = format(item);
        });
        return NewFiles;
      };
      var handleBeforeUpload = function handleBeforeUpload(file) {
        if (props.beforeUpload && isFunction$3(props.beforeUpload)) {
          var beforeUpload = props.beforeUpload(file);
          if (beforeUpload instanceof Promise) return beforeUpload;
          return Promise.resolve(beforeUpload);
        }
        return new Promise(function (resolve) {
          if (props.sizeLimit) {
            resolve(handleSizeLimit(file.size));
          }
          resolve(true);
        });
      };
      var handleSizeLimit = function handleSizeLimit(fileSize) {
        var sizeLimit;
        if (typeof props.sizeLimit === "number") {
          sizeLimit = {
            size: props.sizeLimit,
            unit: "KB"
          };
        } else if (_typeof$1(props.sizeLimit) === "object") {
          sizeLimit = props.sizeLimit;
        } else {
          sizeLimit = {
            size: 0,
            unit: "KB"
          };
        }
        var isOverSize = isOverSizeLimit(fileSize, sizeLimit.size, sizeLimit.unit);
        if (isOverSize) {
          errorMsg.value = sizeLimit.message ? sizeLimit.message : "TDesign Upoad Error: uploaded picture exceeds ".concat(props.sizeLimit).concat(sizeLimit.unit, " restrictions");
        }
        return isOverSize;
      };
      var uploadFiles = function uploadFiles(files) {
        var _toRefs3 = vue.toRefs(props),
          max = _toRefs3.max;
        var tmpFiles = _toConsumableArray(files);
        if (max.value) {
          tmpFiles = tmpFiles.slice(0, max.value - uploadedFiles.value.length);
          if (tmpFiles.length !== files.length) {
            console.warn("TDesign Upload Warn: you can only upload ".concat(max.value, " files"));
          }
        }
        tmpFiles.forEach(function (fileRaw) {
          var uploadFile = _objectSpread$3(_objectSpread$3({}, fileRaw), {}, {
            fileRaw: fileRaw,
            lastModified: fileRaw.lastModified,
            name: fileRaw.name,
            size: fileRaw.size,
            type: fileRaw.type,
            percent: 0,
            status: "waiting"
          });
          var reader = new FileReader();
          reader.readAsDataURL(fileRaw);
          reader.onload = function (event) {
            var _event$target;
            uploadFile.url = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;
          };
          handleBeforeUpload(fileRaw).then(function (canUpload) {
            if (!canUpload) return;
            var newFiles = toUploadFiles.value.concat();
            if (props.allowUploadDuplicateFile || !toUploadFiles.value.find(function (file) {
              return file.name === uploadFile.name;
            })) {
              newFiles.push(uploadFile);
            }
            toUploadFiles.value = newFiles;
            if (props.autoUpload) {
              upload(uploadFile);
            }
          });
        });
      };
      var handleMockProgress = function handleMockProgress(file) {
        var timer = setInterval(function () {
          if (file.status === "success" || file.percent >= 99) {
            clearInterval(timer);
            return;
          }
          file.percent += 1;
          handleProgress({
            file: file,
            percent: file.percent,
            type: "mock"
          });
        }, 10);
      };
      var handleProgress = function handleProgress(_ref) {
        var event = _ref.event,
          file = _ref.file,
          percent = _ref.percent,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? "real" : _ref$type;
        if (!file) throw new Error("Error file");
        file.percent = Math.min(percent, 100);
        var progressCtx = {
          percent: percent,
          e: event,
          file: file,
          type: type
        };
        emitEvent("progress", progressCtx);
      };
      var handleRemove = function handleRemove(e, file, index) {
        errorMsg.value = "";
        var files = uploadedFiles.value.concat();
        files.splice(index, 1);
        setInnerFiles(files, {
          e: e,
          trigger: "remove",
          index: index,
          file: file
        });
        emitEvent("remove", {
          e: e,
          index: index,
          file: file
        });
        images.value.splice(index, 1);
      };
      var upload = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(file) {
          var request;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(!props.action && !props.requestMethod)) {
                    _context.next = 3;
                    break;
                  }
                  console.error("TDesign Upload Error: one of action and requestMethod must be exist.");
                  return _context.abrupt("return");
                case 3:
                  errorMsg.value = "";
                  file.status = "progress";
                  if (props.requestMethod) {
                    handleRequestMethod(file);
                  } else {
                    if (props.useMockProgress) {
                      handleMockProgress(file);
                    }
                    request = xhr;
                    xhrReq.value = request({
                      action: props.action,
                      data: _objectSpread$3({
                        file: file.fileRaw
                      }, props.data),
                      file: file,
                      method: props.method,
                      headers: props.headers || {},
                      withCredentials: props.withCredentials,
                      onError: handleError,
                      onProgress: handleProgress,
                      onSuccess: handleSuccess
                    });
                  }
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function upload(_x) {
          return _ref2.apply(this, arguments);
        };
      }();
      var handleRequestMethod = function handleRequestMethod(file) {
        var _props$requestMethod;
        if (!isFunction$3(props.requestMethod)) {
          console.warn("TDesign Upload Warn: `requestMethod` must be a function.");
          return;
        }
        (_props$requestMethod = props.requestMethod) === null || _props$requestMethod === void 0 ? void 0 : _props$requestMethod.call(props, file).then(function (res) {
          if (!handleRequestMethodResponse(res)) return;
          if (res.status === "success") {
            handleSuccess({
              file: file,
              response: res.response
            });
          } else if (res.status === "fail") {
            var r = res.response || {};
            handleError({
              event: void 0,
              file: file,
              response: _objectSpread$3(_objectSpread$3({}, r), {}, {
                error: res.error
              })
            });
          }
        });
      };
      var handleRequestMethodResponse = function handleRequestMethodResponse(res) {
        if (!res) {
          console.error("TDesign Upoad Error: `requestMethodResponse` is required.");
          return false;
        }
        if (!res.status) {
          console.error("TDesign Upoad Error: `requestMethodResponse.status` is missing, which value is `success` or `fail`");
          return false;
        }
        if (!["success", "fail"].includes(res.status)) {
          console.error("TDesign Upoad Error: `requestMethodResponse.status` must be `success` or `fail`");
          return false;
        }
        if (res.status === "success" && (!res.response || !res.response.url)) {
          console.warn("TDesign Upoad Warn: `requestMethodResponse.response.url` is required, when `status` is `success`");
        }
        return true;
      };
      var handleSuccess = function handleSuccess(_ref3) {
        var _res, _res2;
        var event = _ref3.event,
          file = _ref3.file,
          response = _ref3.response;
        if (!file) throw new Error("Error file");
        file.status = "success";
        var res = response;
        if (props.formatResponse && isFunction$3(props.formatResponse)) {
          res = props.formatResponse(response, {
            file: file
          });
        }
        if ((_res = res) !== null && _res !== void 0 && _res.error) {
          handleError({
            event: event,
            file: file,
            response: res,
            resFormatted: true
          });
          return;
        }
        file.url = ((_res2 = res) === null || _res2 === void 0 ? void 0 : _res2.url) || file.url;
        var index = findIndex_1(toUploadFiles.value, function (o) {
          return o.name === file.name;
        });
        toUploadFiles.value.splice(index, 1);
        var newFile = _objectSpread$3(_objectSpread$3({}, file), {}, {
          response: res
        });
        var files = uploadedFiles.value.concat(newFile);
        setInnerFiles(files, {
          e: event,
          response: res,
          trigger: "upload-success"
        });
        emitEvent("success", {
          file: file,
          fileList: files,
          e: event,
          response: res
        });
        images.value.push(newFile.url);
      };
      var handleError = function handleError(options) {
        var _res3;
        var event = options.event,
          file = options.file,
          response = options.response,
          resFormatted = options.resFormatted;
        file.status = "fail";
        var res = response;
        if (!resFormatted && props.formatResponse && isFunction$3(props.formatResponse)) {
          res = props.formatResponse(response, {
            file: file
          });
        }
        errorMsg.value = (_res3 = res) === null || _res3 === void 0 ? void 0 : _res3.error;
        if (!uploadedFiles.value.find(function (item) {
          return item.name === file.name;
        })) {
          var files = uploadedFiles.value.concat(file);
          setInnerFiles(files, {
            e: event,
            response: res,
            trigger: "upload-fail"
          });
        }
        emitEvent("fail", {
          e: event,
          file: file
        });
      };
      return _objectSpread$3(_objectSpread$3({}, vue.toRefs(props)), {}, {
        UPLOAD_NAME: UPLOAD_NAME,
        images: images,
        showViewer: showViewer,
        initialIndex: initialIndex,
        prefix: prefix$4,
        innerFiles: innerFiles,
        xhrReq: xhrReq,
        toUploadFiles: toUploadFiles,
        errorMsg: errorMsg,
        inputRef: inputRef,
        uploadedFiles: uploadedFiles,
        deleteBtnContent: deleteBtnContent,
        defaultContent: defaultContent,
        itemStyle: itemStyle,
        itemContentStyle: itemContentStyle,
        emitEvent: emitEvent,
        setInnerFiles: setInnerFiles,
        triggerUpload: triggerUpload,
        handleChange: handleChange,
        handlePreview: handlePreview,
        handleReload: handleReload,
        handleBeforeUpload: handleBeforeUpload,
        handleSizeLimit: handleSizeLimit,
        uploadFiles: uploadFiles,
        handleMockProgress: handleMockProgress,
        handleProgress: handleProgress,
        handleRemove: handleRemove,
        upload: upload,
        handleRequestMethodResponse: handleRequestMethodResponse,
        handleSuccess: handleSuccess,
        handleError: handleError
      });
    }
  });

  var _hoisted_1$2 = ["onClick"];
  var _hoisted_2$1 = ["src", "onClick"];
  var _hoisted_3 = ["value", "multiple", "accept"];
  function render$4(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    var _component_refresh_icon = vue.resolveComponent("refresh-icon");
    var _component_add_icon = vue.resolveComponent("add-icon");
    var _component_t_image_viewer = vue.resolveComponent("t-image-viewer");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createElementVNode("ul", {
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.uploadedFiles, function (file, index) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: index,
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-item")),
        style: vue.normalizeStyle(_ctx.itemStyle)
      }, [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-content ").concat(_ctx.UPLOAD_NAME, "__card-box")),
        style: vue.normalizeStyle(_ctx.itemContentStyle)
      }, [vue.createElementVNode("div", {
        key: "delete-icon",
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-delete-item")),
        onClick: function onClick(e) {
          return _ctx.handleRemove(e, file, index);
        }
      }, [_ctx.deleteBtnContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
        key: 0,
        content: _ctx.deleteBtnContent
      }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_close_icon, {
        key: 1,
        class: "close-icon"
      }))], 10, _hoisted_1$2), vue.createElementVNode("img", {
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-image")),
        src: file.url,
        onClick: function onClick(e) {
          return _ctx.handlePreview(e, file);
        }
      }, null, 10, _hoisted_2$1), file.status === "fail" ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-mask"))
      }, [vue.createElementVNode("span", {
        key: "refresh-icon",
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-mask-item"))
      }, [vue.createVNode(_component_refresh_icon, {
        onClick: function onClick($event) {
          return _ctx.handleReload(file);
        }
      }, null, 8, ["onClick"])], 2)], 2)) : vue.createCommentVNode("", true)], 6)], 6);
    }), 128)), _ctx.defaultContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.triggerUpload && _ctx.triggerUpload.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.defaultContent
    }, null, 8, ["content"])])) : (vue.openBlock(), vue.createElementBlock("li", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-item")),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.triggerUpload && _ctx.triggerUpload.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-container ").concat(_ctx.UPLOAD_NAME, "__card-box"))
    }, [vue.createVNode(_component_add_icon)], 2)], 2))], 2), vue.createElementVNode("input", {
      ref: "inputRef",
      value: _ctx.files,
      type: "file",
      multiple: _ctx.multiple,
      hidden: "",
      accept: _ctx.accept,
      onChange: _cache[2] || (_cache[2] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 40, _hoisted_3), vue.createVNode(_component_t_image_viewer, {
      images: _ctx.images,
      "onUpdate:images": _cache[3] || (_cache[3] = function ($event) {
        return _ctx.images = $event;
      }),
      modelValue: _ctx.showViewer,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = function ($event) {
        return _ctx.showViewer = $event;
      }),
      "initial-index": _ctx.initialIndex
    }, null, 8, ["images", "modelValue", "initial-index"])]);
  }

  script$5.render = render$4;

  var _Upload = withInstall(script$5);

  var NoticeBarProps = {
    content: {
      type: [String, Function]
    },
    extra: {
      type: [String, Function]
    },
    marquee: {
      type: [Boolean, Object],
      default: false
    },
    prefixIcon: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    theme: {
      type: String,
      default: "info",
      validator: function validator(val) {
        if (!val) return true;
        return ["info", "success", "warning", "error"].includes(val);
      }
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    onChange: Function,
    onClick: Function
  };

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$3 = config.prefix;
  var name$3 = "".concat(prefix$3, "-notice-bar");
  var iconDefault$1 = {
    info: vue.h(infoCircleFilled),
    success: vue.h(checkCircleFilled),
    warning: vue.h(infoCircleFilled),
    error: vue.h(closeCircleFilled)
  };
  var script$4 = vue.defineComponent({
    name: name$3,
    components: {
      TNode: TNodeComponent
    },
    props: NoticeBarProps,
    emits: ["click", "change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var state = vue.reactive({
        duration: 0,
        offset: 0,
        listWidth: 0,
        itemWidth: 0,
        timer: null,
        nextTimer: null,
        scroll: {
          marquee: false,
          speed: 50,
          loop: -1,
          delay: 0
        }
      });
      var rootClasses = vue.computed(function () {
        return ["".concat(name$3), "".concat(name$3, "--").concat(props.theme)];
      });
      var computedPrefixIcon = vue.ref();
      vue.watchEffect(function () {
        if (!props.prefixIcon && !context.slots.prefixIcon) {
          var key = props.theme;
          computedPrefixIcon.value = (iconDefault$1 === null || iconDefault$1 === void 0 ? void 0 : iconDefault$1[key]) || "";
        } else {
          computedPrefixIcon.value = renderTNode(internalInstance, "prefixIcon");
        }
      });
      var computedSuffixIcon = vue.computed(function () {
        return renderTNode(internalInstance, "suffixIcon");
      });
      var showExtraText = vue.computed(function () {
        return renderTNode(internalInstance, "extra");
      });
      var showContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      function handleClick(trigger) {
        emitEvent("click", trigger);
      }
      var animateStyle = vue.computed(function () {
        return {
          transform: state.offset ? "translateX(".concat(state.offset, "px)") : "",
          transitionDuration: "".concat(state.duration, "s"),
          transitionTimingFunction: "linear"
        };
      });
      var listDOM = vue.ref();
      var itemDOM = vue.ref();
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(visible, modelValue, props.defaultVisible, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        isShow = _useVModel2[0];
        _useVModel2[1];
      function handleScrolling() {
        var _props$marquee, _marquee$speed, _marquee$delay;
        if (!(props !== null && props !== void 0 && props.marquee) || (props === null || props === void 0 ? void 0 : (_props$marquee = props.marquee) === null || _props$marquee === void 0 ? void 0 : _props$marquee.loop) === 0) {
          return;
        }
        if (typeof props.marquee === "boolean") {
          state.scroll = _objectSpread$2(_objectSpread$2({}, state.scroll), {}, {
            marquee: props.marquee
          });
        }
        var marquee = props.marquee;
        state.scroll = {
          marquee: true,
          loop: typeof (marquee === null || marquee === void 0 ? void 0 : marquee.loop) === "undefined" ? state.scroll.loop : marquee.loop,
          speed: (_marquee$speed = marquee.speed) !== null && _marquee$speed !== void 0 ? _marquee$speed : state.scroll.speed,
          delay: (_marquee$delay = marquee.delay) !== null && _marquee$delay !== void 0 ? _marquee$delay : state.scroll.delay
        };
        setTimeout(function () {
          var _listDOM$value, _itemDOM$value;
          var listDOMWidth = (_listDOM$value = listDOM.value) === null || _listDOM$value === void 0 ? void 0 : _listDOM$value.getBoundingClientRect().width;
          var itemDOMWidth = (_itemDOM$value = itemDOM.value) === null || _itemDOM$value === void 0 ? void 0 : _itemDOM$value.getBoundingClientRect().width;
          if (itemDOMWidth > listDOMWidth) {
            state.offset = -itemDOMWidth;
            state.duration = itemDOMWidth / state.scroll.speed;
            state.listWidth = listDOMWidth;
            state.itemWidth = itemDOMWidth;
          }
        }, state.scroll.delay);
      }
      function handleTransitionend() {
        state.scroll.loop = --state.scroll.loop;
        if (state.scroll.loop === 0) {
          state.scroll = _objectSpread$2(_objectSpread$2({}, state.scroll), {}, {
            marquee: false
          });
          return;
        }
        state.offset = state.listWidth;
        state.duration = 0;
        setTimeout(function () {
          state.offset = -state.itemWidth;
          state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;
        }, 0);
      }
      vue.onMounted(function () {
        vue.nextTick(function () {
          if (isShow.value) {
            handleScrolling();
          }
        });
      });
      vue.watch(function () {
        return isShow.value;
      }, function () {
        emitEvent("change", isShow.value);
        vue.nextTick(function () {
          if (isShow.value) {
            state.offset = state.listWidth;
            state.duration = 0;
            handleScrolling();
          }
        });
      });
      return _objectSpread$2(_objectSpread$2(_objectSpread$2({
        name: name$3
      }, vue.toRefs(props)), vue.toRefs(state)), {}, {
        rootClasses: rootClasses,
        computedPrefixIcon: computedPrefixIcon,
        computedSuffixIcon: computedSuffixIcon,
        showExtraText: showExtraText,
        showContent: showContent,
        isShow: isShow,
        handleClick: handleClick,
        listDOM: listDOM,
        itemDOM: itemDOM,
        animateStyle: animateStyle,
        handleScrolling: handleScrolling,
        handleTransitionend: handleTransitionend
      });
    }
  });

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return _ctx.isShow ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [_ctx.computedPrefixIcon ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__hd")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleClick("prefix-icon");
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.computedPrefixIcon
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bd"))
    }, [vue.createElementVNode("div", {
      ref: "listDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__list ").concat(_ctx.scroll.marquee ? "".concat(_ctx.name, "__list--scrolling") : ""))
    }, [vue.createElementVNode("div", {
      ref: "itemDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__item ").concat(_ctx.showExtraText ? "".concat(_ctx.name, "__item-detail") : "")),
      style: vue.normalizeStyle(_ctx.scroll.marquee ? _ctx.animateStyle : ""),
      onTransitionend: _cache[3] || (_cache[3] = function ($event) {
        return _ctx.handleTransitionend();
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.handleClick("content");
      })
    }, [_ctx.showContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.showContent
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createTextVNode(" " + vue.toDisplayString(_ctx.content) + " ", 1), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text-detail")),
      onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
        return _ctx.handleClick("extra");
      }, ["stop"]))
    }, [_ctx.showExtraText ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.showExtraText
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createTextVNode(" " + vue.toDisplayString(_ctx.extra), 1)], 2)], 2)], 38)], 2)], 2), _ctx.computedSuffixIcon !== void 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__ft")),
      onClick: _cache[4] || (_cache[4] = function () {
        return _ctx.handleClick("suffix-icon");
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.computedSuffixIcon
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)], 2)) : vue.createCommentVNode("", true);
  }

  script$4.render = render$3;

  var _NoticeBar = withInstall(script$4);

  var resultProps = {
    description: {
      type: [String, Function]
    },
    icon: {
      type: [String, Function]
    },
    image: {
      type: [String, Function]
    },
    title: {
      type: [String, Function]
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    imageProps: {
      type: Object
    }
  };

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$2 = config.prefix;
  var name$2 = "".concat(prefix$2, "-result");
  var iconDefault = {
    default: vue.h(infoCircle),
    success: vue.h(checkCircle),
    warning: vue.h(infoCircle),
    error: vue.h(closeCircle)
  };
  var script$3 = vue.defineComponent({
    name: name$2,
    components: {
      TNode: TNodeComponent
    },
    props: resultProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descriptionContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var classes = vue.computed(function () {
        return ["".concat(name$2), "".concat(name$2, "--theme-").concat(props.theme)];
      });
      var iconContent;
      if (props.icon !== "") {
        if (Object.keys(iconDefault).includes(props === null || props === void 0 ? void 0 : props.theme)) {
          var key = props.theme;
          iconContent = vue.computed(function () {
            return iconDefault === null || iconDefault === void 0 ? void 0 : iconDefault[key];
          });
        }
        iconContent = props.icon ? vue.computed(function () {
          return renderTNode(internalInstance, "icon");
        }) : iconContent;
      }
      var baseImageProps = {
        src: props.image
      };
      var customImageProps = vue.computed(function () {
        return _objectSpread$1(_objectSpread$1({}, props.imageProps), baseImageProps);
      });
      return _objectSpread$1({
        name: name$2,
        classes: classes,
        imageContent: imageContent,
        customImageProps: customImageProps,
        iconContent: iconContent,
        titleContent: titleContent,
        descriptionContent: descriptionContent
      }, vue.toRefs(props));
    }
  });

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_image = vue.resolveComponent("t-image");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__thumb"))
    }, [_ctx.imageContent ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createBlock(_component_t_image, vue.normalizeProps(vue.mergeProps({
      key: 0
    }, _ctx.customImageProps)), null, 16)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.iconContent !== void 0 ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon")),
      content: _ctx.iconContent
    }, null, 8, ["class", "content"])) : vue.createCommentVNode("", true)], 64))], 2), _ctx.titleContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.descriptionContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descriptionContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$3.render = render$2;

  var _Result = withInstall(script$3);

  var _hoisted_1$1 = {
    key: 0,
    class: "t-cascader__steps"
  };
  var _hoisted_2 = ["onClick"];
  var script$2 = /* @__PURE__ */vue.defineComponent({
    __name: "steps",
    props: {
      items: Array,
      value: Number
    },
    emits: ["update:value"],
    setup: function setup(__props, _ref) {
      var emit = _ref.emit;
      var handleClick = function handleClick(index) {
        emit("update:value", index);
      };
      return function (_ctx, _cache) {
        return Array.isArray(__props.items) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.items, function (item, index) {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: index,
            class: "t-cascader__step",
            onClick: function onClick($event) {
              return handleClick(index);
            }
          }, [vue.createElementVNode("div", {
            class: vue.normalizeClass({
              "t-cascader__step-dot": true,
              "t-cascader__step-dot--active": index === __props.value,
              "t-cascader__step-dot--last": index === __props.items.length - 1
            })
          }, null, 2), vue.createElementVNode("div", {
            class: vue.normalizeClass({
              "t-cascader__step-label": true,
              "t-cascader__step-label--active": index === __props.value
            })
          }, vue.toDisplayString(item), 3)], 8, _hoisted_2);
        }), 128))])) : vue.createCommentVNode("", true);
      };
    }
  });

  var CascaderProps = {
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    closeIcon: {
      type: [Boolean, Function],
      default: true
    },
    title: {
      type: [String, Function],
      default: ""
    }
  };

  var CascaderItemProps = {
    value: {
      type: [String, Number],
      default: void 0
    },
    label: {
      type: [String, Function],
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    },
    index: {
      type: String,
      default: ""
    },
    children: {
      type: [Array],
      default: []
    },
    selected: {
      type: Boolean,
      default: false
    }
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$1 = config.prefix;
  var name$1 = "".concat(prefix$1, "-cascader-item");
  var script$1 = vue.defineComponent({
    name: name$1,
    components: {
      CheckIcon: check
    },
    props: CascaderItemProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var className = vue.computed(function () {
        return ["".concat(name$1), Boolean(props.active) && "active", Boolean(props.disabled) && "disabled"];
      });
      var internalInstance = vue.getCurrentInstance();
      var labelTNode = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var emitEvent = useEmitEvent(props, context.emit);
      var onSelect = function onSelect(context2) {
        emitEvent("click", {
          e: context2.e
        });
      };
      var label = vue.computed(function () {
        return props.label;
      });
      return _objectSpread({
        labelTNode: labelTNode,
        name: name$1,
        label: label,
        className: className,
        onSelect: onSelect
      }, vue.toRefs(props));
    }
  });

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_check_icon = vue.resolveComponent("check-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.className),
      onClick: _cache[0] || (_cache[0] = function ($event) {
        return _ctx.onSelect({
          e: $event
        });
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-content"))
    }, vue.toDisplayString(_ctx.label), 3), vue.withDirectives(vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-active-icon"))
    }, [vue.createVNode(_component_check_icon, {
      size: "24"
    })], 2), [[vue.vShow, _ctx.active]])], 2);
  }

  script$1.render = render$1;

  var prefix = config.prefix;
  var name = "".concat(prefix, "-cascader");
  var script = vue.defineComponent({
    name: name,
    components: {
      CloseIcon: close,
      CascaderItem: script$1,
      TNode: TNodeComponent,
      CascaderSteps: script$2
    },
    props: CascaderProps,
    emits: ["change", "cancel", "pick", "click-tab", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        cascaderValue = _useVModel2[0],
        setCascaderValue = _useVModel2[1];
      var title = vue.computed(function () {
        return props.title || "\u6807\u9898";
      });
      var closeIcon = vue.computed(function () {
        return props.closeIcon || false;
      });
      var stepIndex = vue.ref(0);
      var selectedIndexes = vue.reactive([]);
      var items = vue.reactive([props.options]);
      var steps = vue.reactive(["\u9009\u62E9\u9009\u9879"]);
      var onCancel = function onCancel(e) {
        emitEvent("cancel", {
          e: e
        });
      };
      var onStepsChange = function onStepsChange(index) {
        stepIndex.value = index;
        emitEvent("click-tab", index);
      };
      var internalInstance = vue.getCurrentInstance();
      var closeBtnTNode = vue.computed(function () {
        return renderTNode(internalInstance, "closeIcon");
      });
      var titleTNode = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var onPick = function onPick(item, index, level, e) {
        var _item$children;
        if (item.disabled) {
          return;
        }
        selectedIndexes[level] = index;
        selectedIndexes.length = level + 1;
        steps[level] = item.label;
        emitEvent("pick", item.value, index, {
          e: e
        });
        if (item !== null && item !== void 0 && (_item$children = item.children) !== null && _item$children !== void 0 && _item$children.length) {
          items[level + 1] = item.children;
          items.length = level + 2;
          stepIndex.value += 1;
          steps[level + 1] = "\u9009\u62E9\u9009\u9879";
          steps.length = level + 2;
        } else {
          setCascaderValue(item.value);
          emitEvent("change", item.value, items.map(function (item2, index2) {
            return vue.toRaw(item2[selectedIndexes[index2]]);
          }), {
            e: e
          });
        }
      };
      return {
        closeBtnTNode: closeBtnTNode,
        titleTNode: titleTNode,
        stepIndex: stepIndex,
        name: name,
        title: title,
        closeIcon: closeIcon,
        cascaderValue: cascaderValue,
        steps: steps,
        selectedIndexes: selectedIndexes,
        items: items,
        setCascaderValue: setCascaderValue,
        emitEvent: emitEvent,
        onCancel: onCancel,
        onPick: onPick,
        onStepsChange: onStepsChange
      };
    }
  });

  var _hoisted_1 = {
    style: {
      "width": "100%"
    }
  };
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    var _component_cascader_steps = vue.resolveComponent("cascader-steps");
    var _component_cascader_item = vue.resolveComponent("cascader-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__wrapper"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [!(typeof _ctx.titleTNode === "string") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.titleTNode
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)], 64))], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__close-btn")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onCancel && _ctx.onCancel.apply(_ctx, arguments);
      })
    }, [!(typeof _ctx.closeBtnTNode === "boolean") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.closeBtnTNode
    }, null, 8, ["content"])) : typeof _ctx.closeIcon === "boolean" && _ctx.closeIcon ? (vue.openBlock(), vue.createBlock(_component_close_icon, {
      key: 1,
      size: "24"
    })) : vue.createCommentVNode("", true)], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__content"))
    }, [vue.createVNode(_component_cascader_steps, {
      value: _ctx.stepIndex,
      items: _ctx.steps,
      "onUpdate:value": _ctx.onStepsChange
    }, null, 8, ["value", "items", "onUpdate:value"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__options-title"))
    }, "\u9009\u9879\u6807\u9898", 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__options-content"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (options, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index,
        style: {
          "width": "100%"
        }
      }, [vue.createVNode(vue.Transition, {
        appear: "",
        name: "slide"
      }, {
        default: vue.withCtx(function () {
          return [vue.withDirectives(vue.createElementVNode("div", _hoisted_1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(options, function (item, idx) {
            return vue.openBlock(), vue.createBlock(_component_cascader_item, vue.mergeProps({
              key: item.value
            }, item, {
              active: _ctx.selectedIndexes[index] === idx,
              onClick: function onClick($event) {
                return _ctx.onPick(item, idx, index, $event);
              }
            }), null, 16, ["active", "onClick"]);
          }), 128))], 512), [[vue.vShow, _ctx.stepIndex === index]])];
        }),
        _: 2
      }, 1024)]);
    }), 128))], 2)], 2)], 2);
  }

  script.render = render;

  var _Cascader = withInstall(script);

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Button: _Button,
    ButtonGroup: _ButtonGroup,
    Divider: Divider,
    Calendar: _Calendar,
    Cell: _Cell,
    CellGroup: _CellGroup,
    Checkbox: CheckBox,
    CheckboxGroup: CheckboxGroup,
    Input: _Input,
    Textarea: _Textarea,
    Overlay: Overlay,
    Progress: _Progress,
    Radio: _Radio,
    RadioGroup: _RadioGroup,
    Rate: _Rate,
    Switch: _Switch,
    Stepper: Stepper,
    Slider: _Slider,
    Dialog: DialogPlugin,
    Popup: _Popup,
    ActionSheet: _ActionSheet,
    Badge: _Badge,
    Fab: _Fab,
    ImageViewer: _ImageViewer,
    Drawer: _Drawer,
    Navbar: _Navbar,
    Message: MessagePlugin,
    DateTimePicker: _DateTimePicker,
    Toast: ToastPlugin,
    Search: _Search,
    Steps: Steps,
    Step: Step,
    Indexes: Indexes,
    IndexesCell: IndexesCell,
    Picker: Picker,
    Cascade: Cascade,
    Tag: Tag,
    CheckTag: CheckTag,
    TabBar: TabBar,
    TabBarItem: TabBarItem,
    DropdownMenu: DropdownMenu,
    DropdownItem: DropdownItem,
    Collapse: Collapse,
    CollapsePanel: CollapsePanel,
    Tabs: Tabs,
    TabPanel: TabPanel,
    Swiper: Swiper,
    SwiperItem: SwiperItem,
    Countdown: Countdown,
    Avatar: Avatar,
    AvatarGroup: AvatarGroup,
    Image: _Image,
    SwipeCell: SwipeCell,
    Skeleton: _Skeleton,
    Grid: Grid,
    GridItem: GridItem,
    Sticky: _Sticky,
    List: _List,
    Loading: _Loading,
    BackTop: _BackTop,
    PullDownRefresh: _PullDownRefresh,
    Upload: _Upload,
    NoticeBar: _NoticeBar,
    Result: _Result,
    Cascader: _Cascader
  });

  var install = function install(app, option) {
    Object.keys(components).forEach(function (key) {
      app.use(components[key], option);
    });
  };
  var version = "0.12.1";
  var index = {
    install: install,
    version: version
  };

  exports.ActionSheet = _ActionSheet;
  exports.Avatar = Avatar;
  exports.AvatarGroup = AvatarGroup;
  exports.BackTop = _BackTop;
  exports.Badge = _Badge;
  exports.Button = _Button;
  exports.ButtonGroup = _ButtonGroup;
  exports.Calendar = _Calendar;
  exports.Cascade = Cascade;
  exports.Cascader = _Cascader;
  exports.Cell = _Cell;
  exports.CellGroup = _CellGroup;
  exports.CheckTag = CheckTag;
  exports.Checkbox = CheckBox;
  exports.CheckboxGroup = CheckboxGroup;
  exports.Collapse = Collapse;
  exports.CollapsePanel = CollapsePanel;
  exports.Countdown = Countdown;
  exports.DateTimePicker = _DateTimePicker;
  exports.Dialog = DialogPlugin;
  exports.DialogPlugin = DialogPlugin;
  exports.Divider = Divider;
  exports.Drawer = _Drawer;
  exports.DropdownItem = DropdownItem;
  exports.DropdownMenu = DropdownMenu;
  exports.Fab = _Fab;
  exports.Grid = Grid;
  exports.GridItem = GridItem;
  exports.Image = _Image;
  exports.ImageViewer = _ImageViewer;
  exports.Indexes = Indexes;
  exports.IndexesCell = IndexesCell;
  exports.Input = _Input;
  exports.List = _List;
  exports.Loading = _Loading;
  exports.Message = MessagePlugin;
  exports.MessagePlugin = MessagePlugin;
  exports.Navbar = _Navbar;
  exports.NoticeBar = _NoticeBar;
  exports.Overlay = Overlay;
  exports.Picker = Picker;
  exports.Popup = _Popup;
  exports.Progress = _Progress;
  exports.PullDownRefresh = _PullDownRefresh;
  exports.Radio = _Radio;
  exports.RadioGroup = _RadioGroup;
  exports.Rate = _Rate;
  exports.Result = _Result;
  exports.Search = _Search;
  exports.Skeleton = _Skeleton;
  exports.Slider = _Slider;
  exports.Step = Step;
  exports.Stepper = Stepper;
  exports.Steps = Steps;
  exports.Sticky = _Sticky;
  exports.SwipeCell = SwipeCell;
  exports.Swiper = Swiper;
  exports.SwiperItem = SwiperItem;
  exports.Switch = _Switch;
  exports.TabBar = TabBar;
  exports.TabBarItem = TabBarItem;
  exports.TabPanel = TabPanel;
  exports.Tabs = Tabs;
  exports.Tag = Tag;
  exports.Textarea = _Textarea;
  exports.Toast = ToastPlugin;
  exports.ToastPlugin = ToastPlugin;
  exports.Upload = _Upload;
  exports["default"] = index;
  exports.install = install;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=tdesign.js.map
